<!DOCTYPE html>
<html>
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>张慕晖的博客</title>
  
  

  
  <link rel="alternate" href="/atom.xml" title="张慕晖的博客">
  

  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <!-- meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.6.3/css/all.min.css">
  
  
  <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css'>
  

  
  <link rel="shortcut icon" type='image/x-icon' href="/files/favicon.ico">
  

  
  <link rel="stylesheet" href="/style.css">
  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-119345306-1"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-119345306-1');
    </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  
  
</head>

<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="loading-bar-wrapper">
  <div id="loading-bar" class="pure"></div>
</div>

    <script>setLoadingBarProgress(20)</script>
    <header class="l_header pure">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
      <a class="logo flat-box" href='/' >
        
          张慕晖的博客
        
      </a>
			<div class='menu'>
				<ul class='h-list'>
          
				</ul>
			</div>

			
				<div class="m_search">
					<form name="searchform" class="form u-search-form">
						<input type="text" class="input u-search-input" placeholder="搜索" />
						<span class="icon"><i class="fas fa-search fa-fw"></i></span>
					</form>
				</div>
			
			<ul class='switcher h-list'>
				
					<li class='s-search'><a class="fas fa-search fa-fw" href='javascript:void(0)'></a></li>
				
				<li class='s-menu'><a class="fas fa-bars fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>

		<div class='nav-sub container container--flex'>
			<a class="logo flat-box"></a>
			<ul class='switcher h-list'>
				<li class='s-comment'><a class="flat-btn fas fa-comments fa-fw" href='javascript:void(0)'></a></li>
				<li class='s-toc'><a class="flat-btn fas fa-list fa-fw" href='javascript:void(0)'></a></li>
			</ul>
		</div>
	</div>
</header>
	<aside class="menu-phone">
    <header>
		<nav class="menu">
      <ul>
          
      </ul>
		</nav>
    </header>
	</aside>

    <script>setLoadingBarProgress(40);</script>
    <div class="l_body">
    <div class='container clearfix'>
        <div class='l_main'>
            



  <section class="post-list">
      



      

      

      
        
          
            <div class='post-wrapper'>
              <article class="post reveal ">
  
<section class='meta'>
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-995-minimum-number-of-k-consecutive-bit-flips/">
              
                  Leetcode 995. Minimum Number of K Consecutive Bit Flips
              
          </a>
      </h2>
    

    <div class='new-meta-box'>
      
        <div class='new-meta-item author'>
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class='notlink'>
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-21
          </a>
        </div>
      
      
        
          
          <div class='new-meta-item category'>
            <a href='/categories/Leetcode/'>
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              Leetcode
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>题目来源：<a href="https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/description/" target="_blank" rel="noopener">https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/description/</a></p>
<p>标记难度：Hard</p>
<p>提交次数：4/5</p>
<p>代码效率：</p>
<ul>
<li>暴力贪心：12.68%（5152ms）</li>
<li>线段树：52.11%（288ms）</li>
<li>O(n)：96.20%（84ms）</li>
</ul>
<h2>题意</h2>
<p>有一个只包含0和1的数组<code>A</code>，每次可以将数组<code>A</code>中的恰好连续<code>k</code>个元素取反，问能否将<code>A</code>变成全1？</p>
<h2>分析</h2>
<p>很容易就能想到一种贪心策略：找到左边第一个0，从它开始翻转连续<code>k</code>个元素（因为这个0只能在这里通过翻转而变成1，否则左边就会出现新的0），然后对于右边的0，继续进行这一操作，如果最后能成功则<code>A</code>可以变成全1。这个算法是<code>O(n*k)</code>的，或者说是<code>O(n^2)</code>的，可能太慢了。</p>
<p>很容易就能想到一种优化策略：用线段树来进行区间更新。这样复杂度就会变成<code>O(n*log(n))</code>，可以接受。</p>
<p>用线段树实在是overkill了。可以很简单地通过记录区间的开闭事件来确定当前元素是否需要取反。甚至可以不显式地记录开闭事件——如果<code>k</code>个元素之前的元素是<code>0</code>，那么现在就是一个区间的关闭。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<h2>代码</h2>
<h3>暴力贪心</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + K - <span class="number">1</span> &gt;= A.size()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; K; j++)</span><br><span class="line">                    A[i + j] = <span class="number">1</span> - A[i + j];</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3>线段树</h3>
<p>当然，这是一种比较愚蠢的做法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="keyword">bool</span> toFlip;</span><br><span class="line">        </span><br><span class="line">        TreeNode(<span class="keyword">int</span> _l = <span class="number">0</span>, <span class="keyword">int</span> _r = <span class="number">0</span>) &#123;</span><br><span class="line">            l = _l;</span><br><span class="line">            r = _r;</span><br><span class="line">            toFlip = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    TreeNode tree[<span class="number">120005</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r) tree[node].l = tree[node].r = l;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            tree[node].l = l;</span><br><span class="line">            tree[node].r = r;</span><br><span class="line">            buildTree(node * <span class="number">2</span>, l, m);</span><br><span class="line">            buildTree(node * <span class="number">2</span> + <span class="number">1</span>, m + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].r &lt; l || r &lt; tree[node].l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= tree[node].l &amp;&amp; tree[node].r &lt;= r) &#123;</span><br><span class="line">            tree[node].toFlip = !tree[node].toFlip;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].toFlip) &#123;</span><br><span class="line">            tree[node * <span class="number">2</span>].toFlip = !tree[node * <span class="number">2</span>].toFlip;</span><br><span class="line">            tree[node * <span class="number">2</span> + <span class="number">1</span>].toFlip = !tree[node * <span class="number">2</span> + <span class="number">1</span>].toFlip;</span><br><span class="line">            tree[node].toFlip = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        update(node * <span class="number">2</span>, l, r);</span><br><span class="line">        update(node * <span class="number">2</span> + <span class="number">1</span>, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].l == tree[node].r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tree[node].toFlip) <span class="keyword">return</span> !a[l];</span><br><span class="line">            <span class="keyword">return</span> a[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tree[node].toFlip) &#123;</span><br><span class="line">            tree[node * <span class="number">2</span>].toFlip = !tree[node * <span class="number">2</span>].toFlip;</span><br><span class="line">            tree[node * <span class="number">2</span> + <span class="number">1</span>].toFlip = !tree[node * <span class="number">2</span> + <span class="number">1</span>].toFlip;</span><br><span class="line">            tree[node].toFlip = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = (tree[node].l + tree[node].r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= m) <span class="keyword">return</span> query(node * <span class="number">2</span>, l);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(node * <span class="number">2</span> + <span class="number">1</span>, l);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        a = A;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        buildTree(<span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">bool</span> x = query(<span class="number">1</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (!x &amp;&amp; i + K &gt; n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span> (!x) &#123;</span><br><span class="line">                update(<span class="number">1</span>, i, i + K - <span class="number">1</span>);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3>O(n)</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minKBitFlips</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.size();</span><br><span class="line">        <span class="keyword">int</span> event[n + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memset</span>(event, <span class="number">0</span>, <span class="keyword">sizeof</span>(event));</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cur += event[i];</span><br><span class="line">            <span class="keyword">int</span> x = (A[i] + cur) % <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + K - <span class="number">1</span> &gt;= n) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                cur++;</span><br><span class="line">                ans++;</span><br><span class="line">                event[i + K]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/minimum-number-of-k-consecutive-bit-flips/discuss/238609/JavaC++Python-One-Pass-and-O(1)-Space" target="_blank" rel="noopener">les215's solution - [Java/C++/Python] One Pass and O(1) Space</a> <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
        
          <a href="/tags/Leetcode-Contest/"><i class="fas fa-hashtag fa-fw"></i>Leetcode Contest</a>
        
          <a href="/tags/alg-Greedy/"><i class="fas fa-hashtag fa-fw"></i>alg:Greedy</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class='post-wrapper'>
              <article class="post reveal ">
  
<section class='meta'>
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/codeforces-educational-codeforces-round-60-summary/">
              
                  Codeforces Educational Codeforces Round 60 总结
              
          </a>
      </h2>
    

    <div class='new-meta-box'>
      
        <div class='new-meta-item author'>
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class='notlink'>
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-20
          </a>
        </div>
      
      
        
          
          <div class='new-meta-item category'>
            <a href='/categories/Codeforces/'>
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              Codeforces
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>这次比赛做得乱七八糟，事实上一共只做出来两道题，结果rating还涨了一点点，看来确实有点难。。</p>
<h2>1117A</h2>
<p>题目来源：<a href="https://codeforces.com/contest/1117/problem/A" target="_blank" rel="noopener">https://codeforces.com/contest/1117/problem/A</a></p>
<p>提交次数：1/1</p>
<h3>题意</h3>
<p>给定一个数组，问数组中满足平均数最大的前提下长度最长的子数列。</p>
<h3>分析</h3>
<p>就是找到最大值然后计算最大值最多连续出现了多少次而已。水题。</p>
<h3>代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxn = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        maxn = max(maxn, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, l = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n || a[i] != a[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i - <span class="number">1</span>] == maxn) ans = max(l, ans);</span><br><span class="line">            l = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2>1117B</h2>
<p>题目来源：<a href="https://codeforces.com/contest/1117/problem/B" target="_blank" rel="noopener">https://codeforces.com/contest/1117/problem/B</a></p>
<p>提交次数：1/1</p>
<h3>题意</h3>
<p>给定<code>n</code>个emote，每个emote可以将对手的快乐值增加<code>a[i]</code>，你可以使用一些emote共<code>m</code>次，相同的emote最多连续使用<code>k</code>次，问最多能增加多少快乐值？</p>
<h3>分析</h3>
<p>找出值最大和值次大的emote，连续用最大的emote<code>k</code>次，用一次次大的emote，再接着用最大的emote，以此类推，直到一共用了<code>m</code>次为止。水题。</p>
<h3>代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL n, m, k;</span><br><span class="line">LL a[<span class="number">200005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    sort(a, a + n);</span><br><span class="line">    LL cnt = m / (k + <span class="number">1</span>);</span><br><span class="line">    LL ans = cnt * (a[n<span class="number">-1</span>] * k + a[n<span class="number">-2</span>]) + (m - (k + <span class="number">1</span>) * cnt) * a[n<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2>1117C</h2>
<p>题目来源：<a href="https://codeforces.com/contest/1117/problem/C" target="_blank" rel="noopener">https://codeforces.com/contest/1117/problem/C</a></p>
<p>提交次数：1/4</p>
<h3>题意</h3>
<p>你在<code>(x1, y1)</code>处有一艘船，每天可以向上或下、左、右移动1格。每天的移动效果会和天气效果叠加，天气效果会使得船根据风向往上或下、左、右移动一格。给定<code>m</code>天的天气，之后的天气是循环的，问最少需要几天，船才能到达<code>(x2, y2)</code>处？</p>
<h3>分析</h3>
<p>比赛的时候我意识到走完一个天气循环之后，能到的位置是一个菱形了（或者说是一个尖朝上的正方形）；但很可惜我没有意识到这件事的本质，还打算拿计算几何来做（？？）。显然，这件事的本质是这样的：把天气推船走的路和船自己走的路分开，可以得出一个结论：天气在一个循环内推船走的路是固定的，不妨记为<code>(dx, dy)</code>；船自己可以在这个点周围走出一个菱形，或者说是所有满足<code>|x-dx|+|y-dy|&lt;=n</code>的点。所以对天数二分查找就好了。当然，还是需要重视一下二分查找的前提：只要<code>x</code>天能到，那么<code>y&gt;=x</code>天也能到。（大不了不动）<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>除此之外就是注意上界。显然如果能到达<code>(x2, y2)</code>，每个天气循环至少要向这个方向前进1格（曼哈顿距离），所以上界是<code>(|x2-x1| + |y2-y1|)*n</code>。如果走了这么多还没到，说明到不了了。</p>
<h3>代码</h3>
<p>因为<code>long long int</code>的使用错了好多次……</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL x1, y1, x2, y2;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> s[<span class="number">100005</span>];</span><br><span class="line">pair&lt;LL, LL&gt; pos[<span class="number">100005</span>];</span><br><span class="line">LL fx, fy;</span><br><span class="line"><span class="comment">// U, R, D, L</span></span><br><span class="line"><span class="keyword">int</span> mx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> my[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isOk</span><span class="params">(LL days)</span> </span>&#123;</span><br><span class="line">    LL sx = (days / n) * fx, sy = (days / n) * fy;</span><br><span class="line">    sx += pos[days % n].first, sy += pos[days % n].second;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(x2 - sx) + <span class="built_in">abs</span>(y2 - sy) &lt;= days;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line">    x2 -= x1;</span><br><span class="line">    y2 -= y1;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> d;</span><br><span class="line">        <span class="keyword">if</span> (s[i<span class="number">-1</span>] == <span class="string">'U'</span>) d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i<span class="number">-1</span>] == <span class="string">'R'</span>) d = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i<span class="number">-1</span>] == <span class="string">'D'</span>) d = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i<span class="number">-1</span>] == <span class="string">'L'</span>) d = <span class="number">3</span>;</span><br><span class="line">        pos[i].first = pos[i<span class="number">-1</span>].first + mx[d];</span><br><span class="line">        pos[i].second = pos[i<span class="number">-1</span>].second + my[d];</span><br><span class="line">    &#125;</span><br><span class="line">    fx = pos[n].first, fy = pos[n].second;</span><br><span class="line"></span><br><span class="line">    LL l = <span class="number">0</span>, r = (<span class="built_in">abs</span>(x2) + <span class="built_in">abs</span>(y2)) * n;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        LL m = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (isOk(m)) r = m;</span><br><span class="line">        <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isOk(l)) <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2>1117D</h2>
<p>题目来源：<a href="https://codeforces.com/contest/1117/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1117/problem/D</a></p>
<p>提交次数：1/1</p>
<h3>题意</h3>
<p>一颗魔法宝石可以分裂成<code>M</code>颗普通宝石，问有多少种选择魔法宝石的方法，使得分裂后总的宝石数量是<code>N</code>？不同的魔法宝石数量和不同index的分裂被认为是不同的方法。<code>N&lt;=10^18</code>，<code>M&lt;=100</code>。</p>
<h3>分析</h3>
<p>比赛的时候我努力推了一个公式出来：</p>
<p>$$\sum_{i=0}^{\lfloor N/M \rfloor} \binom{N-(M-1)i}{i}$$</p>
<p>但是肯定不能这么算，因为<code>N</code>太大了。我心想：用动态规划估计也不行。</p>
<p>事实上得用到动态规划递推的思路，看到<code>N</code>和<code>M</code>的大小，我早该想到是矩阵快速幂才对。</p>
<p>令<code>f[n]</code>表示<code>N=n</code>时的方法数量。显然有两种方法进行递推：一种是加上一块不分裂的宝石（<code>f[n-1]</code>）；另一种是加上一块分裂的宝石（<code>f[n-M]</code>）。（虽然第二维看起来没有什么意义……）考虑到递推的本质，不需要乘新加的宝石的位置，因此：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[n] = f[n-1] + f[n-M]</span><br></pre></td></tr></table></figure>
<p>现在就可以造一个矩阵乘法迭代公式了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| f[n-M]  f[n-M+1]  ...  f[n-1] | * | 0 0 0 ... 0 1 | = | f[n-M+1] |</span><br><span class="line">                                    | 1 0 0 ... 0 0 |   | f[n-M+2] |</span><br><span class="line">                                    | 0 1 0 ... 0 0 |   |  ...     |</span><br><span class="line">                                    | 0 0 1 ... 0 0 |   | f[n-1]   |</span><br><span class="line">                                    | 0 0 0 ... 1 1 |   | f[n]     |</span><br></pre></td></tr></table></figure>
<p>然后矩阵快速幂即可。</p>
<p>太久没写矩阵快速幂，手都生了……</p>
<h3>代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL N;</span><br><span class="line"><span class="keyword">int</span> M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LL P = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    LL a[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line">    Matrix(<span class="keyword">int</span> _n, <span class="keyword">int</span> _m) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">        n = _n;</span><br><span class="line">        m = _m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> Matrix <span class="keyword">operator</span> * (<span class="keyword">const</span> Matrix&amp; m1, <span class="keyword">const</span> Matrix&amp; m2) &#123;</span><br><span class="line">        <span class="function">Matrix <span class="title">m3</span><span class="params">(m1.n, m2.m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m1.n; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m1.m; j++)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= m2.m; k++)</span><br><span class="line">                    m3.a[i][k] = (m3.a[i][k] + m1.a[i][j] * m2.a[j][k]) % P;</span><br><span class="line">        <span class="keyword">return</span> m3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">' '</span> &lt;&lt; m &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; a[i][j] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">getIdentity</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">mat</span><span class="params">(n, n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        mat.a[i][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; M) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Matrix <span class="title">v</span><span class="params">(<span class="number">1</span>, M)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; M; i++)</span><br><span class="line">        v.a[<span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">    v.a[<span class="number">1</span>][M] = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Matrix <span class="title">x</span><span class="params">(M, M)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= M; i++)</span><br><span class="line">        x.a[i][i - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    x.a[<span class="number">1</span>][M] = x.a[M][M] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    LL delta = N - M;</span><br><span class="line">    Matrix <span class="built_in">pow</span> = x;</span><br><span class="line">    Matrix ans = getIdentity(M);</span><br><span class="line">    <span class="keyword">while</span> (delta &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (delta &amp; <span class="number">1</span>) ans = ans * <span class="built_in">pow</span>;</span><br><span class="line">        delta &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">pow</span> = <span class="built_in">pow</span> * <span class="built_in">pow</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v = v * ans;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.a[<span class="number">1</span>][M] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2>1117E</h2>
<p>题目来源：<a href="https://codeforces.com/contest/1117/problem/E" target="_blank" rel="noopener">https://codeforces.com/contest/1117/problem/E</a></p>
<p>提交次数：1/1</p>
<h3>题意</h3>
<p>这是一道交互题。给定一个字符串，已知对它进行了<code>&lt;=n</code>次swap操作；你可以拿出一个新的和它长度一样的字符串，然后得到对这个字符串进行相同的swap之后的结果。你最多可以提交三次字符串。问原来的字符串是多少？</p>
<h3>分析</h3>
<p>比赛的时候，我看了看这道题……觉得很有趣，但应该想半天也做不出来吧。（我从来没在比赛里做对过交互题）这道题的一种解法是这样的：既然每次提交的字符串的swap操作是一样的，不妨把提交的三次字符串看成是一个字符串，它的每个位置是由三个字符组成的一个“超字符”。这样我们就可以认为每个位置的“超字符”是两两不等的了！因为<code>26^3 = 17576 &gt;= 1e4</code>，这是可行的。</p>
<p>然后就可以立即得到每个输入位置到输出位置的映射了，倒过来对原来的字符串重新做一遍就行了。</p>
<p>评论区里还出现了用中国剩余定理的做法，我没细看。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<h3>代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">char</span> q[<span class="number">3</span>][<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">3</span>][<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> mapping[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    n = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span><br><span class="line">                q[<span class="number">0</span>][m] = i + <span class="string">'a'</span>;</span><br><span class="line">                q[<span class="number">1</span>][m] = j + <span class="string">'a'</span>;</span><br><span class="line">                q[<span class="number">2</span>][m] = k + <span class="string">'a'</span>;</span><br><span class="line">                m++;</span><br><span class="line">                <span class="keyword">if</span> (m &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (m &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m &gt;= n) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"? "</span> &lt;&lt; q[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = (a[<span class="number">0</span>][i] - <span class="string">'a'</span>) * <span class="number">26</span> * <span class="number">26</span> + (a[<span class="number">1</span>][i] - <span class="string">'a'</span>) * <span class="number">26</span> + (a[<span class="number">2</span>][i] - <span class="string">'a'</span>);</span><br><span class="line">        mapping[idx] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"! "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s[mapping[i]];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2>1117F</h2>
<p>题目来源：<a href="https://codeforces.com/contest/1117/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1117/problem/F</a></p>
<p>提交次数：?/?</p>
<h3>题意</h3>
<p>还没看懂，感觉有点难度。</p>
<h2>111G</h2>
<p>题目来源：<a href="https://codeforces.com/contest/1117/problem/G" target="_blank" rel="noopener">https://codeforces.com/contest/1117/problem/G</a></p>
<p>提交次数：?/?</p>
<h3>题意</h3>
<p>给定一个由1到<code>n</code>的全排列组成的数组，记<code>m</code>是<code>[l, r]</code>范围内的最大元素index，定义函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(l, r) = (r - l + 1) + f(l, m - 1) + f(m + 1, r) (l &lt;= r)</span><br><span class="line">f(l, r) = 0 (l &gt; r)</span><br></pre></td></tr></table></figure>
<p>给定<code>q</code>个询问，请给定<code>f</code>的值。</p>
<p><code>1 &lt;= n, q &lt;= 1e6</code>。</p>
<h3>分析</h3>
<p>这道题我比赛的时候自然是不会做的。比赛完了，看看题解，发现也晦涩难懂。<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1]</a></sup></p>
<p>首先需要把<code>f</code>分解成两个函数，<code>fl</code>和<code>fr</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fl(l, r) = (m - l) + fl(l, m-1) + fl(m+1, r)</span><br><span class="line">fr(l, r) = (r - m) + fr(l, m-1) + fr(m+1, r)</span><br><span class="line">f(l, r) = (r - l + 1) + fl(l, r) + fr(l, r)</span><br></pre></td></tr></table></figure>
<p>可以用数学归纳法简单地证明这个分解的正确性（虽然我可不知道为什么要这样分解……）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(l, r) = (r - l + 1) + fl(l, r) + fr(l, r)</span><br><span class="line">        = (r - l + 1) + fl(l, m-1) + fl(m+1, r) + (m - l)</span><br><span class="line">                      + fr(l, m-1) + fr(m+1, r) + (r - m)</span><br><span class="line">        = (r - l + 1) + f(l, m-1) - (m-1 - l + 1) + f(m+1, r) - (r - (m+1) + 1) + (r - l)</span><br><span class="line">        = (r - l + 1) + f(l, m-1) + f(m+1, r)</span><br></pre></td></tr></table></figure>
<p>然后不妨举一个例子来看看<code>fl</code>是怎么算出来的：</p>
<p><img src="tree.jpg" alt="fl的例子"></p>
<p>（显然<code>fl(i, i) = fr(i,i) = 0</code>）</p>
<p>把这些式子全部展开，就会变成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fl(1, 6) = (3-1) + fl(1, 2) + fl(4, 6)</span><br><span class="line">         = (3-1) + (1-1) + fl(2, 2) + (4-4) + fl(5, 6)</span><br><span class="line">         = (3-1) + (1-1) + (2-2) + (4-4) + (6-5) + fl(5, 5)</span><br><span class="line">         = (3-1) + (1-1) + (2-2) + (4-4) + (6-5) + (5, 5)</span><br></pre></td></tr></table></figure>
<p>可以看出，<code>fl</code>其实是由6项组成的，而且每一项都是某个<code>l &lt;= i &lt;= r</code>与它左边最近的比它小的元素（或者<code>l</code>）之间的距离。这么想其实很合理。记<code>i</code>左边离它最近的比它大的元素为<code>lf[i]</code>，可以看出，它对<code>fl(l, r)</code>产生贡献当且仅当它被作为最大元素选中了，且贡献大小为<code>min(i - l, i - lf[i] - 1)</code>。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://codeforces.com/blog/entry/65365" target="_blank" rel="noopener">Educational Codeforces Round 60 Editorial</a> <a href="#fnref1" class="footnote-backref">↩</a> <a href="#fnref1:1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://codeforces.com/blog/entry/65365?#comment-493763" target="_blank" rel="noopener">saeed_odak's comment for 1117E</a> <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/Codeforces/"><i class="fas fa-hashtag fa-fw"></i>Codeforces</a>
        
          <a href="/tags/Codeforces-Contest/"><i class="fas fa-hashtag fa-fw"></i>Codeforces Contest</a>
        
          <a href="/tags/alg-Binary-Search/"><i class="fas fa-hashtag fa-fw"></i>alg:Binary Search</a>
        
          <a href="/tags/alg-Math/"><i class="fas fa-hashtag fa-fw"></i>alg:Math</a>
        
          <a href="/tags/alg-Matrix/"><i class="fas fa-hashtag fa-fw"></i>alg:Matrix</a>
        
          <a href="/tags/alg-Segmentation-Tree/"><i class="fas fa-hashtag fa-fw"></i>alg:Segmentation Tree</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class='post-wrapper'>
              <article class="post reveal ">
  
<section class='meta'>
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-994-rotting-oranges/">
              
                  Leetcode 994. Rotting Oranges（BFS）
              
          </a>
      </h2>
    

    <div class='new-meta-box'>
      
        <div class='new-meta-item author'>
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class='notlink'>
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-19
          </a>
        </div>
      
      
        
          
          <div class='new-meta-item category'>
            <a href='/categories/Leetcode/'>
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              Leetcode
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>题目来源：<a href="https://leetcode.com/problems/cousins-in-binary-tree/description/" target="_blank" rel="noopener">https://leetcode.com/problems/cousins-in-binary-tree/description/</a></p>
<p>标记难度：Easy</p>
<p>提交次数：1/1</p>
<p>代码效率：12ms</p>
<h2>题意</h2>
<p>在一个四连通图上有若干个橘子，其中有一些是烂的，烂橘子每秒都会向四连通的橘子扩散，问经过多少秒，所有的橘子会烂掉？</p>
<h2>分析</h2>
<p>前几天在CF上做过一道有点类似的题（<a href="https://codeforces.com/problemset/problem/1105/D" target="_blank" rel="noopener">1105D</a>，也是BFS分次扩展，当时虽然过了pretest，却因为每次扩展的结点过多且<code>queue</code>初始化过慢超时了。所以我就学到了一个道理：在这种情况下注意到底应该扩展哪些结点。不过这道题其实没有这个必要……</p>
<p>考虑到这一点，不如直接用<code>vector</code>代替<code>queue</code>。</p>
<h2>代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orangesRotting</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">int</span> orangeCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size(), m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> mx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> my[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="number">0</span>) orangeCnt++;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) q.emplace_back(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (q.size() == orangeCnt) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 全都烂了</span></span><br><span class="line">        <span class="keyword">if</span> (q.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 根本没有烂的</span></span><br><span class="line">        <span class="comment">// [lastEnd, lastSize)这部分是本次需要扩展的</span></span><br><span class="line">        <span class="comment">// 之前的已经扩展过了，没有再扩展一次的必要</span></span><br><span class="line">        <span class="keyword">int</span> lastEnd = <span class="number">0</span>, lastSize = q.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = lastEnd; j &lt; lastSize; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = q[j].first, y = q[j].second;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> nx = x + mx[k], ny = y + my[k];</span><br><span class="line">                    <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx &gt;= n || ny &lt; <span class="number">0</span> || ny &gt;= m) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[nx][ny] = <span class="number">2</span>;</span><br><span class="line">                        q.emplace_back(nx, ny);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 本次没有扩展出新的烂橘子，且还有橘子没烂，说明扩展不到那边了</span></span><br><span class="line">            <span class="keyword">if</span> (lastSize == q.size()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 所有橘子都烂了</span></span><br><span class="line">            <span class="keyword">if</span> (q.size() == orangeCnt) <span class="keyword">return</span> i;</span><br><span class="line">            lastEnd = lastSize;</span><br><span class="line">            lastSize = q.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
        
          <a href="/tags/Leetcode-Contest/"><i class="fas fa-hashtag fa-fw"></i>Leetcode Contest</a>
        
          <a href="/tags/alg-Breadth-first-Search/"><i class="fas fa-hashtag fa-fw"></i>alg:Breadth-first Search</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class='post-wrapper'>
              <article class="post reveal ">
  
<section class='meta'>
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-993-cousins-in-binary-tree/">
              
                  Leetcode 993. Cousins in Binary Tree（树）
              
          </a>
      </h2>
    

    <div class='new-meta-box'>
      
        <div class='new-meta-item author'>
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class='notlink'>
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-19
          </a>
        </div>
      
      
        
          
          <div class='new-meta-item category'>
            <a href='/categories/Leetcode/'>
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              Leetcode
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>题目来源：<a href="https://leetcode.com/problems/cousins-in-binary-tree/description/" target="_blank" rel="noopener">https://leetcode.com/problems/cousins-in-binary-tree/description/</a></p>
<p>标记难度：Easy</p>
<p>提交次数：1/1</p>
<p>代码效率：8ms</p>
<h2>题意</h2>
<p>定义二叉树中的“堂兄弟”结点：两个深度相同且父结点不同的结点。给定一棵结点值互异的二叉树和两个树中的结点值<code>x</code>和<code>y</code>，问这两个结点是否为堂兄弟。</p>
<h2>分析</h2>
<p>只要遍历二叉树，并记录对应的两个结点的父节点和深度即可。不过为了降低复杂度，甚至可以干脆把每个结点的父节点和深度都记录下来，然后在里面查。</p>
<h2>代码</h2>
<p>这里遍历用的是DFS。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> father[<span class="number">102</span>];</span><br><span class="line">    <span class="keyword">int</span> depth[<span class="number">102</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> d, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        father[root-&gt;val] = p;</span><br><span class="line">        depth[root-&gt;val] = d;</span><br><span class="line">        dfs(root-&gt;left, d + <span class="number">1</span>, root-&gt;val);</span><br><span class="line">        dfs(root-&gt;right, d + <span class="number">1</span>, root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isCousins</span><span class="params">(TreeNode* root, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        dfs(root, <span class="number">0</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> depth[x] == depth[y] &amp;&amp; father[x] != father[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
        
          <a href="/tags/Leetcode-Contest/"><i class="fas fa-hashtag fa-fw"></i>Leetcode Contest</a>
        
          <a href="/tags/alg-Tree/"><i class="fas fa-hashtag fa-fw"></i>alg:Tree</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class='post-wrapper'>
              <article class="post reveal ">
  
<section class='meta'>
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/centroid-decomposition-summaary-and-example/">
              
                  重心剖分（Centroid Decomposition）简介及例题
              
          </a>
      </h2>
    

    <div class='new-meta-box'>
      
        <div class='new-meta-item author'>
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class='notlink'>
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-16
          </a>
        </div>
      
      
        
          
          <div class='new-meta-item category'>
            <a href='/categories/Codeforces/'>
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              Codeforces
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>这篇文章主要参考了<a href="https://codeforces.com/blog/entry/52492" target="_blank" rel="noopener">Centroid Decomposition</a>和<a href="https://medium.com/carpanese/an-illustrated-introduction-to-centroid-decomposition-8c1989d53308" target="_blank" rel="noopener">An illustrated introduction to centroid decomposition</a>两篇文章。</p>
<hr>
<h2>问题的描述</h2>
<p>首先给出一道例题：<a href="http://codeforces.com/problemset/problem/342/E" target="_blank" rel="noopener">Codeforces 342E. Xenia and Tree</a>。这道题的题意是这样的：有一棵结点数量为<code>n</code>的树，结点标号为1到<code>n</code>。起始时，结点1是红色的，其他结点都是蓝色的。编程处理以下两种查询：</p>
<ul>
<li><code>update(a)</code>：将<code>a</code>更新为红色</li>
<li><code>query(a)</code>：查询<code>a</code>离最近的红色点的距离</li>
</ul>
<p><img src="xenia.png" alt="两种颜色的结点"></p>
<p>可以立刻想到两种解法：</p>
<ol>
<li>查询时做BFS/DFS（<code>O(N)</code>），更新时直接更新（<code>O(1)</code>）</li>
<li>维护每个结点到最近的红色点的距离，查询时直接查询（<code>O(1)</code>），更新时做BFS/DFS（<code>O(N)</code>）</li>
</ol>
<p>显然这两种解法都不够好。重心剖分（Centroid Decomposition，以下简写为CD）则可以在这两种方法之间取得平衡，使得查询和更新的代价都变成<code>O(log(N))</code>。</p>
<h3>重心的定义</h3>
<p>记树的总结点数为<code>n</code>，定义树的重心为，移除后使得留下的所有连通分量（树）的大小均不超过<code>n/2</code>的结点。</p>
<p><img src="centroid-def.gif" alt="一个重心的例子"></p>
<p>请注意：重心不是中心。</p>
<h3>如何找到树的重心？</h3>
<p>下面给出一种计算树的重心的算法。首先任取结点<code>a</code>，以<code>a</code>为树的根结点，计算它的所有子树的大小。如果这些子树的大小均不超过<code>n/2</code>，则<code>a</code>就是重心。否则，必然存在一棵（且只能有一棵——这一点是平凡的）子树，大小超过<code>n/2</code>。记<code>b</code>为该子树的根结点，对<code>b</code>重复上述算法。</p>
<p><img src="centroid-alg.gif" alt="上述算法的执行过程"></p>
<p>对<code>b</code>来说，以<code>a</code>为根的子树的大小必然不超过<code>n/2</code>，因此算法不会重复访问已经访问过的结点，因此算法是正确的，它的复杂度是<code>O(n)</code>。</p>
<p><img src="centroid-alg-proof.png" alt="为什么算法是正确的"></p>
<p>在具体实现中，以<code>a</code>为根结点，首先用DFS求出每棵子树的大小；然后用DFS寻找重心。因为算法不需要重复访问已经访问过的结点，因此对于每个结点，考虑它的子结点对应的子树大小即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> subSize[N];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; tree[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子树大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    subSize[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: tree[u])</span><br><span class="line">        <span class="keyword">if</span> (v != p)</span><br><span class="line">            subSize[u] += dfs(v, u);</span><br><span class="line">    <span class="keyword">return</span> subSize[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算重心</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_centroid</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: tree[u])</span><br><span class="line">        <span class="keyword">if</span> (v != p &amp;&amp; subSize[v] &gt; n/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> get_centroid(v, u, n);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3>练习</h3>
<p>练习1：请证明每棵树最多只有一个重心，或者给出反例。</p>
<p>反例：如下图。</p>
<p><img src="one-centroid.png" alt="蓝色和红色结点各表示一个重心"></p>
<p>练习2：在什么样的树中，中心和重心是相同的？</p>
<p>我感觉，计算出重心之后，以重心为根的树中，如果深度最大的两棵子树的深度相等或只相差1，那么中心等于重心。</p>
<h2>什么是重心剖分？</h2>
<p>树的重心剖分是另一棵树，它递归定义为：</p>
<ul>
<li>树根是原树的重心</li>
<li>树根的子结点是原树中移除重心后留下的子树的重心</li>
</ul>
<p><img src="cd.png" alt="一棵树的重心剖分"></p>
<h3>实现</h3>
<p>直接按照定义实现这棵树即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> subSize[N];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; tree[N];  <span class="comment">// 为了方便删除……</span></span><br><span class="line"><span class="keyword">int</span> cd_father[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子树大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    subSize[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: tree[u])</span><br><span class="line">        <span class="keyword">if</span> (v != p)</span><br><span class="line">            subSize[u] += dfs(v, u);</span><br><span class="line">    <span class="keyword">return</span> subSize[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算重心</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_centroid</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: tree[u])</span><br><span class="line">        <span class="keyword">if</span> (v != p &amp;&amp; subSize[v] &gt; n/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> get_centroid(v, u, n);</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重心分解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">centroid_decomposition</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = dfs(u, p);</span><br><span class="line">    <span class="keyword">int</span> centroid = get_centroid(u, p, n);</span><br><span class="line">    cd_father[centroid] = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v: tree[centroid])</span><br><span class="line">        <span class="keyword">if</span> (v != p) &#123;</span><br><span class="line">            tree[v].erase(centroid);</span><br><span class="line">            centroid_decomposition(v, centroid);</span><br><span class="line">        &#125;</span><br><span class="line">    tree[centroid].clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3>时间复杂度</h3>
<p>建树的时间复杂度是多少？首先可以给出一个时间复杂度的上界：因为需要对每个结点都执行一次<code>centroid_decomposition</code>，且<code>dfs</code>的代价最多为<code>O(n)</code>，因此时间复杂度最多为<code>O(n^2)</code>。</p>
<p>不过事实上并没有那么多。对每个结点执行<code>centroid_decomposition</code>时，对应的连通分量大小已经大大减小了，所以<code>dfs</code>的代价也降低了——这是因为根据重心的性质，每个连通分量的大小最多为<code>n/2</code>。事实上这就类似于归并排序的分析：</p>
<p><img src="complexity.png" alt="每一层的代价之和都是O(n)"></p>
<p>因为树的高度是<code>O(log(n))</code>，因此总时间复杂度为<code>O(n*log(n))</code>。</p>
<p>而且实现中移除边的过程不会影响总时间复杂度，因为最多有<code>O(n)</code>条边需要移除，而移除每条边的代价最多是<code>O(log(n))</code>。（当然，你也可以不这么实现，省一点常数。）</p>
<h3>重心剖分的性质</h3>
<ol>
<li>在CD树中，结点属于它的所有祖先对应的连通分量。</li>
</ol>
<p><img src="centroid-property.png" alt="结点14属于14、15、11和3对应的连通分量"></p>
<p>证明：在CD树中，结点<code>a</code>是<code>b</code>的子结点，仅当<code>a</code>属于移除<code>b</code>后产生的连通分量。显然这件事的前提是，<code>a</code>属于<code>b</code>对应的连通分量。（这听起来是平凡的。）</p>
<ol start="2">
<li>原树中结点<code>a</code>到结点<code>b</code>的最短路可以分解成结点<code>a</code>到<code>lca(a, b)</code>和<code>lca(a, b)</code>到<code>b</code>的两条路径，其中<code>lca(a, b)</code>是CD树中<code>a</code>和<code>b</code>的LCA。</li>
</ol>
<p><img src="cd-property-2.png" alt="原树中从9到10的最短路可以分解成从9到3的路径和从3到10的路径。"></p>
<p>证明：由性质1，<code>a</code>和<code>b</code>都属于<code>lca(a, b)</code>对应的连通分量。假定<code>lca(a, b)</code>并不在从<code>a</code>到<code>b</code>的最短路上，则在原树中移除<code>lca(a, b)</code>后，<code>a</code>和<code>b</code>仍然在同一个连通分量中，这意味着该连通分量的重心是<code>a</code>和<code>b</code>的比<code>lca(a, b)</code>更低的共同祖先，这显然是荒谬的。</p>
<ol start="3">
<li>原树中的<code>n^2</code>条路径（此处把退化的路径也算进去了）均可分解成两条路径，这两条路径都属于在CD树中每个结点到它的所有祖先结点的共<code>O(n*log(n))</code>条路径的集合。（听起来真是晦涩……）</li>
</ol>
<p>这个性质比较难，但非常重要。以下图为例：</p>
<p><img src="centroid-property.png" alt="结点14属于14、15、11和3对应的连通分量"></p>
<p>共有<code>n</code>条从结点14开始的路径。这些路径可以分成以下几类：</p>
<ol>
<li><code>a in {14}</code>：从14到14，再从14到<code>a</code></li>
<li><code>a in {15}</code>：从14到15，再从15到<code>a</code></li>
<li><code>a in {6, 9, 13}</code>：从14到11，再从11到<code>a</code></li>
<li><code>a in {1, 2, 4, 5, 7, 8, 10, 12}</code>：从14到3，再从3到<code>a</code></li>
</ol>
<p>显然14、15、11和3都是14在CD树中的祖先。这种分类方法的思路是这样的：不是选择路径的两个端点，而是选择两个结点在CD树中的LCA。</p>
<p>证明1：性质2说明，原树中的每条路径都可以分解成两条路径（<code>a</code>到<code>lca(a, b)</code>，以及<code>lca(a, b)</code>到<code>b</code>）。下面证明从每个结点到它的CD树中祖先结点的路径总数是<code>O(n*log(n))</code>。显然CD树的高度是<code>O(log(n))</code>，共有<code>n</code>个结点，所以祖先总数是<code>O(n*log(n))</code>。</p>
<p>证明2：这次考虑CD树中每个结点的后代数量。显然根结点的后代总数是<code>n-1</code>，而且每一层的结点的后代总数都是<code>O(n)</code>，因此总路径数为<code>O(n*log(n))</code>。</p>
<h3>练习</h3>
<p>练习3：给定下图中的CD树，求原树。是否有多个可能的答案？</p>
<p><img src="ex3-tree.png" alt="CD树"></p>
<p>这棵树看起来好像很有问题，居然有重复结点，算了不管它了。。。不过显然CD树和原树不是一一对应的，举个最简单的例子，如果连通分量只剩下两个结点，那么这两个结点哪一个做重心都可以。</p>
<p>练习4：证明每棵CD树都是自己的CD树，或者举出反例。</p>
<p>证明：由CD树的构造过程可知，对于CD树的每棵子树，记其大小为<code>n</code>，去掉根结点后剩下的的每棵子树的大小均不超过<code>n/2</code>。这是因为每棵子树都是和一个联通分量对应的。因此，对CD树做重心剖分时，只需取每层的根结点为重心即可。</p>
<p>练习5：考虑以下陈述：“对于任意有根树，从<code>a</code>到<code>b</code>的路径都可以分解成从<code>a</code>到<code>lca(a, b)</code>的路径和从<code>lca(a, b)</code>到<code>b</code>的路径，这样我们就可以应用性质3中的方法进行处理。”如果这是真的，我们为什么需要重心剖分？</p>
<p>答：这确实是真的，但对于高度没有限制的树，这么做没有意义。考虑退化成一条链的树，根结点的后代数量是<code>n-1</code>，深度为1的结点的后代数量是<code>n-2</code>，以此类推，得到的分解路径总数是<code>n(n-1)/2</code>，和树中所有路径总数的数量级相同，没法起到简化表示的作用。</p>
<h2>例题</h2>
<h3><a href="https://codeforces.com/contest/342/problem/E" target="_blank" rel="noopener">Codeforces 342E. Xenia and Tree</a></h3>
<h4>题意</h4>
<p>略</p>
<h4>分析</h4>
<p>这道题就是上面讲解时用到的例题，应该很好理解。将树进行重心剖分之后，每两个结点之间的距离都可以分解成它们在原树中到重心剖分树中的LCA的距离。这句话听起来太绕了，不如说，对于每两个结点，它们在重心剖分树中的LCA必然会出现在它们在原树中的最短路径上。从这就可以直接推导出，原树中的每条路径都能以两个端点在重心剖分树中的LCA为终点分解成两条路径。</p>
<p>所以我们可以考虑用<code>ans</code>来维护重心剖分树中每个结点到它的子树中最近的红色结点的距离。初始时，<code>ans[a] = inf</code>（之后才将第一个结点涂成红色）。</p>
<p><img src="xenia-cd.png" alt="左侧是染色的原树，右侧是重心剖分和连通分量。"></p>
<p>对于每个<code>update(a)</code>操作，因为<code>a</code>出现在它的祖先结点对应的分量中，所以只需对它的每个祖先结点<code>b</code>，更新<code>ans[b] = min(ans[b], dist(a, b))</code>。由于树的高度为<code>O(log(n))</code>，计算<code>dist(a, b)</code>的复杂度是<code>O(log(n))</code>，因此更新操作的复杂度是<code>O(log^2(n))</code>。</p>
<p>对于每个<code>query(a)</code>操作，只需对它的所有祖先结点<code>b</code>，取<code>dist(a, b) + ans[b]</code>的最小值。如果记<code>ans[b]</code>对应的结点为<code>c</code>，则我们实际上是把从<code>a</code>到<code>c</code>的路径分解成了从<code>a</code>到<code>b</code>的路径（<code>dist(a, b)</code>）和从<code>b</code>到<code>c</code>的路径（<code>ans[b]</code>）。这意味着<code>dist(a, b) + ans[b]</code>是从<code>a</code>到<code>b</code>对应的连通分量中离<code>b</code>最近的红色结点的距离。查询操作的时间复杂度也是<code>O(log^2(n))</code>。</p>
<hr>
<p>我花了特别久的时间debug。模板背错之后出现的那些问题就不说了——一背错就很可能会死循环。首先，照原文中那种删除边的写法是行不通的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = dfs(u, p); <span class="comment">// find the size of each subtree</span></span><br><span class="line">    <span class="keyword">int</span> centroid = dfs(u, p, n); <span class="comment">// find the centroid</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">-1</span>) p = centroid; <span class="comment">// dad of root is the root itself</span></span><br><span class="line">    dad[centroid] = p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for each tree resulting from the removal of the centroid</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : tree[centroid])</span><br><span class="line">        <span class="comment">// v被删除后，指针就失效了，肯定会挂</span></span><br><span class="line">        tree[centroid].erase(v), <span class="comment">// remove the edge to disconnect</span></span><br><span class="line">        tree[v].erase(centroid), <span class="comment">// the component from the tree</span></span><br><span class="line">        build(v, centroid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改成不会产生指针失效的版本也不行，会超时。我目前看到了两种比较好的解决方案：</p>
<ul>
<li>仍然用<code>set</code>，但是在<code>for</code>循环中不从<code>centroid</code>对应的<code>set</code>删除，在<code>for</code>循环结束后再统一清空</li>
<li>改用<code>vector</code>，单独记录删除标记</li>
</ul>
<p>然后我想了想，觉得自己的LCA写的恐怕大有问题（因为太久没写了），于是就找了个地方，抄了一下LCA的主要计算过程。这之后我觉得没有什么问题了，但是交上去却持续WA。我感到很困惑，查了又查，却找不到什么错误。最后我找到了一份相当不错的结构和我类似的<a href="https://codeforces.com/contest/342/submission/23224047" target="_blank" rel="noopener">参考代码</a>，抱着“模块化debug”的心情把我的代码中的LCA整个换成了这份代码里的LCA——</p>
<p>结果竟然就过了！！！</p>
<p>原来我太久没写LCA，把初始化时求<code>2^k</code>级祖先的内外循环给搞反了。推导<code>father[i][j]</code>时可能需要的<code>father[?][j-1]</code>的第一维是不确定的，因此应该把<code>j</code>放在外层循环。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lca_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">21</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            father[i][j] = father[father[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4>代码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[<span class="number">100002</span>];</span><br><span class="line"><span class="keyword">bool</span> deleted[<span class="number">100002</span>];</span><br><span class="line"><span class="keyword">int</span> subTreeSize[<span class="number">100002</span>];</span><br><span class="line"><span class="keyword">int</span> cd_father[<span class="number">100002</span>];</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">100002</span>][<span class="number">21</span>];</span><br><span class="line">LL dist[<span class="number">100002</span>];</span><br><span class="line">LL ans[<span class="number">100002</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算父结点和结点深度（用于LCA）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> parent, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    father[cur][<span class="number">0</span>] = parent == <span class="number">-1</span> ? cur : parent;</span><br><span class="line">    dist[cur] = depth;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u: G[cur])</span><br><span class="line">        <span class="keyword">if</span> (u != parent) &#123;</span><br><span class="line">            dfs(u, cur, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LCA初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lca_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">21</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            father[i][j] = father[father[i][j<span class="number">-1</span>]][j<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算x和y的LCA</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dist[x] &lt; dist[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">int</span> d = dist[x] - dist[y];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            x = father[x][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (father[x][i] != father[y][i]) &#123;</span><br><span class="line">            x = father[x][i];</span><br><span class="line">            y = father[y][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> father[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据LCA和深度计算x和y在树中的距离</span></span><br><span class="line"><span class="function">LL <span class="title">get_dist</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = get_lca(x, y);</span><br><span class="line">    <span class="keyword">return</span> dist[x] + dist[y] - <span class="number">2</span> * dist[fa];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算子树大小（每次重心剖分的子树都需要）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_size</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">    subTreeSize[cur] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u: G[cur]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!deleted[u] &amp;&amp; u != parent) &#123;</span><br><span class="line">            get_size(u, cur);</span><br><span class="line">            subTreeSize[cur] += subTreeSize[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算重心</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_centroid</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> parent, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u: G[cur]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!deleted[u] &amp;&amp; u != parent &amp;&amp; subTreeSize[u] &gt; n / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> get_centroid(u, cur, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归进行重心剖分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">centroid_decomposition</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">    get_size(cur, parent);</span><br><span class="line">    <span class="keyword">int</span> centroid = get_centroid(cur, parent, subTreeSize[cur]);</span><br><span class="line">    cd_father[centroid] = parent;</span><br><span class="line">    <span class="comment">// 这里采取的则是一种比较愚蠢的策略，单独为结点记录了删除标记……</span></span><br><span class="line">    deleted[centroid] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u: G[centroid])</span><br><span class="line">        <span class="keyword">if</span> (!deleted[u] &amp;&amp; u != parent)</span><br><span class="line">            centroid_decomposition(u, centroid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将a更新为红色结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = a;</span><br><span class="line">    <span class="comment">// 对于a在CD树中的每个祖先（包括a），更新a到它的距离</span></span><br><span class="line">    <span class="comment">// 注意不是a在CD树中到它的距离！！！</span></span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">-1</span>) &#123;</span><br><span class="line">        ans[b] = min(ans[b], get_dist(a, b));</span><br><span class="line">        b = cd_father[b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询a和最近的红色结点之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = a;</span><br><span class="line">    LL x = <span class="number">1e9</span>;</span><br><span class="line">    <span class="comment">// 对于a在CD树中的每个祖先（包括a），取答案为（a到该祖先的距离+该祖先到最近红色结点距离）的最小值</span></span><br><span class="line">    <span class="comment">// 注意距离不是CD树中的距离！！！</span></span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">-1</span>) &#123;</span><br><span class="line">        x = min(x, ans[b] + get_dist(a, b));</span><br><span class="line">        b = cd_father[b];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">int</span> t, v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一些必要的初始化</span></span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    lca_init();</span><br><span class="line">    centroid_decomposition(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        ans[i] = <span class="number">1e9</span>;</span><br><span class="line">    update(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;t, &amp;v);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">1</span>) update(v);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3><a href="https://codeforces.com/contest/321/problem/C" target="_blank" rel="noopener">Codeforces 321C. Ciel the Commander</a></h3>
<h4>题意</h4>
<p>给定一棵树，要求把上面的所有结点用<code>A</code>到<code>Z</code>标记，使得对于任意两个标记相同的结点，它们之间的最短路上至少有一个标记（字典序）更小的结点。</p>
<h4>分析</h4>
<p>只要会重心剖分，想到这道题要用到重心剖分并不难（……这好像是句废话，考虑到这道题是作为例题出现的……），所以难点在于如何证明重心剖分得到的是最优解。（对于实现而言，这并不是个难点）</p>
<p><a href="https://codeforces.com/blog/entry/8192" target="_blank" rel="noopener">题解</a>里给出了两种证明思路。第一种是自顶向下构造。显然，rank为A的结点只能有一个。选定一个结点为rank A之后，树会被分成几个连通分量，这些连通分量之间不会有非法路径（因为必须要通过这个结点），所以可以单独考虑这些连通分量，于是我们得到了一个递归解法。问题是应该怎么选择A。单从连通分量的大小来考虑，我们希望这些连通分量的大小尽量小，所以不妨取rank A结点为重心。然后判断CD树的高度是否大于26就行。</p>
<p>不过，问题是我觉得不能单从连通分量的大小来考虑。但到底怎么考虑比较好，这个我也不知道……</p>
<h4>代码</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; g[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> cd_father[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> subSize[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> cd_depth[<span class="number">100005</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> maxDepth;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_size</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    subSize[cur] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u: g[cur])</span><br><span class="line">        <span class="keyword">if</span> (u != p)</span><br><span class="line">            subSize[cur] += get_size(u, cur);</span><br><span class="line">    <span class="keyword">return</span> subSize[cur];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_centroid</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> p, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u: g[cur])</span><br><span class="line">        <span class="keyword">if</span> (u != p &amp;&amp; subSize[u] &gt; n / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> get_centroid(u, cur, n);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">centroid_decomposition</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> p, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = get_size(cur, p);</span><br><span class="line">    <span class="keyword">int</span> centroid = get_centroid(cur, p, n);</span><br><span class="line">    cd_father[centroid] = p;</span><br><span class="line">    cd_depth[centroid] = depth;</span><br><span class="line">    maxDepth = max(depth, maxDepth);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> u: g[centroid])</span><br><span class="line">        <span class="keyword">if</span> (u != p) &#123;</span><br><span class="line">            g[u].erase(centroid);</span><br><span class="line">            centroid_decomposition(u, centroid, depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    g[centroid].clear();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].insert(v);</span><br><span class="line">        g[v].insert(u);</span><br><span class="line">    &#125;</span><br><span class="line">    centroid_decomposition(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (maxDepth &gt;= <span class="number">26</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Impossible!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>) (cd_depth[i] + <span class="string">'A'</span>) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/alg-Centroid-Decomposition/"><i class="fas fa-hashtag fa-fw"></i>alg:Centroid Decomposition</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class='post-wrapper'>
              <article class="post reveal ">
  
<section class='meta'>
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/codeforces-global-round-1/">
              
                  Codeforces Global Round 1总结
              
          </a>
      </h2>
    

    <div class='new-meta-box'>
      
        <div class='new-meta-item author'>
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class='notlink'>
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-14
          </a>
        </div>
      
      
        
          
          <div class='new-meta-item category'>
            <a href='/categories/Codeforces/'>
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              Codeforces
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>因为写总结和做题实在太艰难了，我决定以后CF每场比赛只写一篇总结……</p>
<h2>1110A</h2>
<p>题目来源：<a href="https://codeforces.com/contest/1110/problem/A" target="_blank" rel="noopener">https://codeforces.com/contest/1110/problem/A</a></p>
<p>提交次数：1/1</p>
<h3>题意</h3>
<h3>分析</h3>
<h3>代码</h3>
<h2>1110D</h2>
<p>题目来源：<a href="https://codeforces.com/contest/1110/problem/D" target="_blank" rel="noopener">https://codeforces.com/contest/1110/problem/D</a></p>
<p>提交次数：1/1</p>
<h3>题意</h3>
<p>给定若干个1和m之间的整数，定义triplet为形如<code>(x, x, x)</code>或<code>(x, x+1, x+2)</code>的元组，问这些整数最多一共能组成多少个triplet？</p>
<h3>分析</h3>
<p>这道题有一个非常必要的观察：如果有大于等于三个的形如<code>[x, x+1, x+2]</code>的triplet，那么完全可以把其中的三个替换成<code>[x, x, x]</code>，<code>[x+1, x+1, x+1]</code>和<code>[x+2, x+2, x+2]</code>。这也就意味着对于每一个<code>x</code>，形如<code>[x-2, x-1, x]</code>的triplet最多只有2个。<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<p>然后我就想了一种错漏百出的方法，调了一个下午，终于调出来了。</p>
<p>令<code>f[i][x][y]</code>表示考虑前<code>i-1</code>个数组成的triplet，<code>a[i-1]</code>还剩<code>x</code>个，<code>a[i-2]</code>还剩<code>y</code>个时的triplet总数。我心想：既然连续的triplet最多只有2个，那么<code>x</code>和<code>y</code>的上限就都是2。（后来事实证明这很离谱）于是列出向后的转移方程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不组成形如(i-2, i-1, i)的triplet</span></span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= <span class="number">0</span>)</span><br><span class="line">    f[i+<span class="number">1</span>][(a[i] - <span class="number">0</span>) % <span class="number">3</span>][x - <span class="number">0</span>] =</span><br><span class="line">        max(f[i+<span class="number">1</span>][(a[i]- <span class="number">0</span>) % <span class="number">3</span>][x - <span class="number">0</span>], f[i][x][y] + <span class="number">0</span> + (a[i] - <span class="number">0</span>) / <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 组成一个形如(i-2, i-1, i)的triplet</span></span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= <span class="number">1</span> &amp;&amp; x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span>)</span><br><span class="line">    f[i+<span class="number">1</span>][(a[i] - <span class="number">1</span>) % <span class="number">3</span>][x - <span class="number">1</span>] =</span><br><span class="line">        max(f[i+<span class="number">1</span>][(a[i] - <span class="number">1</span>) % <span class="number">3</span>][x - <span class="number">1</span>], f[i][x][y] + <span class="number">1</span> + (a[i] - <span class="number">1</span>) / <span class="number">3</span>);</span><br><span class="line"><span class="comment">// 组成两个形如(i-2, i-1, i)的triplet</span></span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= <span class="number">2</span> &amp;&amp; x &gt;= <span class="number">2</span> &amp;&amp; y &gt;= <span class="number">2</span>)</span><br><span class="line">    f[i+<span class="number">1</span>][(a[i] - <span class="number">2</span>) % <span class="number">3</span>][x - <span class="number">2</span>] =</span><br><span class="line">        max(f[i+<span class="number">1</span>][(a[i] - <span class="number">2</span>) % <span class="number">3</span>][x - <span class="number">2</span>], f[i][x][y] + <span class="number">2</span> + (a[i] - <span class="number">2</span>) / <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>跑一下看看，发现错得离谱。思考了一段时间之后，发觉这个转移方程“太准确了”。比如说，<code>a[4]=2</code>时，<code>f[4][2][2]</code>可以转移到<code>f[5][1][1]</code>，但也应该可以转移到<code>f[5][0][1]</code>和<code>f[5][1][0]</code>（丢掉一些4和3也是可以的）。于是把转移方程修改如下，加入了后面两维的更多可能性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(a[i], <span class="number">2</span>); k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= x - <span class="number">0</span>; j++) &#123;</span><br><span class="line">            f[i+<span class="number">1</span>][k][j] = </span><br><span class="line">                max(f[i+<span class="number">1</span>][k][j], f[i][x][y] + <span class="number">0</span> + (a[i] - k) / <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= <span class="number">1</span> &amp;&amp; x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(a[i] - <span class="number">1</span>, <span class="number">2</span>); k++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= x - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            f[i+<span class="number">1</span>][k][j] = </span><br><span class="line">                max(f[i+<span class="number">1</span>][k][j], f[i][x][y] + <span class="number">1</span> + (a[i] - k - <span class="number">1</span>) / <span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt;= <span class="number">2</span> &amp;&amp; x &gt;= <span class="number">2</span> &amp;&amp; y &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(a[i] - <span class="number">2</span>, <span class="number">2</span>); k++) &#123;</span><br><span class="line">        f[i+<span class="number">1</span>][k][x - <span class="number">2</span>] = </span><br><span class="line">            max(f[i+<span class="number">1</span>][k][x - <span class="number">2</span>], f[i][x][y] + <span class="number">2</span> + (a[i] - k - <span class="number">2</span>) / <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果还是不对。经过更加漫长的debug，我意识到这种做法里的上限不能是2，因为它表示的是整体剩下的上限，而不是一共有多少个以它结尾的triplet。于是我直接把上限改成了6（既然有三种triplet的可能性），然后就过了（虽然耗时非常长）。</p>
<h3>代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> cnt[<span class="number">1000005</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1000005</span>][<span class="number">7</span>][<span class="number">7</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> *a = cnt + <span class="number">1</span>;  <span class="comment">// 处理i-2的边缘情况</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        a[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= min(<span class="number">6</span>, a[i<span class="number">-1</span>]); x++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt;= min(<span class="number">6</span>, a[i<span class="number">-2</span>]); y++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(a[i], <span class="number">6</span>); k++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= x - <span class="number">0</span>; j++) &#123;</span><br><span class="line">                            f[i+<span class="number">1</span>][k][j] = </span><br><span class="line">                                max(f[i+<span class="number">1</span>][k][j], f[i][x][y] + <span class="number">0</span> + (a[i] - k) / <span class="number">3</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt;= <span class="number">1</span> &amp;&amp; x &gt;= <span class="number">1</span> &amp;&amp; y &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(a[i] - <span class="number">1</span>, <span class="number">6</span>); k++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= x - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                            f[i+<span class="number">1</span>][k][j] = </span><br><span class="line">                                max(f[i+<span class="number">1</span>][k][j], f[i][x][y] + <span class="number">1</span> + (a[i] - k - <span class="number">1</span>) / <span class="number">3</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[i] &gt;= <span class="number">2</span> &amp;&amp; x &gt;= <span class="number">2</span> &amp;&amp; y &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= min(a[i] - <span class="number">2</span>, <span class="number">6</span>); k++) &#123;</span><br><span class="line">                        f[i+<span class="number">1</span>][k][x - <span class="number">2</span>] = </span><br><span class="line">                            max(f[i+<span class="number">1</span>][k][x - <span class="number">2</span>], f[i][x][y] + <span class="number">2</span> + (a[i] - k - <span class="number">2</span>) / <span class="number">3</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= <span class="number">6</span>; x++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt;= <span class="number">6</span>; y++)</span><br><span class="line">            ans = max(ans, f[m + <span class="number">2</span>][x][y]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2>1110F</h2>
<p>题目来源：<a href="https://codeforces.com/contest/1110/problem/F" target="_blank" rel="noopener">https://codeforces.com/contest/1110/problem/F</a></p>
<p>提交次数：1/1</p>
<h3>题意</h3>
<p>给定一棵带权树，所有结点按DFS遍历顺序从1到n编号，回答q次询问：给定整数v、l和r，找到从结点v到编号在l和r之间的叶结点之间的最短距离。</p>
<h3>分析</h3>
<p>题解里给出了一种很类似于可持久化线段树的离线方法：对根结点记录它到每个叶子的距离，然后从根结点走到需要查询的结点v，同时根据边权更新它到叶子的距离。不过并不是很详细。<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1]</a></sup></p>
<p>另一种方法是使用重心剖分（centroid decomposition，我就简称CD了）。首先对树进行重心剖分。对于每个叶结点，将它存储在它在重心剖分树的每个祖先结点中，也就是对重心剖分树中的每个结点，维护它子树中的叶结点的一个list，包括编号和（到该结点的）距离。需要回答询问时，对于结点v在重心剖分树中的每个祖先结点，查询该结点对应的叶结点中，编号在l和r之间的叶结点中的最短距离。这一步可以用线段树。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<p>不妨举个例子。这是CF上的第五个测试数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">10 10</span><br><span class="line">1 12</span><br><span class="line">2 89</span><br><span class="line">3 20</span><br><span class="line">3 37</span><br><span class="line">3 15</span><br><span class="line">2 43</span><br><span class="line">7 8</span><br><span class="line">8 31</span><br><span class="line">1 52</span><br><span class="line">8 8 9</span><br><span class="line">1 1 8</span><br><span class="line">7 7 10</span><br><span class="line">4 3 4</span><br><span class="line">9 3 8</span><br><span class="line">7 7 9</span><br><span class="line">6 7 10</span><br><span class="line">2 3 7</span><br><span class="line">6 8 10</span><br><span class="line">7 1 4</span><br></pre></td></tr></table></figure>
<p><img src="tree.jpg" alt="左侧是原树，右侧是重心剖分树，以及子树中叶结点到当前结点的距离"></p>
<p>真的去写的时候，照例遇到了一万个问题，不过幸好这次有一份写得相当不错的代码<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>可以参照，省了很多时间。重心剖分的模板每次都背错这种愚蠢的事情就不说了，不过仍然会遇到如何组织树的这个问题。之前已经说过了，其实用修正过写法的<code>set</code>和<code>vector</code>加上删除标志都可以接受；但这次需要存边权，换成<code>map</code>听起来有点不太像一棵树。（倒不如说是我觉得这样遍历太麻烦了）所以换成了<code>vector&lt;pair&lt;int, long long&gt;&gt;</code>。</p>
<p>除了重心剖分以外，为了计算距离，当然LCA也是需要的。这次我虽然基本没有背错LCA模板，但我忘记这是棵带权树了。当然改起来很容易，把深度改成到根结点的距离就行。</p>
<p>初始化的部分倒是挺好写的——如果某个结点是叶子，那么就把它加到它在CD树的所有祖先（包括自己）的叶结点list中，同时计算距离。在这一步（或者不如说是下一步）中，我没有意识到这个list可能是空的，因为CD树的叶结点不一定是原树中的叶结点，所以仍然花了一些debug的时间。</p>
<p>所以下面得给每个结点都建一棵线段树。还采用自顶向下的那种方法就实在太冗长了，于是我直接抄了<sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3]</a></sup>中的<a href="https://codeforces.com/blog/entry/18051" target="_blank" rel="noopener">zkw_cf线段树</a>，这个东西是对zkw线段树的改进，不仅是自底向上的，而且只需要使用<code>2*n</code>的空间，不需要和2的幂对齐了。不过我还没太搞明白这是怎么做到的，就直接抄了。。。</p>
<p>下面这个问题花了我很久去debug，听起来十分愚蠢，但事实就是这样的……CD树上每个叶结点的线段树都是做了离散化的，只包含有的叶结点的编号。所以需要查的时候，显然需要找到编号的index。所以下面的问题是：对于排好序的<code>pair&lt;int, LL&gt; a[n]</code>和<code>l &lt;= r</code>，如何找到最左边的满足<code>a[i].first &gt;= l</code>的<code>i</code>和最右边的满足<code>a[i].first &lt;= r</code>的<code>i</code>？答案当然是二分查找，但是过程相当tricky……总之我最后也是又抄代码了。</p>
<p>最后一个问题很傻逼。我又忘记在CD树中从下向上查时，两个结点的距离不能用它们到中间结点的距离的和来推导了，这只能重新直接在原树中算……</p>
<p>总的来说这算法比较慢。我现在懒得去分析复杂度了……</p>
<h3>代码</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">int</span> q, n;</span><br><span class="line"><span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, LL&gt;&gt; tree[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">bool</span> deleted[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">int</span> cd_father[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">500005</span>][<span class="number">30</span>];</span><br><span class="line">LL dist[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">int</span> level[<span class="number">500005</span>];</span><br><span class="line"><span class="keyword">int</span> subSize[<span class="number">500005</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抄来的zkw_cf线段树</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, LL&gt;&gt; leaves;</span><br><span class="line">    <span class="built_in">vector</span>&lt;LL&gt; tree;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        n = leaves.size();</span><br><span class="line">        sort(leaves.begin(), leaves.end());</span><br><span class="line">        tree.resize(<span class="number">2</span> * n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            tree[n + i] = leaves[i].second;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">            tree[i] = min(tree[<span class="number">2</span> * i], tree[<span class="number">2</span> * i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">bool</span> convert = <span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (leaves.size() == <span class="number">0</span> || r &lt; leaves.front().first || leaves.back().first &lt; l) <span class="keyword">return</span> <span class="number">1e16</span>;</span><br><span class="line">        <span class="keyword">if</span> (convert) &#123;</span><br><span class="line">            <span class="comment">// 抄的代码（注意r是开区间，这是这种线段树写法的要求）</span></span><br><span class="line">            l = lower_bound(leaves.begin(), leaves.end(), make_pair(l, (LL) <span class="number">-1</span>)) - leaves.begin();</span><br><span class="line">            r = lower_bound(leaves.begin(), leaves.end(), make_pair(r + <span class="number">1</span>, (LL) <span class="number">-1</span>)) - leaves.begin();</span><br><span class="line">        &#125;</span><br><span class="line">        LL ans = <span class="number">1e16</span>;</span><br><span class="line">        <span class="keyword">for</span> (l += n, r += n; l &lt; r; l /= <span class="number">2</span>, r /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l &amp; <span class="number">1</span>) ans = min(ans, tree[l++]);</span><br><span class="line">            <span class="keyword">if</span> (r &amp; <span class="number">1</span>) ans = min(ans, tree[--r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; segTree[<span class="number">500005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> parent, LL d, <span class="keyword">int</span> l)</span> </span>&#123;</span><br><span class="line">    dist[cur] = d;</span><br><span class="line">    level[cur] = l;</span><br><span class="line">    father[cur][<span class="number">0</span>] = parent == <span class="number">-1</span> ? cur : parent;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[cur].size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (tree[cur][i].first != parent)</span><br><span class="line">            dfs(tree[cur][i].first, cur, d + tree[cur][i].second, l + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lca_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> dep = <span class="number">1</span>; dep &lt; <span class="number">30</span>; dep++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            father[i][dep] = father[father[i][dep<span class="number">-1</span>]][dep<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (level[x] &lt; level[y]) swap(x, y);</span><br><span class="line">    <span class="keyword">int</span> d = level[x] - level[y];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> (d &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            x = father[x][i];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">29</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="keyword">if</span> (father[x][i] != father[y][i])</span><br><span class="line">            x = father[x][i], y = father[y][i];</span><br><span class="line">    <span class="keyword">return</span> father[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">get_dist</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dist[x] + dist[y] - <span class="number">2</span> * dist[get_lca(x, y)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs_sub_size</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">    subSize[cur] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[cur].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = tree[cur][i].first;</span><br><span class="line">        <span class="keyword">if</span> (u != parent &amp;&amp; !deleted[u])</span><br><span class="line">            subSize[cur] += dfs_sub_size(u, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subSize[cur];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_centroid</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> parent, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[cur].size(); i++)</span><br><span class="line">        <span class="keyword">if</span> (tree[cur][i].first != parent &amp;&amp; !deleted[tree[cur][i].first] </span><br><span class="line">            &amp;&amp; subSize[tree[cur][i].first] &gt; n / <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> get_centroid(tree[cur][i].first, cur, n);</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">centroid_decomposition</span><span class="params">(<span class="keyword">int</span> cur, <span class="keyword">int</span> parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = dfs_sub_size(cur, parent);</span><br><span class="line">    <span class="keyword">int</span> centroid = get_centroid(cur, parent, n);</span><br><span class="line">    cd_father[centroid] = parent;</span><br><span class="line">    deleted[centroid] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tree[centroid].size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = tree[centroid][i].first;</span><br><span class="line">        <span class="keyword">if</span> (u != parent &amp;&amp; !deleted[u])</span><br><span class="line">            centroid_decomposition(u, centroid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    lca_init();</span><br><span class="line">    centroid_decomposition(<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tree[i].size() != <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 是叶子</span></span><br><span class="line">        <span class="keyword">int</span> cur = i;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="number">-1</span>) &#123;</span><br><span class="line">            segTree[cur].leaves.emplace_back(i, get_dist(i, cur));</span><br><span class="line">            cur = cd_father[cur];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        segTree[i].init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">query</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    LL ans = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">int</span> p = v;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// upDist并不是累加的！（某个bug曾经出现的位置）</span></span><br><span class="line">        ans = min(ans, segTree[p].query(l, r, <span class="literal">true</span>) + get_dist(v, p));</span><br><span class="line">        p = cd_father[p];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> p, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;p, &amp;w);</span><br><span class="line">        tree[i].emplace_back(p, w);</span><br><span class="line">        tree[p].emplace_back(i, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v, l, r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; q; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp;v, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, query(v, l, r));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://codeforces.com/blog/entry/65079" target="_blank" rel="noopener">The Editorial of the First Codeforces Global Round</a> <a href="#fnref1" class="footnote-backref">↩</a> <a href="#fnref1:1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://codeforces.com/blog/entry/65059?#comment-490727" target="_blank" rel="noopener">Codeforces - comment of gaurav172</a> <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://codeforces.com/contest/1110/submission/49592451" target="_blank" rel="noopener">tfg's solution for 1110F</a> <a href="#fnref3" class="footnote-backref">↩</a> <a href="#fnref3:1" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/Codeforces/"><i class="fas fa-hashtag fa-fw"></i>Codeforces</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class='post-wrapper'>
              <article class="post reveal ">
  
<section class='meta'>
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/Leetcode 992. Subarrays with K Different Integers/">
              
                  Leetcode 992. Subarrays with K Different Integers
              
          </a>
      </h2>
    

    <div class='new-meta-box'>
      
        <div class='new-meta-item author'>
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class='notlink'>
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-12
          </a>
        </div>
      
      
        
          
          <div class='new-meta-item category'>
            <a href='/categories/Leetcode/'>
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              Leetcode
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>题目来源：<a href="https://leetcode.com/problems/subarrays-with-k-different-integers/description/" target="_blank" rel="noopener">https://leetcode.com/problems/subarrays-with-k-different-integers/description/</a></p>
<p>标记难度：Hard</p>
<p>提交次数：1/1</p>
<p>代码效率：</p>
<ul>
<li>两个滑动窗口：28.89%（340ms）</li>
<li>一个滑动窗口：</li>
</ul>
<h2>题意</h2>
<p>给定数组<code>A</code>，求<code>A</code>中恰好含有<code>k</code>个不同元素的子数组的数量。</p>
<h2>分析</h2>
<p>从数据范围来看，显然<code>N^2</code>的算法是过不了的。所以比赛的时候我就想了一种这样的算法：</p>
<ul>
<li>遍历数组元素</li>
<li>用指针<code>i</code>和<code>j</code>分别表示从当前元素开始，含有<code>k</code>个不同元素的最短子数组的结尾元素和最长子数组的结尾元素</li>
<li>用两个<code>map</code>分别维护这两个子数组中的元素</li>
<li>需要移动到下一个元素时，从<code>map</code>中删除当前元素，并移动指针直到满足要求为止。显然<code>i</code>和<code>j</code>的位置是递增的</li>
</ul>
<p>这就相当于维护了两个滑动窗口。显然每个元素最多进出每个集合一次，所以整体复杂度应该是<code>O(N)</code>。（虽然常数实在很大……）</p>
<p>这个算法应该和<a href="https://leetcode.com/problems/subarrays-with-k-different-integers/solution/" target="_blank" rel="noopener">题解</a>是很相似的。</p>
<hr>
<p>当然别人还有一些更神奇的做法，比如<a href="https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/234482/JavaC++Python-Sliding-Window-with-Video" target="_blank" rel="noopener">lee215的另辟蹊径的方法</a>。他做了一件这样的事情：</p>
<ul>
<li>对于某个<code>K</code>，遍历数组元素</li>
<li>对于每个<code>A[j]</code>，找到使得<code>A[i...j]</code>中恰好有<code>K</code>个不同元素的最大的<code>i</code>，记<code>j-i+1</code>为以<code>j</code>结尾的最多有<code>K</code>个不同元素的子数组的数量</li>
<li>令<code>f(K)</code>表示数组中最多有<code>K</code>个不同元素的子数组的数量</li>
<li>则所求结果为<code>f(K) - f(K-1)</code></li>
</ul>
<p>还真是一个独到的想法，虽然有些不明白他是怎么想出来的……</p>
<hr>
<p>还有一种更有趣的方法<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，没有显式地维护两个滑动窗口。我觉得这种方法的核心思路其实是这样的：</p>
<ul>
<li>对于每一个数组元素<code>A[i]</code>，记<code>sMin</code>为使得<code>A[sMin...i]</code>中包含<code>K</code>个不同元素的最小index，<code>sMax</code>为使得<code>A[sMax...i]</code>中包含<code>K</code>个不同元素的最大index</li>
<li>那么显然<code>A[sMin...i]</code>和<code>A[sMax...i]</code>包含的元素是一样的（虽然可能个数不同）</li>
<li>考虑从<code>A[i]</code>转移到<code>A[i+1]</code>的情况：
<ul>
<li>如果<code>A[i+1]</code>是窗口中已经出现过的元素，则<code>sMin</code>不变，<code>sMax</code>可能会减小</li>
<li>如果<code>A[i+1]</code>是窗口中没有出现过的元素，则<code>sMin = sMax + 1</code>，<code>sMax &gt;= sMin</code></li>
</ul>
</li>
<li>所以维护<code>sMax</code>对应的小窗口就够了。</li>
</ul>
<hr>
<p>以及，有一个可以大幅度提速的优化。题目里给了数组元素的范围（<code>&lt;=N</code>），因此可以用数组代替<code>map</code>。</p>
<h2>代码</h2>
<h3>两个滑动窗口</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; beginMap;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; endMap;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> end1, end2 = A.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (beginMap.size() &lt; K) &#123;</span><br><span class="line">                beginMap[A[i]]++;</span><br><span class="line">                endMap[A[i]]++;</span><br><span class="line">                <span class="keyword">if</span> (beginMap.size() == K) end1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (endMap.find(A[i]) == endMap.end()) &#123;</span><br><span class="line">                    end2 = i - <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                endMap[A[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (beginMap.size() &lt; K) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// end1和end2是两个窗口结尾的指针</span></span><br><span class="line">        ans += end2 - end1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            beginMap[A[i - <span class="number">1</span>]]--;</span><br><span class="line">            endMap[A[i - <span class="number">1</span>]]--;</span><br><span class="line">            <span class="keyword">if</span> (beginMap[A[i - <span class="number">1</span>]] == <span class="number">0</span>) beginMap.erase(A[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (endMap[A[i - <span class="number">1</span>]] == <span class="number">0</span>) endMap.erase(A[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">while</span> (end1 &lt; A.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (beginMap.size() == K) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                end1++;</span><br><span class="line">                beginMap[A[end1]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (beginMap.size() &lt; K) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (end2 &lt; A.size() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (endMap.size() &lt; K || endMap.size() == K &amp;&amp; endMap.find(A[end2 + <span class="number">1</span>]) != endMap.end()) &#123;</span><br><span class="line">                    end2++;</span><br><span class="line">                    endMap[A[end2]]++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (endMap.size() &lt; K) <span class="keyword">break</span>;</span><br><span class="line">            ans += end2 - end1 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3>一个滑动窗口</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sMin = <span class="number">0</span>, sMax = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; window;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// sMin不变，只修改sMax</span></span><br><span class="line">            <span class="keyword">if</span> (window.size() &lt; K || window.find(A[i]) != window.end()) &#123;</span><br><span class="line">                window[A[i]]++;</span><br><span class="line">                <span class="keyword">while</span> (window.size() == K &amp;&amp; window[A[sMax]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    window[A[sMax]]--;</span><br><span class="line">                    sMax++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// sMin和sMax都改变</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                window[A[i]]++;</span><br><span class="line">                sMin = sMax + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (window.size() &gt;= K) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (window.size() == K &amp;&amp; window[A[sMax]] == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                    window[A[sMax]]--;</span><br><span class="line">                    <span class="keyword">if</span> (window[A[sMax]] == <span class="number">0</span>) window.erase(A[sMax]);</span><br><span class="line">                    sMax++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (window.size() == K) ans += sMax - sMin + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/235235/C++-with-picture-7-lines-56-ms" target="_blank" rel="noopener">votrubac's solution - C++ with picture, 7 lines 56 ms</a> <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
        
          <a href="/tags/Leetcode-Contest/"><i class="fas fa-hashtag fa-fw"></i>Leetcode Contest</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class='post-wrapper'>
              <article class="post reveal ">
  
<section class='meta'>
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-991-broken-calculator/">
              
                  Leetcode 991. Broken Calculator
              
          </a>
      </h2>
    

    <div class='new-meta-box'>
      
        <div class='new-meta-item author'>
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class='notlink'>
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-11
          </a>
        </div>
      
      
        
          
          <div class='new-meta-item category'>
            <a href='/categories/Leetcode/'>
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              Leetcode
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>题目来源：<a href="https://leetcode.com/problems/broken-calculator/description/" target="_blank" rel="noopener">https://leetcode.com/problems/broken-calculator/description/</a></p>
<p>标记难度：Medium</p>
<p>提交次数：1/1</p>
<p>代码效率：100.00%（4ms）</p>
<h2>题意</h2>
<p>给定两个数<code>X</code>和<code>Y</code>，可以对<code>X</code>执行以下两种操作：</p>
<ul>
<li>乘2</li>
<li>减1</li>
</ul>
<p>问最少需要对<code>X</code>执行多少次操作才能将<code>X</code>变成<code>Y</code>？（<code>X</code>和<code>Y</code>的范围都是1e9）</p>
<h2>分析</h2>
<p>比赛的时候我居然首先就写了一个BFS，然后自然是超时了……</p>
<p>后来就思考怎么用数学方法解决，也没想出来，各种各样奇怪的贪心大部分也是错的。</p>
<p>后来想到了对<code>X</code>的操作就等同于对<code>Y</code>的除2和加1两种操作，不过想到了也没什么大的突破……</p>
<p>然后就没做出来……</p>
<hr>
<p>这道题考虑对<code>Y</code>的操作比考虑对<code>X</code>的操作要更容易。如果对<code>Y</code>加1两次再除2，显然不如先除2再加1，因此不会出现两次连续的加1操作。题解<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>是这么说的，不过我感觉有一点不太严谨。倒不如这么说：首先假设有一个最优的操作顺序，需要除2<code>n</code>次，且在第一次除2之前需要加1<code>a[0]</code>次，在第二次除2之前需要加1<code>a[1]</code>次，……，在最后一次除2之后需要加1<code>a[n]</code>次。此时总操作次数为<code>a[0] + a[1] + ... + a[n] + n</code>。假如存在<code>i &lt; n</code>且<code>a[i] &gt; 1</code>，那显然可以把多余的+1操作下移，变成<code>a'[i] = a[i] - 2 * (a[i]/2)</code>，<code>a'[i+1] = a[i+1] + a[i]/2</code>，总操作次数减少<code>a[i]/2</code>次。如果<code>a'[i+1]</code>仍然大于1，则可以继续尝试下移，直到除了<code>a[n]</code>以外的所有<code>a[i]</code>都变成0或1为止。</p>
<p>事实上我大概是做了一个Exchange类型的贪心证明……</p>
<h2>代码</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">brokenCalc</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (Y &gt; X) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Y % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                Y /= <span class="number">2</span>;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Y = (Y + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                ans += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans + (X - Y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://leetcode.com/problems/broken-calculator/solution/" target="_blank" rel="noopener">Leetcode Official Solution for 991. Broken Calculator</a> <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
        
          <a href="/tags/Leetcode-Contest/"><i class="fas fa-hashtag fa-fw"></i>Leetcode Contest</a>
        
          <a href="/tags/alg-Math/"><i class="fas fa-hashtag fa-fw"></i>alg:Math</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class='post-wrapper'>
              <article class="post reveal ">
  
<section class='meta'>
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/leetcode-990-satisfiability-of-equality-equations/">
              
                  Leetcode 990. Satisfiability of Equality Equations
              
          </a>
      </h2>
    

    <div class='new-meta-box'>
      
        <div class='new-meta-item author'>
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class='notlink'>
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-11
          </a>
        </div>
      
      
        
          
          <div class='new-meta-item category'>
            <a href='/categories/Leetcode/'>
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              Leetcode
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>题目来源：<a href="https://leetcode.com/problems/satisfiability-of-equality-equations/description/" target="_blank" rel="noopener">https://leetcode.com/problems/satisfiability-of-equality-equations/description/</a></p>
<p>标记难度：Medium</p>
<p>提交次数：1/1</p>
<p>代码效率：16ms</p>
<h2>题意</h2>
<p>给定一系列等式，每个等式形如<code>a==b</code>或<code>a!=b</code>，变量名为单个英文小写字母，问这些等式组能否成立？</p>
<h2>分析</h2>
<p>这道题的思路很简单：首先将所有<code>a==b</code>等式转化成<code>a</code>和<code>b</code>之间的连边，然后做并查集或DFS，然后再判断形如<code>a!=b</code>的等式中的两个变量是否在同一个连通集中。总之用并查集和DFS都差不多……</p>
<h2>代码</h2>
<p>所以我就直接写了并查集……</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _fa[<span class="number">26</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            _fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fa</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (_fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> _fa[x] = fa(_fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        x = fa(x);</span><br><span class="line">        y = fa(y);</span><br><span class="line">        _fa[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">equationsPossible</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; equations)</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> s: equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'='</span>)</span><br><span class="line">                merge(s[<span class="number">0</span>] - <span class="string">'a'</span>, s[<span class="number">3</span>] - <span class="string">'a'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> s: equations) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[<span class="number">1</span>] == <span class="string">'!'</span>)</span><br><span class="line">                <span class="keyword">if</span> (fa(s[<span class="number">0</span>] - <span class="string">'a'</span>) == fa(s[<span class="number">3</span>] - <span class="string">'a'</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/Leetcode/"><i class="fas fa-hashtag fa-fw"></i>Leetcode</a>
        
          <a href="/tags/Leetcode-Contest/"><i class="fas fa-hashtag fa-fw"></i>Leetcode Contest</a>
        
          <a href="/tags/alg-Depth-first-Search/"><i class="fas fa-hashtag fa-fw"></i>alg:Depth-first Search</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
          
            <div class='post-wrapper'>
              <article class="post reveal ">
  
<section class='meta'>
  
  
  <div class="meta" id="header-meta">
    
      <h2 class="title">
          <a href="/post/computational-geometry-usaco-translation/">
              
                  翻译：计算几何（USACO）
              
          </a>
      </h2>
    

    <div class='new-meta-box'>
      
        <div class='new-meta-item author'>
          <a href="https://zhanghuimeng.github.io">
            <i class="fas fa-user" aria-hidden="true"></i>
            张慕晖
          </a>
        </div>
      
      
        <div class="new-meta-item date">
          <a class='notlink'>
            <i class="fas fa-calendar-alt" aria-hidden="true"></i>
            2019-02-10
          </a>
        </div>
      
      
        
          
          <div class='new-meta-item category'>
            <a href='/categories/USACO/'>
              <i class="fas fa-folder-open" aria-hidden="true"></i>
              USACO
            </a>
          </div>
        
      
      
      
    </div>
    <hr>
  </div>
</section>

  <section class="article typo">
    <div class="article-entry" itemprop="articleBody">
      <p>这是几乎全部机翻的版本。几乎可以肯定的是，这个翻译需要改进。</p>
<!-- Prerequisites -->
<h2>先决条件</h2>
<!-- Graph Theory
Shortest Path -->
<blockquote>
<ul>
<li>图论</li>
<li>最短路</li>
</ul>
</blockquote>
<!-- Tools -->
<h2>工具</h2>
<!-- This module discusses several algorithms that calculate various geometric properties, mostly based on only two operations described below: cross product and arctangent. -->
<blockquote>
<p>本节讨论了几种用于计算各类几何属性的算法，主要基于下面描述的两种操作：叉积和反正切。</p>
</blockquote>
<!-- Cross Product -->
<h3>叉积</h3>
<!-- The cross product of u and v is written as u x v. Computationally, the cross product of two three-dimensional vectors u and v is the vector determinant of the following matrix (where i, j, and k are unit vectors in the x, y, and z directions respectively):  -->
<blockquote>
<p>u和v的叉积写作u x v。在计算中，两个三维向量u和v的叉积是下列矩阵的矢量行列式（其中i、j和k分别是x、y和z方向的单位向量）：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| i  j  k  |</span><br><span class="line">| ux uy uz |</span><br><span class="line">| vx vy vz |</span><br></pre></td></tr></table></figure>
<!-- That equation works out to: -->
<blockquote>
<p>这个式子的值为：</p>
</blockquote>
<blockquote>
<p>(uyvz-vyuz)i + (uzvx-uxvz)j + (uxvy-uyvx)k</p>
</blockquote>
<p><img src="geom6.gif" alt=""></p>
<!-- This definition can be used for vectors in two dimensions by using three-dimensional vectors with a z component of 0. The resulting vector will only have a z value. -->
<blockquote>
<p>通过将三维向量的z分量置为0，这一定义可用于二维向量。得到的向量只有z分量有值。</p>
</blockquote>
<!-- The cross product has three properties: -->
<blockquote>
<p>叉积有三条性质：</p>
</blockquote>
<!-- The cross product of two vectors is perpendicular to both vectors.
The length of the cross product is equal to the product of:
the length of u,
the length of v, and
the sine of the angle between the vectors. -->
<blockquote><ul>
<li>两个向量的<em>叉积</em>垂直于这两个向量。</li>
<li>叉积的长度等于以下几项的乘积：
<ul>
<li>u的长度</li>
<li>v的长度</li>
<li>u和v夹角的正弦值</li>
</ul>
</li>
</ul>
</blockquote>
<!-- Of the two different directions that are perpendicular to both u and v, the direction the cross product points depends on whether u is ``to the right'' of v or ``to the left.''  -->
<blockquote>
<p>在与u和v垂直的两个不同方向中，叉积指向的方向取决于u是在v的“右边”还是“左边”。</p>
</blockquote>
<p><img src="geom7.gif" alt=""></p>
<p>这就是右手定则吧。</p>
<!-- Dot product -->
<h3>点积</h3>
<!-- The dot product of two vectors u and v is a scalar written as u · v. Computationally, it is defined in three dimensions as: uxvx + u yvy + uzv z -->
<blockquote>
<p>两个向量u和v的点积是写作u·v的标量。在计算中，它在三维向量中定义为： uxvx + uyvy + uzvz</p>
</blockquote>
<!-- The dot product is actually equal to the product of: -->
<blockquote>
<p>点积实际上等于以下几项的乘积：</p>
</blockquote>
<!-- the length of u
the length of v
the cosine of the angle between u and v. -->
<blockquote>
<ul>
<li>u的长度</li>
<li>v的长度</li>
<li>u和v之间夹角的余弦值。</li>
</ul>
</blockquote>
<!-- Presuming u and v are non-zero, if the dot product if negative, u and v make an angle greater than 90 degrees. If it is zero, then u and v are perpendicular. If u cdot v is positive, then the two vectors form an acute angle. -->
<blockquote>
<p>假定u和v不为零，如果点积为负，则u和v的夹角大于90度。如果它为零，则u和v垂直。如果点积为正，则两个向量的夹角为锐角。</p>
</blockquote>
<!-- Arctangent -->
<h3>反正切</h3>
<!-- The arctangentfunction calculates the (an) angle whose tangent is its argument and generally returns a real number between -pi/2 and pi/2. An additional function in C, atan2, takes two arguments: a DELTA y value and a DELTA x value (in that order!). It determines the angle between the given vector and the positive x axis and returns a value between -pi and pi. This has the advantage of removing concerns about dividing by zero or writing code to repair angles in order to handle the negative x cases. The atan2 function is almost always easier to use than the simpler atan function that takes only one argument. -->
<blockquote>
<p>反正切函数计算其正切值等于它的参数的角度，通常返回-pi/2和pi/2之间的一个实数。C中的函数<code>atan2</code>接收两个参数：y轴的差值和x轴的差值（按此顺序！）。它确定给定向量和x轴正半轴之间的角度，并返回一个-pi和pi之间的值。这可以解决除零或需要撰写代码处理x轴负半轴的问题。该<code>atan2</code>函数几乎总是比简单的只有一个参数的反正切函数容易使用。</p>
</blockquote>
<p>显然如果只接收一个参数，无法处理向量和x轴垂直的情况（因为会发生除0问题），而且只有正负也无法说明是和正半轴还是负半轴的夹角。</p>
<!-- Particular Debugging Problems -->
<h2>调试中的特殊问题</h2>
<!-- The main problem with geometric problems is that they spawn a lot of special cases. Be on the lookout for these special cases and make sure your program works for all of them. -->
<blockquote>
<p>计算几何题的主要问题是它们会产生<strong>许多</strong>特殊情况。请留意这些特殊情况，并<strong>确保你的程序适用于所有这些情况</strong>。</p>
</blockquote>
<!-- Floating point calculations also create a new set of problems. Floating point calculations are rarely precise, as the computer only maintains so many bits (digits) of accuracy: be aware of this. In particular, when checking if two values are equal, check to see if they are within some small tolerance of each other not precisely equal. -->
<blockquote>
<p>浮点数计算也会产生很多新问题。浮点计算很少是精确的，因为计算机只准确保留了若干比特（位）：要注意这一点。特别注意，在检查两个值是否相等时，不要检查它们是否精确相等，而是检查它们之间的差值是否小于某个范围。</p>
</blockquote>
<!-- Geometric Algorithms -->
<h2>计算几何算法</h2>
<!-- Here are some of snippets that can help you solve geometry problems. -->
<blockquote>
<p>下面是一些可以帮助你解决计算几何问题的代码片段。</p>
</blockquote>
<!-- Area of Triangle -->
<h3>三角形面积</h3>
<!-- To calculate the area of a triangle with vertices (a, b, c), pick a vertex (say a) and create a vector to the other two vertices (let u = b - a, and v = c - a). The area of the triangle (a, b, c) is one half the length of cross product u x v. -->
<blockquote>
<p>要计算顶点为(a，b，c)的三角形的面积，选择一个顶点（比如说a），并创建从a指向另外两个顶的向量（令u = b - a，v = c - a）。则三角形(a，b，c)的面积是u和v叉积长度的一半。</p>
</blockquote>
<p><img src="geom1.gif" alt=""></p>
<!-- An alternative method to find the area of triangle is to use Hero's formula. If the lengths of the sides of a triangle are a, b, and c, let s = (a+b+c)/2. The area of the triangle is then -->
<blockquote>
<p>另一种计算三角形面积的方法是海伦公式。如果三角形的三条边长度分别为a，b，c，令s = s = (a+b+c)/2，则三角形的面积为</p>
</blockquote>
<!-- sqrt(s* (s-a)*(s-b)*(s-c)) . -->
<blockquote>
<p>sqrt(s*(s-a)*(s-b)*(s-c))</p>
</blockquote>
<!-- Are Two Line Segments Parallel? -->
<h3>两条线段是否平行？</h3>
<!-- To check if two line segments are parallel, create vectors along each line segment and check to see if their cross product is (almost) zero. -->
<blockquote>
<p>为了检查两条线段是否平行，请沿每条线段创建向量，并检查它们的叉积是否（几乎）为零。</p>
</blockquote>
<!-- Area of polygon -->
<h3>多边形面积</h3>
<!-- The area of a polygon with vertices (x 1, y 1), ..., (x n, y n) is equal to the determinant:  -->
<blockquote>
<p>顶点为(x1, y1), ...，(xn, yn)的多边形的面积等于行列式：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> 1   | x1 x2 ... xn |</span><br><span class="line">---  |              |</span><br><span class="line"> 2   | y1 y2 ... yn |</span><br></pre></td></tr></table></figure>
<!-- where the determinate is defined to be similar to the 2 by 2 determinant: x1 y2 + x2y3 + ... + xn y1 - y1 x2 - y2x3 - ... - yn x1 -->
<blockquote>
<p>其中行列式的定义类似于2*2的行列式：x1y2 + x2y3 + ... + xny1 - y1x2 - y2x3 - ... - ynx1</p>
</blockquote>
<p>不过我觉得我一般只会把多边形分成若干个三角形来算……</p>
<!-- Distance from a point to a line -->
<h3>点到直线的距离</h3>
<!-- The distance from a point P to a line AB is given by the magnitude of the cross product. In particular, d(P,AB) = |(P - A) x (B - A)| / | B - A| . -->
<blockquote>
<p>从点P到线段AB的距离等于叉积的大小，即d(P，AB) = |(P-A）x (B-A)| / | B - A | 。</p>
</blockquote>
<!-- To determine the distance from a point P to the plane defined by A, B, and C, let n = (B - A) x (C - A). The distance is then give by the following equation: d(P,ABC) = (P-A) · n / |n|. -->
<blockquote>
<p>为了确定从点P到由点A、B和C定义的平面的距离，令n =(B-A) × (C-A)。下列等式即给出距离：d(P，ABC) = (P - A) · n / |n|。</p>
</blockquote>
<!-- Points on a line -->
<h3>点在直线上</h3>
<!-- A point is on a line if the distance from the point to the line is 0. -->
<blockquote>
<p>点在直线上当且仅当点到直线的距离为0。</p>
</blockquote>
<!-- Points on the same side of line -->
<h3>在直线同一侧的点</h3>
<!-- This notion only makes sense for two dimensions. To check if points C and D are on the same side of line AB, calculate the z component of (B - A) x (C - A) and (B - A) x (D - A). If the z components have the same sign (i.e., their product is positive), then C and D are on the same side of the line AB. -->
<p>这个概念只对二维平面有意义。要检查C点和D点是否在直线AB的同一侧，计算(B - A) x (C - A)和(B - A) x (D - A)的z分量。如果z分量具有相同的符号（即它们的乘积是正的），则C和D位于直线AB的同一侧。</p>
<!-- Point on line segment -->
<h3>点在线段上</h3>
<!-- To calculate if a point C is on the line segment AB, check if C is on the line AB. If it is, then check if the length of AB is equal to the sum of the lengths of AC and CB. -->
<blockquote>
<p>为了计算点C是否在线段AB上，检查C是否在直线AB上。如果是，则检查AB的长度是否等于AC和CB的长度之和。</p>
</blockquote>
<!-- Point in triangle -->
<h3>点在三角形中</h3>
<!-- To check if a point A is in a triangle, find another point B which is within the triangle (the average of the three vertices works well). Then, check if the point A is on the same side of the three lines defined by the edges of the triangle as B. -->
<blockquote>
<p>为了检查点A是否在三角形中，找到三角形内的另一个点B（三个顶点的平均值就可以）。然后，检查点A是否和点B在由三角形的边定义的三条直线的同一侧。</p>
</blockquote>
<p><img src="geom3.gif" alt=""></p>
<!-- Point in convex polygon -->
<h3>点在凸多边形中</h3>
<!-- The same trick works for a convex polygon:  -->
<blockquote>
<p>同样的技巧适用于凸多边形：</p>
</blockquote>
<p><img src="geom4.gif" alt=""></p>
<!-- Four (or more) points are coplanar -->
<h3>四（或更多）点共面</h3>
<!-- To determine if a collection of points is coplanar, select three points, A, B, and C. Now, if, for any other point D, (B - A) x (C - A)) · (D - A) = ~0, then the collection of points resides in some plane. -->
<blockquote>
<p>为了确定点集是否是共面的，选择三个点，A、B和C。如果对于任何其他点D，((B - A) x (C - A)) · (D - A) ≈ 0，则该点集共面。</p>
</blockquote>
<p>先算出三个点对应的平面的法向量……</p>
<!-- Two lines intersect -->
<h3>两条直线相交</h3>
<!-- Two lines intersect if and only if they are not parallel in two dimensions. -->
<blockquote>
<p>在二维平面中，两条线相交当且仅当它们不平行。</p>
</blockquote>
<!-- In three dimensions, two lines AB and CD intersect if they are not parallel and A, B, C, and D are coplanar. -->
<blockquote>
<p>在三维中，当直线AB和CD不平行且A、B、C、D共面时，AB和CD相交。</p>
</blockquote>
<!-- Two line segments intersect -->
<h3>两条线段相交</h3>
<!-- In two dimensions, two line segments AB and CD intersect if and only if A and B are on opposite sides of the line CD and C and D are on opposite sides of line AB. -->
<blockquote>
<p>在二维平面中，线段AB和CD相交，当且仅当A和B位于直线CD的不同侧且C和D位于直线AB的不同侧时。</p>
</blockquote>
<p><img src="geom5.gif" alt=""></p>
<!-- Note that both of the checks are necessary, as for the last case one of the checks returns true, while the other testifies to the fact that AB and CD do not intersect. In three dimensions, solve following system of equations, where i and j are the unknowns: -->
<p>请注意，两个检查都是必要的，因为在上图中最后一种情况中，一个检查返回true，而另一个检查才能证明AB和CD不相交。在三维情况中，求解下面的方程组，其中i和j是未知数：</p>
<!-- Ax + (Bx - Ax) i = Cx + (Dx - Cx) j 
Ay + (By - Ay) i = Cy + (Dy - Cy) j 
Az + (Bz - Az) i = Cz + (Dz - Cz) j  -->
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ax + (Bx - Ax) i = Cx + (Dx - Cx) j</span><br><span class="line">Ay + (By - Ay) i = Cy + (Dy - Cy) j</span><br><span class="line">Az + (Bz - Az) i = Cz + (Dz - Cz) j</span><br></pre></td></tr></table></figure>
<!-- If this system has a solution (i, j), where 0 <= i <= 1 and 0 <= j <= 1, then the line segments intersect at: (Ax + (Bx - Ax)i, Ay + (By - Ay)i, Az + (Bz - Az) i . -->
<blockquote>
<p>如果该方程组具有解(i，j)，其中0 &lt;= i &lt;= 1且0 &lt;= j &lt;= 1，则线段相交于点(Ax + (Bx - Ax)i, Ay + (By - Ay)i, Az + (Bz - Az) i。</p>
</blockquote>
<!-- Point of Intersection of Two Lines -->
<h3>两条直线的交点</h3>
<!-- For the lines AB and CD in two dimensions, the most straight-forward way to calculate the intersection of them is to solve the system of two equations and two unknowns: -->
<blockquote>
<p>对于二维平面中的直线AB和CD，计算它们交点的最直接方法是求解以下两方程两未知数的方程组：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Ax + (Bx - Ax)i = Cx + (Dx - Cx) j</span><br><span class="line">Ay + (By - Ay)i = Cy + (Dy - Cy) j</span><br></pre></td></tr></table></figure>
<!-- The point of intersection is: -->
<blockquote>
<p>交点坐标为：<br>
(Ax + (Bx - Ax) i, Ay + (By - Ay) i)</p>
</blockquote>
<!-- In three dimensions, solve the same system of equations as was used to check line intersection, and the point of intersection is: -->
<blockquote>
<p>在三维情况下，求解与检查线段交叉时相同的方程组，则交点坐标为：<br>
(Ax + (Bx - Ax)i, Ay + (By - Ay)i, Az + (Bz - Az)i)</p>
</blockquote>
<!-- Checking convexity of 2-dimensional polygon -->
<h3>检查二维多边形的凸性</h3>
<!-- To check the convexity of a 2-dimensional polygon, walk the polygon in clock-wise order. For each triplet of consecutive points (A, B, C), calculate the cross product (B - A) x (C - A). If the z component of each of these vectors is positive, the polygon is convex. -->
<blockquote>
<p>为了检查二维多边形的凸性，按顺时针顺序遍历多边形的顶点。对于所有的连续三个顶点(A，B，C)，计算叉积(B - A) x (C - A)。如果 得到的所有向量的z分量都是正的，则多边形是凸的。</p>
</blockquote>
<!-- Point in non-convex polygon -->
<h3>点在非凸多边形中</h3>
<!-- To calculate if a point is within a nonconvex polygon, make a ray from that point in a random direction and count the number of times it intersects the polygon. If the ray intersects the polygon at a vertex or along an edge, pick a new direction. Otherwise, the point is within the polygon if and only if the ray intersects the polygon an odd number of times. -->
<blockquote>
<p>为了计算某点是否在非凸多边形内，从该点沿随机方向发出一条射线，并计算它与多边形相交的次数。如果射线在顶点或沿边缘与多边形相交，则选择一个新方向。否则，当且仅当射线与多边形相交奇数次时，该点才在多边形内。</p>
</blockquote>
<p><img src="geom8.gif" alt=""></p>
<!-- This method also extends to three dimensions (and higher), but the restriction on intersection is that it only intersects at faces and not at either a vertex or an edge. -->
<blockquote>
<p>此方法也适用于三维（和更高维度），但对相交的限制是只在面上相交，而不是在顶点或边上。</p>
</blockquote>
<!-- Geometry Methodologies -->
<h2>计算几何方法</h2>
<!-- Geometric problems introduce several different tricks that can be used to either reduce the run-time or approximate the solution. -->
<blockquote>
<p>计算几何题引入了几种不同的技巧，可用于减少运行时间或估计解。</p>
</blockquote>
<!-- Monte Carlo -->
<h3>蒙特卡洛方法</h3>
<!-- The first geometric trick is based on randomness. Instead of calculating the probability that something occurs, simulate a random event and calculate the fraction of times it occurs. If enough events are simulated, the difference between these two values becomes very small. -->
<blockquote>
<p>第一种计算几何技巧基于随机性。我们不是计算某事发生的概率，而是模拟随机事件并计算它发生的次数。如果模拟了足够多的事件，则这两个值之间的差异将变得非常小。</p>
</blockquote>
<!-- This can be helpful to determine something like the area of a figure. Instead of calculating the area directly, determine a bounding box, and throw ``darts'' at the box, and estimate what the probability of hitting the figure is. If this is calculated accurately enough, this can give a good estimate of the actual area. -->
<blockquote>
<p>这有助于确定图形面积大小之类内容。我们不是直接计算区域，而是确定一个边界框，然后向框中抛出“飞镖”，并估计击中图形的概率是多少。如果计算得足够准确，这可以很好地估计实际面积。</p>
</blockquote>
<!-- The problem with this method is to get a good relative error (error divided by the actual value) requires a large number of successful events. If the probability of the event occurring is very small, the method does not yield good results. -->
<blockquote>
<p>这种方法的问题是，获得良好的相对误差（误差除以实际值）需要大量成功的事件。如果事件发生的概率非常小，则该方法不会产生很好的结果。</p>
</blockquote>
<!-- Partitioning -->
<h3>分区</h3>
<!-- Partitioning is a method to improve the speed of a geometric algorithm. This entails dividing the plane up into sections (usually by a grid but sometimes into radial sections or some other method), and bucketing the objects into appropriate section(s). When looking for objects within some figure, only those sections which have a non-zero intersection with that figure need to be examined, thereby greatly reducing the cost of the algorithm. This is helpful to determine the set of objects within some distance of a given point (the figure is a circle) or to check for intersections (the figure is a line). -->
<blockquote>
<p>分区是一种提高计算几何算法速度的方法。这需要将平面分成多个部分（通常通过网格，但有时也会按辐射切开或其他方法），并将对象分到对应的区域中。当在某个图形中查找对象时，只需要检查与该图图形具有非零交点的那些部分，从而大大降低了算法的成本。这有助于确定到给定点的距离在某个范围内的对象集和（图形是圆）或检查交叉点（图形是一条直线）。</p>
</blockquote>
<p><img src="geom9.gif" alt=""></p>
<!-- Graph Problems -->
<h3>图论问题</h3>
<!-- Sometimes what may look like a geometric problem is really a graph problem. Just because the input is points in the plane does not mean it's a geometric algorithm. -->
<blockquote>
<p>有时看起来像计算几何问题的问题实际上是图论问题。仅仅因为输入是平面中的点并不意味着需要计算几何算法。</p>
</blockquote>
<!-- Example Problems -->
<h2>例题</h2>
<!-- Point Moving -->
<h3>移动点</h3>
<!-- Given a set of line segments in the plane, and two points A and B, is it possible to move from A to B without crossing any of the segments? -->
<blockquote>
<p>给定平面中的一组线段，以及两个点A和B，能否在不跨越任何线段的情况下从A移动到B？</p>
</blockquote>
<!-- The line segments partition the plane into regions. Determine these regions, and see if A and B reside in the same region. -->
<blockquote>
<p>分析：线段将平面划分为区域。确定这些区域，并检查A和B是否位于同一区域。</p>
</blockquote>
<p>问题是怎么确定这些区域，感觉有些麻烦……</p>
<!-- Bicycle Routing -->
<h3>自行车路线</h3>
<!-- Given a collection of non-intersecting buildings along with start and end locations, find the shortest path from A to B that doesn't go through any buildings. -->
<blockquote>
<p>给定一系列互不交叉建筑的以及它们的起点和终点位置，找到从A到B的不经过任何建筑物的最短路径。</p>
</blockquote>
<!-- Analysis: This is really a graph problem. The nodes are the start and end locations, along with the vertices of the buildings. There are edges between any two nodes such that the line segment between them does not intersect any buildings, with weight equal to the length of the length of the line segments. Once that graph has been calculated, the problem is shortest path. -->
<blockquote>
<p>分析：这实际上是一个图论问题。结点是起始位置和结束位置，以及建筑物的顶点。如果两个结点之间的线段不与任何建筑物相交，则它们之间有边，其权重等于线段的长度。构造完该图后，问题就变成了最短路。</p>
</blockquote>
<!-- Maximizing Line Intersections -->
<h3>最大化交叉点数量</h3>
<!-- Given a collection of segments in the plane, find the greatest number of segments which can by intersected by drawing a single line. -->
<blockquote>
<p>给定平面中的一组线段，找到可以与一条直线相交的线段的最大数量。</p>
</blockquote>
<!-- Analysis: With a little bit of thought, it is clear that the line segment must pass through two of the vertices of the collection of line segments. Thus, try all pairs of vertices, and calculate the crossing for each. Combining this with partitioning gives an algorithm that runs fairly quickly. -->
<blockquote>
<p>分析：经过一些思考，很显然直线必须通过线段集合中的两个顶点。因此，尝试所有顶点对，并计算每条直线的交叉点数量。将其与分区相结合，可以提供一种运行速度相当快的算法。</p>
</blockquote>
<p>或者说，一种最优解可以通过旋转变换成另一个一定至少通过两个顶点的最优解……</p>
<!-- Polygon Classification -->
<h3>多边形分类</h3>
<!-- Given a collection of segments defining a polygon, determine if it is simple (no two non-consecutive line segments intersect) and convex. -->
<blockquote>
<p>给定定义多边形的一组线段，确定它是否是简单多边形（没有两个非连续线段相交）和凸多边形。</p>
</blockquote>
<p>Q：凸多边形一定是简单的吗？</p>

      
    </div>
    
      <div class="full-width auto-padding tags">
        
          <a href="/tags/USACO/"><i class="fas fa-hashtag fa-fw"></i>USACO</a>
        
          <a href="/tags/translation/"><i class="fas fa-hashtag fa-fw"></i>translation</a>
        
      </div>
    
  </section>
</article>

            </div>
          
        
      

  </section>






  
      <br>
      <div class="prev-next">
          <div class="prev-next">
              
                  <a class="prev" rel="prev" href="/page/6/">
                      <section class="post prev" >
                          <i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页&nbsp;
                      </section>
                  </a>
              
              <p class="current">
                  7 / 44
              </p>
              
                  <a class="next" rel="next" href="/page/8/">
                      <section class="post next">
                          &nbsp;下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i>
                      </section>
                  </a>
              

          </div>
      </div>

  

  <!-- 根据主题中的设置决定是否在archive中针对摘要部分的MathJax公式加载mathjax.js文件 -->
  

  




        </div>
        <aside class='l_side'>
            
  
  
    
      
      
        <section class='author'>
  <div class='content pure'>
    
    
    
      <div class="social-wrapper">
        
          
            <a href="mailto:zhanghuimeng1997@gmail.com" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-envelope" aria-hidden="true"></i></a>
          
        
          
            <a href="https://github.com/zhanghuimeng" class="social flat-btn" target="_blank" rel="external"><i class="social fab fa-github" aria-hidden="true"></i></a>
          
        
          
            <a href="https://music.163.com/#/user/home?id=261028414" class="social flat-btn" target="_blank" rel="external"><i class="social fas fa-music" aria-hidden="true"></i></a>
          
        
      </div>
    
  </div>
</section>

      
    
  
    
      
      
        

      
    
  
    
      
      
        
  <section class='category'>
    
<header class='pure'>
  <div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;所有分类</div>
  
</header>

    <div class='content pure'>
      <ul class="entry">
        
          <li><a class="flat-box" title="/categories/Blogging/" href="/categories/Blogging/"><div class='name'>Blogging</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Codeforces/" href="/categories/Codeforces/"><div class='name'>Codeforces</div><div class='badge'>(4)</div></a></li>
        
          <li><a class="flat-box" title="/categories/Leetcode/" href="/categories/Leetcode/"><div class='name'>Leetcode</div><div class='badge'>(32)</div></a></li>
        
          <li><a class="flat-box" title="/categories/MLDS/" href="/categories/MLDS/"><div class='name'>MLDS</div><div class='badge'>(0)</div></a></li>
        
          <li><a class="flat-box" title="/categories/NLP/" href="/categories/NLP/"><div class='name'>NLP</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box" title="/categories/USACO/" href="/categories/USACO/"><div class='name'>USACO</div><div class='badge'>(5)</div></a></li>
        
          <li><a class="flat-box" title="/categories/博客/" href="/categories/博客/"><div class='name'>博客</div><div class='badge'>(0)</div></a></li>
        
          <li><a class="flat-box" title="/categories/旧博客/" href="/categories/旧博客/"><div class='name'>旧博客</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/机器学习/" href="/categories/机器学习/"><div class='name'>机器学习</div><div class='badge'>(2)</div></a></li>
        
          <li><a class="flat-box" title="/categories/深度学习/" href="/categories/深度学习/"><div class='name'>深度学习</div><div class='badge'>(0)</div></a></li>
        
          <li><a class="flat-box" title="/categories/读书笔记/" href="/categories/读书笔记/"><div class='name'>读书笔记</div><div class='badge'>(16)</div></a></li>
        
          <li><a class="flat-box" title="/categories/随笔/" href="/categories/随笔/"><div class='name'>随笔</div><div class='badge'>(3)</div></a></li>
        
      </ul>
    </div>
  </section>


      
    
  
    
      
      
        
  <section class='tagcloud'>
    
<header class='pure'>
  <div><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div>
  
</header>

    <div class='content pure'>
      <a href="/tags/A-Munday/" style="font-size: 14px; color: #999">A.Munday</a> <a href="/tags/Blogging/" style="font-size: 14px; color: #999">Blogging</a> <a href="/tags/C-Marlowe/" style="font-size: 14px; color: #999">C.Marlowe</a> <a href="/tags/CSP/" style="font-size: 15.07px; color: #929292">CSP</a> <a href="/tags/Codeforces/" style="font-size: 19.36px; color: #757575">Codeforces</a> <a href="/tags/Codeforces-Contest/" style="font-size: 19px; color: #777">Codeforces Contest</a> <a href="/tags/Counseling/" style="font-size: 14px; color: #999">Counseling</a> <a href="/tags/Cryptography/" style="font-size: 14px; color: #999">Cryptography</a> <a href="/tags/D-Drayton/" style="font-size: 14px; color: #999">D.Drayton</a> <a href="/tags/Deep-Learning/" style="font-size: 15.07px; color: #929292">Deep Learning</a> <a href="/tags/Depth-first-Search/" style="font-size: 14px; color: #999">Depth-first Search</a> <a href="/tags/Deutsch/" style="font-size: 14px; color: #999">Deutsch</a> <a href="/tags/DigitCircuit/" style="font-size: 14px; color: #999">DigitCircuit</a> <a href="/tags/E-Vere/" style="font-size: 14px; color: #999">E. Vere</a> <a href="/tags/E-Spencer/" style="font-size: 14px; color: #999">E.Spencer</a> <a href="/tags/Essay/" style="font-size: 14.36px; color: #979797">Essay</a> <a href="/tags/Flask/" style="font-size: 14px; color: #999">Flask</a> <a href="/tags/Github/" style="font-size: 14.71px; color: #949494">Github</a> <a href="/tags/GoldenTreasury/" style="font-size: 23.29px; color: #5a5a5a">GoldenTreasury</a> <a href="/tags/Google-Analytics/" style="font-size: 14px; color: #999">Google Analytics</a> <a href="/tags/H-Constable/" style="font-size: 14px; color: #999">H.Constable</a> <a href="/tags/Hexo/" style="font-size: 14px; color: #999">Hexo</a> <a href="/tags/J-Donne/" style="font-size: 14px; color: #999">J.Donne</a> <a href="/tags/J-Lyly/" style="font-size: 14px; color: #999">J.Lyly</a> <a href="/tags/J-Sylvester/" style="font-size: 14px; color: #999">J.Sylvester</a> <a href="/tags/J-Webster/" style="font-size: 14px; color: #999">J.Webster</a> <a href="/tags/Leetcode/" style="font-size: 24px; color: #555">Leetcode</a> <a href="/tags/Leetcode-Contest/" style="font-size: 23.64px; color: #575757">Leetcode Contest</a> <a href="/tags/Lyric/" style="font-size: 17.21px; color: #838383">Lyric</a> <a href="/tags/Machine-Learning/" style="font-size: 19.36px; color: #757575">Machine Learning</a> <a href="/tags/Machine-Translation/" style="font-size: 16.5px; color: #888">Machine Translation</a> <a href="/tags/Maths/" style="font-size: 14px; color: #999">Maths</a> <a href="/tags/NLP/" style="font-size: 14px; color: #999">NLP</a> <a href="/tags/Natural-Language-Processing/" style="font-size: 17.21px; color: #838383">Natural Language Processing</a> <a href="/tags/OS/" style="font-size: 21.14px; color: #686868">OS</a> <a href="/tags/OSTEP/" style="font-size: 17.93px; color: #7e7e7e">OSTEP</a> <a href="/tags/Old-Blog/" style="font-size: 14px; color: #999">Old Blog</a> <a href="/tags/OldBlog/" style="font-size: 14.71px; color: #949494">OldBlog</a> <a href="/tags/P-Sidney/" style="font-size: 14px; color: #999">P.Sidney</a> <a href="/tags/PRML/" style="font-size: 18.29px; color: #7c7c7c">PRML</a> <a href="/tags/Paper/" style="font-size: 16.5px; color: #888">Paper</a> <a href="/tags/Paul-Simon/" style="font-size: 14px; color: #999">Paul Simon</a> <a href="/tags/PhysicsExperiment/" style="font-size: 14px; color: #999">PhysicsExperiment</a> <a href="/tags/Psychology/" style="font-size: 14px; color: #999">Psychology</a> <a href="/tags/PyCharm/" style="font-size: 14px; color: #999">PyCharm</a> <a href="/tags/Quality-Estimation/" style="font-size: 15.43px; color: #8f8f8f">Quality Estimation</a> <a href="/tags/R-Barnfield/" style="font-size: 14px; color: #999">R.Barnfield</a> <a href="/tags/Raspberry-Pi/" style="font-size: 14px; color: #999">Raspberry Pi</a> <a href="/tags/Reading-Report/" style="font-size: 17.57px; color: #818181">Reading Report</a> <a href="/tags/S-Daniel/" style="font-size: 14px; color: #999">S.Daniel</a> <a href="/tags/SGU/" style="font-size: 14.36px; color: #979797">SGU</a> <a href="/tags/Sonnet/" style="font-size: 19.71px; color: #727272">Sonnet</a> <a href="/tags/Spokes/" style="font-size: 14.71px; color: #949494">Spokes</a> <a href="/tags/SystemAnalysis-Control/" style="font-size: 14px; color: #999">SystemAnalysis&Control</a> <a href="/tags/T-Dekker/" style="font-size: 14px; color: #999">T.Dekker</a> <a href="/tags/T-Heywood/" style="font-size: 14px; color: #999">T.Heywood</a> <a href="/tags/T-Lodge/" style="font-size: 14px; color: #999">T.Lodge</a> <a href="/tags/T-Nashe/" style="font-size: 14px; color: #999">T.Nashe</a> <a href="/tags/T-Wyatt/" style="font-size: 14px; color: #999">T.Wyatt</a> <a href="/tags/THUMT/" style="font-size: 15.79px; color: #8d8d8d">THUMT</a> <a href="/tags/TensorFlow/" style="font-size: 15.07px; color: #929292">TensorFlow</a> <a href="/tags/Translation/" style="font-size: 18.64px; color: #797979">Translation</a> <a href="/tags/Tree/" style="font-size: 14px; color: #999">Tree</a> <a href="/tags/USACO/" style="font-size: 22.21px; color: #616161">USACO</a> <a href="/tags/W-Alexander/" style="font-size: 14px; color: #999">W.Alexander</a> <a href="/tags/W-Drummond/" style="font-size: 15.07px; color: #929292">W.Drummond</a> <a href="/tags/W-Shakespeare/" style="font-size: 21.5px; color: #666">W.Shakespeare</a> <a href="/tags/WebStorm/" style="font-size: 14px; color: #999">WebStorm</a> <a href="/tags/object-Object/" style="font-size: 14px; color: #999">[object Object]</a> <a href="/tags/alg-Ad-Hoc/" style="font-size: 14.36px; color: #979797">alg:Ad-Hoc</a> <a href="/tags/alg-Aho–Corasick-Algorithm/" style="font-size: 14px; color: #999">alg:Aho–Corasick Algorithm</a> <a href="/tags/alg-Array/" style="font-size: 20.79px; color: #6b6b6b">alg:Array</a> <a href="/tags/alg-Automata/" style="font-size: 14px; color: #999">alg:Automata</a> <a href="/tags/alg-Backtracking/" style="font-size: 15.79px; color: #8d8d8d">alg:Backtracking</a> <a href="/tags/alg-Binary-Indexed-Tree/" style="font-size: 14px; color: #999">alg:Binary Indexed Tree</a> <a href="/tags/alg-Binary-Search/" style="font-size: 16.5px; color: #888">alg:Binary Search</a> <a href="/tags/alg-Binary-Search-Tree/" style="font-size: 16.86px; color: #868686">alg:Binary Search Tree</a> <a href="/tags/alg-Binary-Tree/" style="font-size: 14px; color: #999">alg:Binary Tree</a> <a href="/tags/alg-Binray-Search/" style="font-size: 14px; color: #999">alg:Binray Search</a> <a href="/tags/alg-Bit-Manipulation/" style="font-size: 15.43px; color: #8f8f8f">alg:Bit Manipulation</a> <a href="/tags/alg-Bitmasks/" style="font-size: 14px; color: #999">alg:Bitmasks</a> <a href="/tags/alg-Breadth-First-Search/" style="font-size: 14px; color: #999">alg:Breadth-First Search</a> <a href="/tags/alg-Breadth-first-Search/" style="font-size: 18.29px; color: #7c7c7c">alg:Breadth-first Search</a> <a href="/tags/alg-Breadth-firth-Search/" style="font-size: 14.36px; color: #979797">alg:Breadth-firth Search</a> <a href="/tags/alg-Brute-Force/" style="font-size: 17.21px; color: #838383">alg:Brute Force</a> <a href="/tags/alg-Centroid-Decomposition/" style="font-size: 14px; color: #999">alg:Centroid Decomposition</a> <a href="/tags/alg-Depth-first-Search/" style="font-size: 20.07px; color: #707070">alg:Depth-first Search</a> <a href="/tags/alg-Divide-and-Conquer/" style="font-size: 14px; color: #999">alg:Divide and Conquer</a> <a href="/tags/alg-Dynamic-Porgramming/" style="font-size: 14px; color: #999">alg:Dynamic Porgramming</a> <a href="/tags/alg-Dynamic-Programming/" style="font-size: 22.57px; color: #5f5f5f">alg:Dynamic Programming</a> <a href="/tags/alg-Games/" style="font-size: 14px; color: #999">alg:Games</a> <a href="/tags/alg-Geometry/" style="font-size: 14px; color: #999">alg:Geometry</a> <a href="/tags/alg-Graph/" style="font-size: 15.43px; color: #8f8f8f">alg:Graph</a> <a href="/tags/alg-Greedy/" style="font-size: 21.86px; color: #646464">alg:Greedy</a> <a href="/tags/alg-Hash-Table/" style="font-size: 19.71px; color: #727272">alg:Hash Table</a> <a href="/tags/alg-Heap/" style="font-size: 15.43px; color: #8f8f8f">alg:Heap</a> <a href="/tags/alg-In-Order-Traversal/" style="font-size: 14.36px; color: #979797">alg:In-Order Traversal</a> <a href="/tags/alg-Index-Search-Array/" style="font-size: 14px; color: #999">alg:Index Search Array</a> <a href="/tags/alg-Linked-List/" style="font-size: 15.79px; color: #8d8d8d">alg:Linked List</a> <a href="/tags/alg-Map/" style="font-size: 14px; color: #999">alg:Map</a> <a href="/tags/alg-Math/" style="font-size: 22.93px; color: #5c5c5c">alg:Math</a> <a href="/tags/alg-Matrix/" style="font-size: 14px; color: #999">alg:Matrix</a> <a href="/tags/alg-Meet-in-the-Middle/" style="font-size: 14.36px; color: #979797">alg:Meet in the Middle</a> <a href="/tags/alg-Minimax/" style="font-size: 14.36px; color: #979797">alg:Minimax</a> <a href="/tags/alg-Minmax/" style="font-size: 14px; color: #999">alg:Minmax</a> <a href="/tags/alg-Monotonic-Stack/" style="font-size: 16.14px; color: #8a8a8a">alg:Monotonic Stack</a> <a href="/tags/alg-Network-Flow/" style="font-size: 14px; color: #999">alg:Network Flow</a> <a href="/tags/alg-Priority-Queue/" style="font-size: 14px; color: #999">alg:Priority Queue</a> <a href="/tags/alg-Queue/" style="font-size: 14.71px; color: #949494">alg:Queue</a> <a href="/tags/alg-Rabin-Karp/" style="font-size: 14px; color: #999">alg:Rabin-Karp</a> <a href="/tags/alg-Random/" style="font-size: 14.71px; color: #949494">alg:Random</a> <a href="/tags/alg-Rank-Tree/" style="font-size: 14px; color: #999">alg:Rank Tree</a> <a href="/tags/alg-Recursion/" style="font-size: 15.43px; color: #8f8f8f">alg:Recursion</a> <a href="/tags/alg-Recursive/" style="font-size: 14.36px; color: #979797">alg:Recursive</a> <a href="/tags/alg-Rejection-Sampling/" style="font-size: 14px; color: #999">alg:Rejection Sampling</a> <a href="/tags/alg-Reservoir-Sampling/" style="font-size: 14px; color: #999">alg:Reservoir Sampling</a> <a href="/tags/alg-Segmentation-Tree/" style="font-size: 14px; color: #999">alg:Segmentation Tree</a> <a href="/tags/alg-Set/" style="font-size: 14px; color: #999">alg:Set</a> <a href="/tags/alg-Sliding-Window/" style="font-size: 14px; color: #999">alg:Sliding Window</a> <a href="/tags/alg-Sort/" style="font-size: 15.07px; color: #929292">alg:Sort</a> <a href="/tags/alg-Stack/" style="font-size: 19px; color: #777">alg:Stack</a> <a href="/tags/alg-String/" style="font-size: 19px; color: #777">alg:String</a> <a href="/tags/alg-Suffix-Array/" style="font-size: 14px; color: #999">alg:Suffix Array</a> <a href="/tags/alg-Suffix-Tree/" style="font-size: 14px; color: #999">alg:Suffix Tree</a> <a href="/tags/alg-Ternary-Search/" style="font-size: 14px; color: #999">alg:Ternary Search</a> <a href="/tags/alg-Topological-Sort/" style="font-size: 14px; color: #999">alg:Topological Sort</a> <a href="/tags/alg-Treap/" style="font-size: 14px; color: #999">alg:Treap</a> <a href="/tags/alg-Tree/" style="font-size: 20.43px; color: #6d6d6d">alg:Tree</a> <a href="/tags/alg-Trie/" style="font-size: 14.36px; color: #979797">alg:Trie</a> <a href="/tags/alg-Two-Pointers/" style="font-size: 17.93px; color: #7e7e7e">alg:Two Pointers</a> <a href="/tags/alg-Union-find-Forest/" style="font-size: 15.43px; color: #8f8f8f">alg:Union-find Forest</a> <a href="/tags/artist-Ceremony/" style="font-size: 14px; color: #999">artist:Ceremony</a> <a href="/tags/artist-Cruel-Hand/" style="font-size: 14.36px; color: #979797">artist:Cruel Hand</a> <a href="/tags/artist-Have-Heart/" style="font-size: 14px; color: #999">artist:Have Heart</a> <a href="/tags/artist-Johnny-Cash/" style="font-size: 14px; color: #999">artist:Johnny Cash</a> <a href="/tags/artist-Touche-Amore/" style="font-size: 14px; color: #999">artist:Touche Amore</a> <a href="/tags/artist-Wir-Sind-Helden/" style="font-size: 14.71px; color: #949494">artist:Wir Sind Helden</a> <a href="/tags/translation/" style="font-size: 14.36px; color: #979797">translation</a> <a href="/tags/ucore/" style="font-size: 14px; color: #999">ucore</a> <a href="/tags/付勇林/" style="font-size: 15.79px; color: #8d8d8d">付勇林</a> <a href="/tags/卞之琳/" style="font-size: 14px; color: #999">卞之琳</a> <a href="/tags/屠岸/" style="font-size: 16.14px; color: #8a8a8a">屠岸</a> <a href="/tags/戴镏龄/" style="font-size: 15.79px; color: #8d8d8d">戴镏龄</a> <a href="/tags/曹明伦/" style="font-size: 15.43px; color: #8f8f8f">曹明伦</a> <a href="/tags/朱生豪/" style="font-size: 17.57px; color: #818181">朱生豪</a> <a href="/tags/李霁野/" style="font-size: 15.07px; color: #929292">李霁野</a> <a href="/tags/杨熙龄/" style="font-size: 14px; color: #999">杨熙龄</a> <a href="/tags/林天斗/" style="font-size: 14px; color: #999">林天斗</a> <a href="/tags/梁宗岱/" style="font-size: 16.86px; color: #868686">梁宗岱</a> <a href="/tags/梁葆成/" style="font-size: 14px; color: #999">梁葆成</a> <a href="/tags/袁广达/" style="font-size: 14px; color: #999">袁广达</a> <a href="/tags/郭沫若/" style="font-size: 14px; color: #999">郭沫若</a> <a href="/tags/黄新渠/" style="font-size: 14px; color: #999">黄新渠</a>
    </div>
  </section>


      
    
  
    
      
      
        <section class='list'>
  
<header class='pure'>
  <div><i class="fas fa-link fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;特别链接</div>
  
</header>

  <div class='content pure'>
    <ul class="entry">
      
        <li><a class="flat-box" title="https://wenj.github.io/" href="https://wenj.github.io/">
          <div class='name'>
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;wenj
          </div>
          
        </a></li>
      
        <li><a class="flat-box" title="http://bellasong.site/" href="http://bellasong.site/">
          <div class='name'>
            
              <i class="fas fa-comment-dots fa-fw" aria-hidden="true"></i>
            
            &nbsp;&nbsp;ssh
          </div>
          
        </a></li>
      
    </ul>
  </div>
</section>

      
    
  


        </aside>
        <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
    </div>
    <footer id="footer" class="clearfix">
  
  
    <div class="social-wrapper">
      
        
          <a href="mailto:zhanghuimeng1997@gmail.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://github.com/zhanghuimeng" class="social fab fa-github flat-btn" target="_blank" rel="external"></a>
        
      
        
          <a href="https://music.163.com/#/user/home?id=261028414" class="social fas fa-music flat-btn" target="_blank" rel="external"></a>
        
      
    </div>
  
  <br>
  <div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p>
</div>
  <div>本站使用 <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename">Material X</a> 作为主题，总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次。
  </div>
</footer>

    <script>setLoadingBarProgress(80);</script>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js"></script>

  <script>
    var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
    var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
    var ALGOLIA_API_KEY = "";
    var ALGOLIA_APP_ID = "";
    var ALGOLIA_INDEX_NAME = "";
    var AZURE_SERVICE_NAME = "";
    var AZURE_INDEX_NAME = "";
    var AZURE_QUERY_KEY = "";
    var BAIDU_API_ID = "";
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/"||"/";
    if(!ROOT.endsWith('/'))ROOT += '/';
  </script>



  <script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script>
  <script type="text/javascript">
    $(function() {
      const $reveal = $('.reveal');
      if ($reveal.length === 0) return;
      const sr = ScrollReveal({ distance: 0 });
      sr.reveal('.reveal');
    });
  </script>


  <script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>
  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>







  <script type="text/javascript">
    (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];
      if (typeof LivereTower === 'function') { return; }
      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;
      e.parentNode.insertBefore(j, e);
    })(document, 'script');
  </script>





  <script src="/js/app.js"></script>
<script src="/js/search.js"></script>





<!-- 复制 -->
<script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>Copy</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };

</script>


<!-- fancybox -->
<script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>





    <script>setLoadingBarProgress(100);</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>
