---
title: Leetcode水题合集
urlname: leetcode-easy-questions
toc: true
date: 2018-11-11 09:22:54
updated: 2018-11-11 09:22:54
tags: [Leetcode, alg:Linked List]
---

嗯，即使是我，最终也会发现Leetcode中有些题太水了而不值得专门写一篇post，有些题太愚蠢了而不值得专门写一篇post，等等。但有时候还是有一些可写的东西，所以就放在这里好了。

## 237. Delete Node in a Linked List

题目来源：[https://leetcode.com/problems/delete-node-in-a-linked-list/description/](https://leetcode.com/problems/delete-node-in-a-linked-list/description/)

难度：Easy

知识点：链表

这道题的傻逼之处在于，明明是要删除链表中的结点，最后却变成了（不得不）交换链表中结点的值，这一点也不科学。我的第一个想法是把给定结点（`node`）之后的值依次前移然后删掉最后一个结点；[题解](https://leetcode.com/articles/delete-node-linked-list/)中给出了只需赋值一次的方法，把`node->val`替换成`node->next->val`，`node->next`也替换成`node->next->next`。但这方法仍然不怎么样。

```cpp
class Solution {
public:
    void deleteNode(ListNode* node) {
        ListNode* p = node;
        while (p->next != nullptr) {
            p->val = p->next->val;
            if (p->next->next == nullptr) break;
            p = p->next;
        }
        p->next = nullptr;
    }
};
```

## 840. Magic Squares In Grid

题目来源：[https://leetcode.com/problems/magic-squares-in-grid/description/](https://leetcode.com/problems/magic-squares-in-grid/description/)

难度：Easy

知识点：数组

（数组是知识点不就相当于没有吗）

这道题就是在一个二维数组里寻找所有可能的三阶幻方。因为判断条件比较多，而三阶幻方的阶数又很小，不如直接对每个3x3的方框进行暴力判断。我写了横纵和的递推，当然事实上对角线之和，以及各个数字的出现次数这些都能递推，但就三阶幻方而言，这么做太大张旗鼓了，还不如直接暴力算了。

```cpp
class Solution {
public:
    int numMagicSquaresInside(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        if (n < 3 || m < 3) return 0;
        
        int ans = 0;
        int downSum[n][m], rightSum[n][m];
        
        for (int i = 0; i < m; i++)
            downSum[0][i] = grid[0][i] + grid[1][i] + grid[2][i];
        for (int i = 1; i <= n - 3; i++)
            for (int j = 0; j < m; j++)
                downSum[i][j] = downSum[i-1][j] - grid[i-1][j] + grid[i+2][j];
        
        for (int i = 0; i < n; i++)
            rightSum[i][0] = grid[i][0] + grid[i][1] + grid[i][2];
        for (int i = 0; i < n; i++)
            for (int j = 1; j <= m - 3; j++)
                rightSum[i][j] = rightSum[i][j-1] - grid[i][j-1] + grid[i][j+2];
        
        int f[20];
        for (int i = 0; i <= n - 3; i++)
            for (int j = 0; j <= m - 3; j++) {
                int sum = rightSum[i][j];
                if (rightSum[i+1][j] != sum || rightSum[i+2][j] != sum || downSum[i][j] != sum 
                    || downSum[i][j+1] != sum || downSum[i][j+2] != sum)
                    continue;
                if (grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2] != sum || grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2] != sum)
                    continue;
                
                memset(f, 0, sizeof(f));
                for (int i1 = 0; i1 < 3; i1++)
                    for (int j1 = 0; j1 < 3; j1++)
                        f[grid[i+i1][j+j1]]++;
                bool ok = true;
                for (int k = 1; k <= 9; k++)
                    if (f[k] != 1) {
                        ok = false;
                        break;
                    }
                if (!ok) continue;
                ans++;
            }
        return ans;
    }
};
```

## 852. Peak Index in a Mountain Array

题目来源：[https://leetcode.com/problems/peak-index-in-a-mountain-array/description/](https://leetcode.com/problems/peak-index-in-a-mountain-array/description/)

难度：Easy

知识点：数组，二分查找

（根本就没有把二分查找用在这种题目上的必要……）

题意是，给定一个单增再单减的数组，问最大值的元素对应的`index`。

直接扫一遍找到第一个开始单减的数就好了……

```cpp
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& A) {
        for (int i = 1; i < A.size(); i++) {
            if (!(A[i] > A[i - 1]))
                return i - 1;
        }
        return -1;
    }
};
```