---
title: 翻译：编写成功的解题代码（USACO）
urlname: crafting-winning-solutions-usaco-translation
toc: true
date: 2018-12-03 14:36:18
updated: 2018-12-03 14:36:18
tags: [Translation, USACO]
---

下面的翻译部分来自[^ref]，做了一点小修改。

[^ref]: [1.3 Crafting Winning Solutions - 翻译](https://www.cnblogs.com/DeathKid/archive/2011/11/14/2248931.html)

<!--A good way to get a competitive edge is to write down a game plan for what you're going to do in a contest round. This will help you script out your actions, in terms of what to do both when things go right and when things go wrong. This way you can spend your thinking time in the round figuring out programming problems and not trying to figure out what the heck you should do next... it's sort of like precomputing your reactions to most situations.-->

>一个帮你获得竞争优势的好方法是，为你在下一场比赛中将要做的事情写一份比赛计划。这将帮助你规划你的行动，意思是当一切顺利或者出了差错时各应该干什么。这样你就可以把比赛时的思考时间花在想编程问题上，而不是纠结你下一步到底应该做什么……这有点像是预计算出绝大多数情境下你应有的反应。

我喜欢这个“预计算”的说法。

<!--Mental preparation is also important.-->

>心理上的准备也很重要。

<!--Game Plan For A Contest Round-->

## 比赛计划

<!--Read through ALL the problems FIRST; sketch notes with algorithm, complexity, the numbers, data structs, tricky details, ...-->

>**首先**读完所有题目；简单记下算法、复杂度、数字、数据结构、棘手的细节……

“数字”这个词看起来有点怪。我想每道题一般也会有一些关键数字的，但是这个意思吗？

<!--Brainstorm many possible algorithms - then pick the stupidest that works!
DO THE MATH! (space & time complexity, and plug in actual expected and worst case numbers)
Try to break the algorithm - use special (degenerate?) test cases
Order the problems: shortest job first, in terms of your effort (shortest to longest: done it before, easy, unfamiliar, hard)-->

>* 头脑风暴出很多可能的算法——然后选择能够通过的算法中最愚蠢的！
>* **做数学估计**！(估计时空复杂度，并代入实际情况和最坏情况的值)
>* 尝试给算法挑错——使用特殊的（退化的？）样例
>* 将题目排序：最短任务优先，以你的工作量进行排序（从所需时间最短到最长：之前做过，简单，不熟悉，难）

[最短任务优先（SJF）调度算法](https://en.wikipedia.org/wiki/Shortest_job_next)……当然，在比赛中是合适的！

<!--Coding a problem - For each, one at a time:-->

>在写一道题的时候，逐个解决下列问题：

<!--Finalize algorithm
Create test data for tricky cases
Write data structures
Code the input routine and test it (write extra output routines to show data?)
Code the output routine and test it
Stepwise refinement: write comments outlining the program logic
Fill in code and debug one section at a time
Get it working & verify correctness (use trivial test cases)
Try to break the code - use special cases for code correctness
Optimize progressively - only as much as needed, and keep all versions (use hard test cases to figure out actual runtime)-->

>* 确定算法
>* 为棘手的情况编写测试数据
>* 编写数据结构
>* 编写输入代码并测试（并且编写额外的输出代码用于展示数据？）
>* 编写输出代码并测试
>* 逐步细化：写注释来概述程序的逻辑
>* 填写代码，每次只debug一个部分
>* 将程序跑起来 & 验证正确性（用一些平凡的样例）
>* 尝试找出代码的错误——用特殊情况测试代码的正确性
>* 逐步优化——到需要的程度即可，并保留所有的版本（用最难的样例测试实际运行时间）

这些步骤可以说是非常实用的——虽然显然并不是每道题都需要这么多步骤。首先确定算法肯定是正确的，当然在这一步也需要考虑之后能否进行优化，或者直接把优化写了也可以。逐步debug每个部分可能太费时间了，我只会在每个部分输出一下数据和结果之类的。

<!--Time management strategy and "damage control" scenarios-->

## 时间管理策略和“损害控制”场景

<!--Have a plan for what to do when various (foreseeable!) things go wrong; imagine problems you might have and figure out how you want to react. The central question is: "When do you spend more time debugging a program, and when do you cut your losses and move on?". Consider these issues:-->

>有没有一个方案来准备各类（可预见的）出错的事情；想象一下你可能会出的问题并且想出你怎么去纠正。中心问题是：“当你花更多的时间来debugging程序，什么时候你能减少你浪费的时间并且继续前进？”。想想下面的问题：

<!--How long have you spent debugging it already?
What type of bug do you seem to have?
Is your algorithm wrong?
Do you data structures need to be changed?
Do you have any clue about what's going wrong?
A short amount (20 mins) of debugging is better than switching to anything else; but you might be able to solve another from scratch in 45 mins.
When do you go back to a problem you've abandoned previously?
When do you spend more time optimizing a program, and when do you switch?
Consider from here out - forget prior effort, focus on the future: how can you get the most points in the next hour with what you have?-->

>* 你通常debugging完一个程序要多久？
>* 通常那些bug你经常犯？
>* 你的算法是否是错误的？
>* 你的数据结构要换嘛？
>* 那个地方出错了你有没有线索-（头绪）？
>* 一个很短的调试（20min）比换成其他任何方法都强；但是你也有可能花45min从头解决掉这个问题。
>* 你什么时候回头看你曾放弃的题目？
>* 你什么时候花更多的时间来优化，或者什么时候放弃从新开始？
>* 考虑从现在转变 - 忘掉之前的成就，focus on the future：你如何能在接下来一个小时内取到更多的分数用你所拥有的？

<!--Have a checklist to use before turning in your solutions:-->

>列一个提交代码前需要检查的清单：

<!--Code freeze five minutes before end of contest?
Turn asserts off.
Turn off debugging output.-->

>* 比赛结束5min前你有没有冻结代码？
>* 关闭断言
>* 关闭调试输出

<!--Tips & Tricks-->

## 提示和技巧

<!--Brute force it when you can
KISS: Simple is smart!
Hint: focus on limits (specified in problem statement)
Waste memory when it makes your life easier (if you can get away with it)
Don't delete your extra debugging output, comment it out
Optimize progressively, and only as much as needed
Keep all working versions!
Code to debug:
whitespace is good,
use meaningful variable names,
don't reuse variables,
stepwise refinement,
COMMENT BEFORE CODE.
Avoid pointers if you can
Avoid dynamic memory like the plague: statically allocate everything.
Try not to use floating point; if you have to, put tolerances in everywhere (never test equality)
Comments on comments:
Not long prose, just brief notes
Explain high-level functionality: ++i; /* increase the value of i by */ is worse than useless
Explain code trickery
Delimit & document functional sections
As if to someone intelligent who knows the problem, but not the code
Anything you had to think about
Anything you looked at even once saying, "now what does that do again?"
Always comment order of array indices
Keep a log of your performance in each contest: successes, mistakes, and what you could have done better; use this to rewrite and improve your game plan!-->

>* 能暴力就暴力
>* KISS: 简单就是聪明
>* 提示: 注意限制（尤其是题目的描述）
>* 浪费内存吧，如果这能让你的life 很爽（当然如果能解决掉那个不爽的问题）
>* 不要删掉你的调试内容，注释掉他。
>* 逐步优化，仅当需要更多的优化时。
>* 保留所有好使的代码版本！
>* 代码调试：
>   * 空格多多益善
>   * 使用有意义的变量名
>   * 不要重复使用变量
>   * 逐步细化,
>   * **代码前面写注释**.
>* 尽可能避免用指针
>* 避免麻烦的动态分配内存：静态的分配一切。
>* 尽量不要使用浮点型；如果不得不用，那把误差放在每个地方（不要同等的测试）
>* 评论注释：
>   * 不要写冗长的散文，只要简要说明
>   * 说明高层次的功能: ++i; /* increase the value of i by */ 没用！
>   * 解释代码诡异的地方
>   * 记录功能区和文件区
>   * 这些评论应该是针对知道这个问题的聪明人而不是代码本身
>   * 你不得不考虑的一些东西
>   * 看代码的时候多问几次：“现在是在做什么呢？”
>   * 始终说明数组的索引顺序
>* 记录你每次比赛时的表现：成功、失误、可以改进的地方；用这些重写和改进你的比赛计划！

<!--Complexity-->

## 复杂度

<!--Basics and order notation-->

### 基础知识和通用符号

<!--The fundamental basis of complexity analysis revolves around the notion of ``big oh'' notation, for instance: O(N). This means that the algorithm's execution speed or memory usage will double when the problem size doubles. An algorithm of O(N 2) will run about four times slower (or use 4x more space) when the problem size doubles. Constant-time or space algorithms are denoted O(1). This concept applies to time and space both; here we will concentrate discussion on time.-->

>复杂度分析的基础……

<!--One deduces the O() run time of a program by examining its loops. The most nested (and hence slowest) loop dominates the run time and is the only one mentioned when discussing O() notation. A program with a single loop and a nested loop (presumably loops that execute N times each) is O(N 2), even though there is also a O(N) loop present.-->

>通过检查程序中的循环……

<!--Of course, recursion also counts as a loop and recursive programs can have orders like O(b N), O(N!), or even O(N N).-->

>当然，递归也算是循环……

<!--Rules of thumb-->

## 经验法则

<!--When analyzing an algorithm to figure out how long it might run for a given dataset, the first rule of thumb is: modern (2004) computers can deal with 100M actions per second. In a five second time limit program, about 500M actions can be handled. Really well optimized programs might be able to double or even quadruple that number. Challenging algorithms might only be able to handle half that much. Current contests usually have a time limit of 1 second for large datasets.
16MB maximum memory use
210 ~approx~ 10 3
If you have k nested loops running about N iterations each, the program has O(N k) complexity.
If your program is recursive with b recursive calls per level and has l levels, the program O(b l) complexity.
Bear in mind that there are N! permutations and 2 n subsets or combinations of N elements when dealing with those kinds of algorithms.
The best times for sorting N elements are O(N log N).
DO THE MATH! Plug in the numbers.-->

>* 当分析这个算法对给出的测试数据会运行多长时间的时候，第一条法则是：当代计算机每秒能够处理 100M次运算。在5s限制的程序里，大概能处理500M次运算。一个优化好的程序也许真的能处理双倍或者四倍的量。有挑战性的算法大概仅仅需要处理这个的一半。当前比赛大都对处理大数据量有1s的限制。
>* 最大存储限制：16MB
>* 2^10约等于10^3
>* 如果你的程序有k层循环，每层循环的长度大约为N，那么程序的复杂度为O(N k)的复杂度。
>* 如果你的程序每次递归产生 b 次递归，大概有l层，那程序有O(b l)的复杂度。
>* 请记住排列 N! – 求 N 个元素的组合或者子集  2 n，处理这些算法的时间复杂度大概就是这些。
>* 处理排序 N 个元素最好的时间复杂度是O(N log N)。
>* 用数学计算！带人数字。

USACO这个存储限制真的小，开个5000\*5000的的数组就爆炸了。NOIP通常内存限制是128MB或者256MB。

<!--Examples-->

## 例子

A single loop with N iterations is O(N): 

```
sum = 0
for i = 1 to n
  sum = sum + i
```

A double nested loop is often O(N 2): 

```
fill array a with N elements
for i = 1 to n-1
  for j = i + 1 to n
    if (a[i] > a[j])
       swap (a[i], a[j])
```

Note that even though this loop executes N x (N+1) / 2 iterations of the if statement, it is O(N 2) since doubling N quadruples the execution times.

Consider this well balanced binary tree with four levels: 

![](craft1.gif)

An algorithm that traverses a general binary tree will have complexity O(2 N).

<!--Solution Paradigms-->

## 解题范式

<!--Generating vs. Filtering-->

### 生成 VS 过滤

<!--Programs that generate lots of possible answers and then choose the ones that are correct (imagine an 8-queen solver) are filters. Those that hone in exactly on the correct answer without any false starts are generators. Generally, filters are easier (faster) to code and run slower. Do the math to see if a filter is good enough or if you need to try and create a generator.-->

>filters 是 程序生成很多可能的答案然后选择其中对的答案（想想 8 皇后问题）。generating 是 在严格正确的没有错误的开始上操作。大体上说，filters 是容易（快速）去码但是运行很慢。用数学计算值不值得用generating去代替filters

<!--Precomputation-->

### 预计算

<!--Sometimes it is helpful to generate tables or other data structures that enable the fastest possible lookup of a result. This is called precomputation (in which one trades space for time). One might either compile precomputed data into a program, calculate it when the program starts, or just remember results as you compute them. A program that must translate letters from upper to lower case when they are in upper case can do a very fast table lookup that requires no conditionals, for example. Contest problems often use prime numbers - many times it is practical to generate a long list of primes for use elsewhere in a program.-->

>有时候生成一个表或者其他某种数据结构来查找某个结果是非常有帮助的。这叫做预处理（花空间来节省时间）。可以把要预处理的数据写成程序，在程序的一开始调用她，或者直接记住你算的结果。（译者：举了两个例子。一个是大小写转换的hash表，另一个是素数打表。不在翻译）

<!--Decomposition (The Hardest Thing At Programming Contests)-->

### 分解（编程竞赛时最难的事情）

<!--While there are fewer than 20 basic algorithms used in contest problems, the challenge of combination problems that require a combination of two algorithms for solution is daunting. Try to separate the cues from different parts of the problem so that you can combine one algorithm with a loop or with another algorithm to solve different parts of the problem independently. Note that sometimes you can use the same algorithm twice on different (independent!) parts of your data to significantly improve your running time.-->

>虽然在竞赛中用的有少于20种基础算法，相对综合的问题需要综合两个算法，这是个艰难的挑战。尝试从问题的不同部分分别分析，这样你能够结合某个算法得的一步与其他相对独立的部分的算法解决问题。注意有时候你能用一个算法两次，在不同的部分里（独立的！）来显著的提高你的程序运行时间。

<!--Symmetries-->

### 对称性

<!--Many problems have symmetries (e.g., distance between a pair of points is often the same either way you traverse the points). Symmetries can be 2-way, 4-way, 8-way, and more. Try to exploit symmetries to reduce execution time.-->

>很多问题存在对称性（比如：一对点的距离通常是一样的，不管你怎样遍历）。对称性可能是2-way, 4-way, 8-way, 甚至更多。尝试发现对称性并且缩短运行时间。

<!--For instance, with 4-way symmetry, you solve only one fourth of the problem and then write down the four solutions that share symmetry with the single answer (look out for self-symmetric solutions which should only be output once or twice, of course).-->

>例如，4-way 对称的，你仅仅需要算出问题的4分之1，然后用对称性和这个答案写出问题的 4 个答案（如果找到了自我对称的解决方案，那么可能只需要计算 1 或者 2次）。

<!--Forward vs. Backward-->

### 向前 VS 向后

<!--Surprisingly, many contest problems work far better when solved backwards than when using a frontal attack. Be on the lookout for processing data in reverse order or building an attack that looks at the data in some order or fashion other than the obvious.-->

>令人惊讶的是，许多比赛的问题倒着想比正着想容易的多。试探性的以相反的顺序去解决问题或者从比较明显或者有规律的数据入手。

<!--Simplification-->

### 简化

<!--Some problems can be rephrased into a somewhat different problem such that if you solve the new problem, you either already have or can easily find the solution to the original one; of course, you should solve the easier of the two only. Alternatively, like induction, for some problems one can make a small change to the solution of a slightly smaller problem to find the full answer.-->

一些问题可以被改写成一个略微不同的问题，就好像你在解决新问题一样，你就会从原始问题很快的找到解决方法；当然，你应该很轻松的解决。。。。。另外，像归纳，对某些问题你可以做些微小的改变找到答案，之道找到整个答案。
