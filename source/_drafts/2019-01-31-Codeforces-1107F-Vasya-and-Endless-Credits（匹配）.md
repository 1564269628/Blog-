---
title: Codeforces 1107F. Vasya and Endless Credits（匹配）
urlname: codeforces-1107f-vasya-and-endless-credits
toc: true
date: 2019-01-31 17:42:02
updated: 2019-01-31 17:42:02
tags:
---

题目来源：[https://codeforces.com/contest/1107/problem/F](https://codeforces.com/contest/1107/problem/F)

提交次数：2/2

## 题意

有`n`种借贷手续可以办理：

* 对于第`i`种手续，在激活当月月初发放`a[i]`元，之后（包括激活当月）连续`k[i]`个月每月月底返还`b[i]`元
* 每个月最多只能激活一种借贷
* `1 <= n <= 500`

问在任意时刻手中的总钱数的最大值是多少？

## 分析

这道题我完全不会做，只能看题解就是了……

### 转化为任务分配问题

在某个时刻（某个月中间），如果我们在`m`个月前激活了第`i`种贷款，则在此时它对我们手中钱数的贡献是`a[i] - min(k[i], m) * b[i]`。显然最优的选择是拿到贷款之后尽量少还钱，所以最多只需要考虑开始第一次激活之后`n`个月的时间长度。（这个观察是很重要的，不然很难转换问题……）

因此，可以为每种贷款都计算出，如果它是在`0, 1, ..., n-1`个月前被激活，对目前状态的总钱数的贡献是多少。然后构造这样一个矩阵：它的第`i`行表示贷款在`i`个月前被激活时对钱数的贡献，即`mat[i][j] = a[j] - min(k[j], i) * b[j]`。然后问题即转化成了，从这样一个矩阵中选出若干个元素，且不能在同一行（同一个月不能激活两个贷款）和同一列（一个贷款不能被激活两次）选元素，问最大和是多少？

于是据说这就是一个任务分配问题（[Assignment problem](https://en.wikipedia.org/wiki/Assignment_problem)），可以用最小费用流或者匈牙利算法来求解。这两个东西我大概都学过，但是已经忘得一干二净了。让我想想……

### 匈牙利算法

匈牙利算法一般被认为是求解二分图最大匹配问题的。（这一点我大概还记得）

匈牙利算法的核心在于找增广路。（这一点我现在想起来了）

匈牙利算法至少有两种实现形式：DFS和BFS。（我大概之前只会背DFS形式）[^bi-matching]

[^bi-matching]: [二分图的最大匹配、完美匹配和匈牙利算法](https://www.renfei.org/blog/bipartite-matching.html)

上面定义的匈牙利算法是不管边权的。但是实际上匈牙利算法是可以有边权的——也就是所谓的任务分配问题了。