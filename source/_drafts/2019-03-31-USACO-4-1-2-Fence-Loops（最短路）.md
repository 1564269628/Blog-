---
title: 'USACO 4.1.2: Fence Loops（最短路）'
urlname: usaco-4-1-2-fence-loops
toc: true
date: 2019-03-31 20:59:50
updated: 2019-03-31 20:59:50
tags: [USACO, alg:Shortest Path, alg:Dijkstra's Algorithm]
categories: USACO
---

## 题意

见[洛谷 P2738 篱笆回路 Fence Loops](https://www.luogu.org/problemnew/show/P2738)。

农场上有`N`条篱笆，已知每条篱笆的长度和它们两端连接的篱笆的编号，问篱笆形成的最小环的长度。保证没有自环。

<!--more-->

## 分析

### 读入数据处理

这道题的读入数据形式非常毒瘤——给的是每条边和相联边的编号。所以必须要预处理成点和边的形式才行。

我使用的方法也非常毒瘤。我直接把每条边的两侧看成两个点，用“和这个点连接的所有边”来表示这个点，然后去重。于是我搞出来了`map<vector<int>, int>`这种形式的东西……（事实上，[这是合法甚至合理的](https://stackoverflow.com/questions/8903737/stl-map-with-a-vector-for-the-key)）不过，令我困惑的一点是，如果图上事实上只有两个点，那么和这两个点各自相连的边都是一样的，上述去重方法并不可取。比如下列数据：

```
3
1 4 2 2
2 3
2 3
2 5 2 2
1 3
1 3
3 6 2 2
1 2
1 2
```

显然，这张图上有两个点，所有边都连在这两个点上；正确答案大概是9，然而我的AC代码输出了4。我猜这是测试数据的疏漏。

这之后用邻接表之类的数据结构就很合适了。

题解里提供了一些更加稀奇古怪的方法。读入数据保证和每条边的一侧连接的边的数量不超过8，所以

