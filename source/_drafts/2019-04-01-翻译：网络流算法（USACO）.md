---
title: 翻译：网络流算法（USACO）
urlname: network-flow-algorithms-usaco
toc: true
date: 2019-04-01 18:35:29
updated: 2019-04-29 16:35:00
tags: [USACO, translation]
categories: USACO
---

这是几乎全部机翻的版本。几乎可以肯定的是，这个翻译需要改进。

网络流真难……

<!--more-->

<!-- Prerequisite -->

## 前置知识

<!-- Shortest Path -->

>* 最短路

<!-- The Problem -->

## 问题

<!-- Given: A direct connected graph with integer weighted arcs, along with a source node and a sink node. -->

>给定一个具有整数权重的连通图，以及一个源结点和一个汇结点。

<!-- Each arc weight corresponds to the ``capacity'' of that arc. A flow through the graph is constructed by assigning an integer amount of ``flow'' to send through each edge such that: -->

>每条边的权重表示该边的“容量”。穿越该图的一个流通过为每条边分配一个整数流量构成，且满足：

<!-- The flow through each arc is no greater than the arc's capacity.
For each node other than the source and sink, total flow in is the same as total flow out. -->

>* 通过每条边的流量不超过每条边的容量。
>* 除了源和汇之外的结点，输入流量等于输出流量。

<!-- Maximize the total of the weights of the out-arcs of the source minus the weights of the in-arcs (or the total of the weights of the in-arcs of the sink minus the weights of the out-arcs). -->

>最大化源结点的输出量减输入量（或汇结点的输入量减输出量）。

<!-- Example -->

### 例子

<!-- Given: The layout of a collection of water pipes, along with the capacity of each pipe. Water in these pipes must flow downhill, so within each pipe, water can only flow in one direction. -->

>给定水管集合的布局，以及每个管道的容量。这些管道中的水必须向下流动，因此在每个管道内，水只能沿一个方向流动。

<!-- Calculate the amount of water that can flow from a given start (the water-purification plant) to a given end (your farm). -->

>计算从给定的起点（净水厂）到给定的终点（您的农场）可以流动的水量。

<!-- The Algorithm -->

## 算法

<!-- The algorithm (greedily) builds the network flow by iteratively adding flow from the source to the sink. -->

>该算法（贪婪地）通过迭代地添加从源到汇的流量来构建网络流。

<!-- Start with every arc having weight equal to the beginning weight (The arc weights will correspond to the amount of capacity still unused in that arc). -->

>开始时，将每条边的权重都置为初始权重（边的权重等于该边中还没有用完的容量）。

<!-- Given the current graph, find a path from the source to the sink across arcs that all have non-zero weight in the current graph. Calculate the maximum flow across this path, call it PathCap. -->

>给定当前的图，找到一条在当前图中从源到汇的只经过非零权重的边的路径。计算能通过该路径的最大流量，记为PathCap。

<!-- For each arc along the path, reduce the capacity of that arc by PathCap. In addition, add the reverse arc (the arc between the same two nodes, but in the opposite direction) with capacity equal to PathCap (if the reverse arc already exists, just increase its capacity). -->

>对于路径上的每条边，将该边的容量减去PathCap。除此之外，添加容量等于PathCap的反向边（连接两个相同结点但方向相反的边）；如果反向边已经存在，只需增加其容量。

<!-- Continue to add paths until none exist. -->

>继续添加路径，直到找不到更多路径位置。

<!-- This is guaranteed to terminate because you add at least one unit of flow each time (since the weights are always integers), and the flow is strictly monotonically increasing. The use of an added reverse arc is equivalent to reducing the flow along that path. -->

>这个算法必然可以终止，因为每次都至少增加一个单位的流量（因为权重总是整数），且流量是严格单调递增的。增加反向边的方法和减少路径上的流量是等价的。

<!-- If you are interested in a more detailed analysis of this algorithm, consult Sedgewick. -->

>如果你想对这个算法做一个更详细的分析，请去查Sedgewick的书。

<!-- Here is pseudocode for the algorithm:  -->

>下面是算法伪代码：

```py
 1   if (source = sink)
 2     totalflow = Infinity
 3     DONE

 4   totalflow = 0

 5   while (True)
 6   # 找到源到汇的容量最大的路径
 7   # 使用修改过的Djikstra算法
       # 算法初始化
 8     for all nodes i
 9       prevnode(i) = nil
10       flow(i) = 0
11       visited(i) = False
12     flow(source) = infinity

13     while (True)
14       maxflow = 0
15       maxloc = nil
16       # 找到还没有访问过的结点中流量（flow）最大的
17       for all nodes i
18         if (flow(i) > maxflow AND not visited(i))
19           maxflow = flow(i)
20           maxloc = i
21       if (maxloc = nil)
22         break inner while loop
23       if (maxloc = sink)
24         break inner while loop
24a      visited(maxloc) = true
25       # 更新它的邻居的流量
26       for all neighbors i of maxloc
27         if (flow(i) < min(maxflow, capacity(maxloc,i)))
28           prevnode(i) = maxloc
29           flow(i) = min(maxflow, capacity(maxloc,i))

30     if (maxloc = nil)         # 找不到路径
31       break outer while loop

32     pathcapacity = flow(sink)
33     totalflow = totalflow + pathcapacity

   # 将当前流加入网络中，更新容量
35     curnode = sink
         # for each arc, prevnode(curnode),
         # curnode on path:
36     while (curnode != source)
38       nextnode = prevnode(curnode)
39       capacity(nextnode,curnode) =
           capacity(nextnode,curnode) -
40                           pathcapacity
41       capacity(curnode,nextnode) =
           capacity(curnode,nextnode) +
42                           pathcapacity
43       curnode = nextnode
```

这个算法伪代码看起来有些令人头疼……总的来说，这是一种Ford–Fulkerson算法。而且是一种用修改过的Dijkstra算法进行Maximum capacity augmentation的算法。反向边的必要性我还没有完全理解，不过反正加了之后求的也只是min，所以没什么意义……

<!-- Running time of this formulation is O(F M), where F is the maximum flow and M is the number of arcs. You will generally perform much better, as the algorithm adds as much flow as possible every time. -->

>上述算法的复杂度是O(FM)，其中F是最大流量，M是边数。实际运行时间一般会比这好得多，因为算法每次都尽可能地增加流量。

<!-- To determine the flow across each arc, compare the starting capacity with the final capacity. If the final capacity is less, the difference is the amount of flow traversing that arc. -->

>为了确定每条边的流量，将起始容量和最终容量比较。如果最终容量更少，则差值就是穿过该边的流量大小。

<!-- This algorithm may create `eddies,' where there is a loop which does not contribute to the flow itself. -->

>上述算法可能会产生“漩涡”，即对总体流量没有贡献的环。

<!-- Execution Example -->

## 执行示例

<!-- Consider the following network, where the source is node 5, and the sink is node 2. -->

>考虑以下网络，其中源是结点5，汇是结点2。

![](flow1.gif)

<!-- The path with the highest capacity is {5,1,3,6,2}.  -->

>具有最高容量的路径是{5,1,3,6,2}。

![](flow2a.gif)

<!-- The bottleneck arc on this path is 1->3, which has a capacity of 5. Thus, reduce all arcs on the path by 5, and add 5 to the capacity of the reverse arcs (creating the arcs, if necessary). This gives the following graph:  -->

>此路径上的瓶颈边为1->3，其容量为5。因此，将路径上的所有边的容量减少5，并将反向弧的容量加5（如果需要，创建边）。于是得到下图：

![](flow2b.gif)

<!-- In the new graph, the path with highest capacity is {5,4,6,2}. -->

>在新图中，容量最大的路径是{5,4,6,2}。

![](flow2c.gif)

<!-- The capacity of this path is 3, so once again, reduce the forward arcs by 3, and increase the reverse arcs by 3.  -->

>此路径的容量为3，因此再次将前向边的容量减少3，并将反向边的容量增加3。

![](flow2d.gif)

<!-- Now the network's maximum capacity path is {5,4,6,3,2} -->

>现在网络的最大容量路径为{5,4,6,3,2}

![](flow2e.gif)

<!-- This flow has only a capacity of 1, as the arc from 5 to 4 has capacity 1. Once again, update the forward and backwards arcs appropriately. -->

>这条路径的容量仅为1，因为从5到4的边的容量为1。再次适当地更新前向和后向边。

![](flow2f.gif)

<!-- The resulting graph has no paths from the source to the sink. The only nodes reachable from the source node 5 are node 5 itself and node 1. -->

>生成的图没有从源到汇的路径。从源结点5可到达的唯一节点是结点5本身和结点1。

![](flow2g.gif)

<!-- The algorithm added three flows, the first with capacity 5, the second with capacity 3, and the last with capacity 1. Thus, the maximum flow through the network from node 5 to node 2 is 9. -->

>该算法增广了三次流，第一次容量为5，第二次容量为3，最后一次容量为1。因此，网络中从结点5到结点2的最大流量是9。

<!-- Extensions -->

## 扩展

<!-- Network flow problems are very extensible, mostly by playing with the graph. -->

>网络流问题是非常容易扩展的，主要是通过对图的修改。

<!-- To extend to the case of undirected graphs, simple expand the edge as two arcs in opposite directions. -->

>为了扩展到无向图的情况，简单地将无向边扩展为方向相反的两条边。

<!-- If you want to limit the amount of traffic through any node, split each node into two nodes, an in-node and and out-node. Put all the in-arcs into the in-node, and all of the out-arcs out of the out-node and place an arc from the in-node to the out-node with capacity equal to the capacity of the node. -->

>如果要限制通过每个结点的流量，将每个结点拆分为两个结点，即in-结点和out-结点。将所有入边连到in-结点，并将所有出边连出out-节点，并在in-结点和out-结点之间连接一条边，其容量等于结点的容量。

<!-- If you have multiple sources and sinks, create a `virtual source' and `virtual sink' with arcs from the virtual source to each of the sources and arcs from each of the sinks to the virtual sink. Make each of the added arcs have infinite capacity. -->

>如果你有多个源和汇，请创建一个“虚拟源”和“虚拟汇”，其中包含从虚拟源到每个源的边和从每个汇到虚拟汇的边。让每条添加的边具有无限的容量。

<!-- If you have arcs with real-valued weights, then this algorithm is no longer guaranteed to terminate, although it will asymptotically approach the maximum. -->

>如果边的权重是实数，那么这个算法不再保证能够终止，尽管它会渐近逼近最大值。

<!-- Alternative Problems -->

## 其他问题

<!-- Network flow can also be used to solve other types of problems that aren't so obvious -->

>网络流也可用于解决不那么明显的其他类型的问题。

<!-- Maximum Matching -->

### 最大匹配

<!-- Given a two sets of objects (call them A and B), where you want to `match' as many individual A objects with individual B objects as possible, subject to the constraint that only certain pairs are possible (object A1 can be matched with object B3, but not object B1 or B2). This is called the `maximum matching' problem. -->

>给定两组对象（称为A和B），你希望尽可能多地“匹配”单个A对象和单个B对象，且受到一定的限制（对象A1可以与对象B3匹配，但不是对象B1或B2）。这称为“最大匹配”问题。

<!-- To reformulate this as network flow, create a source and add an arc with capacity 1 from this source to each A object. Create a sink with an arc from each B object to it with capacity 1. In addition, if object Ai and Bk may be matched together, add an arc from Ai to Bk with capacity 1. Now run the algorithm and determine which arcs between A objects and B objects are used. -->

>要将这个问题重新表示为网络流问题，创建一个源，从该源到每个A对象连接一条容量为1的边。创建一个汇，从每个B对象连接一条容量为1的边到汇。此外，如果对象Ai和Bk可以匹配在一起，则添加一条从Ai到Bk的容量为1的边。现在运行算法，并确定A和B之间的哪些弧被使用了。

<!-- Minimum Cut -->

### 最小割

<!-- Given a weight undirected graph, what is the set of edges with minimum total weight such that it separates two given nodes. -->

>给定带权无向图，求能够分离两个给定结点的具有最小总权重的边集。

<!-- The minimum total weight is exactly the flow between those two nodes. -->

>最小总权重恰好是这两个结点之间的流量。

<!-- To determine the path, try removing each edge in increasing weight order, and seeing if it reduces the network flow (if it does, it should reduce the flow by the capacity of that edge. The first one which does is a member of the minimum cut, iterate on the graph without that edge. -->

>为了确定路径，尝试按权重递增的顺序删除每条边，并查看它是否减少了网络流量（如果是，它应该使得流量减去这条边的容量）。第一条这样的边是最小割的一部分，在没有这条边的情况下在图上迭代算法。

说实话这段我没太看懂……

<!-- This can be extended to node cuts by the same trick as nodes with limited capacity. Directed graphs work using the same trick. However, it can not solve the problem of finding a so-called `best match,' where each pairing has a `goodness' value, and you want to create the matching which has the highest total `goodness.' -->

>这可以通过与容量有限的结点相同的技巧扩展到结点切割。有向图的方法相同。然而，它无法解决找到所谓的“最佳匹配”的问题，其中每个配对都具有“良好”值，并且您想要创建具有最高总体“良好”的匹配。

<!-- Example Problems -->

## 例题

<!-- If the problems talks about maximizing the movement or flow of something from one location to another, it is almost assuredly maximum flow. If it talks about trying to separate two items minimally, it is probably minimum cut. If it talks about maximizes the pairing of any sort of thing (person, object, money, whatever), it is probably maximum matching. -->

>如果问题涉及最大化从一个位置到另一个位置的物体的移动或流动，则几乎可以确定是最大流。如果它试图最小化两个项目，它可能是最小割。如果它谈论最大化任何类型的东西（人，物，钱，等等）的配对，它可能是最大匹配。

<!-- Virus Flow -->

### 病毒流

<!-- You have a computer network, with individual machines connected together by wires. Data may flow either direction on the wire. Unfortunately, a machine on your network has caught a virus, so you need to separate this machine from your central server to stop the spread of this virus. Given the cost of shutting down the network connection between each pair of machines, calculate the minimum amount of money which must be spent to separate the contaminated machine from your server. -->

>有一个计算机网络，通过电线将各个机器连接在一起。数据可以在电线上的任一方向流动。遗憾的是，网络上有一台计算机已经感染了病毒，因此您需要将此计算机与中央服务器分开以阻止此病毒的传播。考虑到关闭每对机器之间的网络连接的成本，计算必须花费的最小金额来将受污染的机器与服务器分开。

<!-- This is exactly the min cut problem. -->

>这正是最小割问题。

<!-- Lumberjack Scheduling -->

### 伐木工人调度

<!-- Different types of trees require different techniques to be employed by lumberjacks for them to harvest the tree properly. Regardless of the tree or lumberjack, harvest a tree requires 30 minutes. Given a collection of lumberjacks, and the types of trees that each one is able to correctly cut down, and a collection of trees, calculate the maximum number of trees which may be cut down in the next half hour. -->

>不同类型的树木需要不同的技术来使伐木工人适当地采伐树木。收获一棵树需要30分钟，与树木和伐木工人无关。给定伐木工人的集合，以及每个人能够正确砍伐的树木类型，以及树木的集合，计算在下一个半小时可以砍伐的最大树木数量。

<!-- Each lumberjack can be paired with each tree of a type that he/she is able to properly harvest. Thus, the problem can be solved using the maximum matching algorithm. -->

>每个伐木工人都可以与他/她能够适当收获的每棵树配对。因此，可以使用最大匹配算法来解决该问题。

<!-- Telecowmunication (USACO Championship 1996) -->

### 电话通信（USACO Championship 1996）

<!-- Given a group of computers in the field, along with the wires running between the computers, what is the minimum number of machines which may crash before two given machines are the network are unable to communicate? Assume that the two given machines will not crash. -->

>给定一组计算机，以及计算机之间运行的电线，在两台给定机器无法通信之前，可能崩溃的最小机器数是多少？假设两台给定的机器不会崩溃。

<!-- This is equivalent to the minimum node cut problem. The two given machines can be arbitrarily labeled the source and sink. The wires are bidirectional. Split each node into an in-node and an out-node, so that we limit the flow through any given machine to 1. Now, the maximum flow across this network is equivalent to the minimum node cut. -->

>这相当于最小割问题。两台给定的机器可以任意标记为源和汇。电线是双向的。将每个节点拆分为in-节点和out-节点，这样我们就可以将通过任何给定计算机的流量限制为1。现在，通过该网络的最大流相当于最小割。

<!-- To actually determine the cut, iterative remove the nodes until you find one which lowers the capacity of the network. -->

>要实际确定割，请迭代删除节点，直到找到降低网络容量的节点。

<!-- Science Fair Judging -->

### 科学博览会评委

<!-- A science fair has N categories, and M judges. Each judge is willing to judge some subset of the categories, and each category needs some number of judges. Each judge is only able to judge one category at a given science fair. How many judges can you assign subject to these constraints? -->

>科学博览会有N个类别和M个评委。每位评委都愿意给某些类别打分，每个类别都需要一定数量的评委。每位评委只能在特定的科学博览会上评判一个类别。您可以根据这些限制分配多少名评委？

<!-- This is very similar to the maximum matching problem, except that each category can handle possibly more than one judge. The easiest way to do this is to increase the capacity of the arcs from categories to the sink to be the number of judges required. -->

>这与最大匹配问题非常相似，只是每个类别可以接收多个法官。最简单的方法是将从类别到汇的边的容量增加到所需的评委数量。

<!-- Oil Pipe Planning -->

### 油管规划

<!-- Given the layout (the capacity of each pipe, and how the pipes are connected together) of the pipelines in Alaska, and the location of each of the intersections, you wish to increase the maximum flow between Juneau and Fairbanks, but you have enough money to only add one pipe of capacity X. Moreover, the pipe can only be 10 miles long. Between which two intersections should this pipe be added to increase the flow the most? -->

>考虑到阿拉斯加管道的布局（管道的容量以及管道如何连接在一起）以及每个交叉口的位置，你希望增加朱诺和费尔班克斯之间的最大流量，但是你只有足够的钱增加一个容量为X的管道。此外，管道只能长为10英里。应该在哪两个交叉点之间添加这个管道以增加流量？

<!-- To solve this problem, for each pair of intersections within 10 miles of each other, calculate the increase in the flow between Juneau and Fairbanks if you add a pipe between the intersections. Each of these sub-problems is exactly maximum flow. -->

>为了解决这个问题，对于彼此相距10英里内的每对交叉点，计算如果在交叉点之间添加管道，朱诺和费尔班克斯之间增加的流量。每一个子问题都是最大流。
