---
title: Intel80X86架构概述
toc: true
date: 2018-03-28 12:57:08
tags:
urlname: intel-80x86-architecture-overview
---

这个现在只是草稿而已。写这个太tm烦了。。。

## 模式
IA-32架构一共有4个模式：
* 保护模式：一般使用的模式
* 实模式：刚开机时的默认模式，和8086环境相同
* SMM模式
* 虚拟8086模式
我们目前只关心前两个模式就行。保护模式和实模式相互切换的方法是切换CR0寄存器中的PE位，当然还需要一些其他的设置，以后会讲到。

## 数据结构和寄存器
下面介绍X86相关的数据结构和寄存器。如果不介绍这些，那么具体的内存管理机制就很难看懂了。

呃呃，我现在才发现，我不知道何为系统架构。。

最重要的数据结构包括：
* 描述符
* 门
* 描述符表
* 选择子
* 段

### 全局描述符表（Global Descriptor Table，GDT）和本地描述符表（Local Descriptor Table，LDT）
这是一种数据结构。一般存储在内存中。是一个表，表中的每一项称为段描述符（segment descriptor），提供段基址和访问权限等信息。

段选择子（segment selector）是用来访问段描述符的，其中包括了**段描述符在全局/本地描述符表中的偏移量**，全局/本地信息（访问GDT还是LDT），以及访问权限信息。

GDT的基址的线性地址存储在GDTR寄存器中，LDT的基址的线性地址存储在LDTR寄存器中。（为何是线性地址？）

### 系统段（system segment）、段描述符和门（gate）
除了代码段、数据段和堆栈段之外，还有两种系统段：任务状态段（task-state segment，TSS）和LDT。（因为似乎每个任务对应自己的TSS和LDT，所以应该有多个系统段）GDT不被认为是一个段，因为它无法通过段选择符和段描述符的组合访问。TSS和LDT拥有对应的段描述符。

系统定义了一系列特殊的描述符，称为门（中断门、陷阱门和任务门）。它们为用户进程提供了访问特权级较高代码的方法。为了通过中断门访问程序，调用程序提供门的选择符，检查特权级，如果合法，则通过段选择子访问对应的代码段。如果特权级发生变化，则栈也会切换。新的栈对应的段选择符是通过当前任务的TSS获得的。

### 任务状态段和任务门
TSS定义了任务执行环境的状态，包括通用寄存器、段寄存器、EFLAGS寄存器、EIP寄存器，以及三个特权级的堆栈段的栈顶指针的段选择子。TSS还包含了当前任务的LDT的段选择子，以及页表的基址（是线性地址么？）

保护模式下，程序都执行在当前任务下。当前任务的TSS的段选择子存放在任务寄存器中。切换新任务的方法是CALL或JMP指令。切换过程中会做以下几件事：
* 将当前任务的状态存储在当前的TSS中
* 通过段选择子，加载新任务的任务寄存器
* 通过GDT中存储的段描述符访问新的TSS
* 从新的TSS中加载新的任务状态，主要都是那堆寄存器
* 开始执行新任务
（也就是，每个任务执行环境对应一个TSS段，就像每个进程一般有代码段和数据段那样。切换任务时，通过某种方法获得新任务的TSS段选择子，这个段选择子从GDT中读出对应的TSS段描述符，此时才能访问TSS段中的内容。当然存储当前任务的TSS的过程同理。）

任务也可以通过任务门来访问，它和普通的门相似，但是提供的是用段选择子指向TSS的功能。（中间仍然要经过查GDT这个过程）

### 中断和异常处理
中断描述符表（interrupt descriptor table，IDT）处理中断和异常。IDT存储一系列门描述符，提供中断处理例程的访问服务。IDT也不是一个段，它的基址的线性地址存储在IDTR寄存器中。

IDT的门描述符有三种：中断门，陷阱门，任务门。内部硬件提供中断向量，其中包含IDT中描述符表的index。处理中断门和陷阱门的方法和处理调用门的方法类似（什么时候讲了通过调用门处理调用程序了？我咋不知道？）。如果描述符是一个任务门，则进行任务切换。

### 内存管理
支持物理访存和虚拟内存（分页）。物理访存就是把线性地址直接当成物理地址。开启分页时，所有的代码段、数据段、堆栈段和**系统段**（还有**GDT**和**IDT**）都可能被换出去。（这真是解释了一个未解之谜，为啥都要存线性地址）

存储分页信息的页表结构位于内存中。页表结构的基址（物理地址）存在CR3寄存器中，页表项提供页帧的基址（物理地址）、访问权限等信息。

在使用页表机制时，线性地址分成若干部分。（这个我们很熟了。）系统可以只有一个页表，也可以是每个任务有一个页表。（但是如何实现？？？）

#### 与内存管理相关的寄存器
（虽然这些寄存器之前讲到过了，也不全是关于我们一般意义上的内存管理的）

（此处应有一张图）

总之就是把GDTR、IDTR、TR（任务寄存器）和LDTR再讲一遍。

##### GDTR（全局描述符表寄存器）
GDTR寄存器有48位，其中47-16位存储的是GDT的32位基址（线性地址），15-0位存储的是表的大小。LGDT和SGDT指令负责加载和保存GDTR寄存器。上电时，GDTR的基址初始化为0，表大小初始化为`0FFFFH`。为了切换到实模式，必须为GDTR装载新的基址。

##### LDTR（局部描述符表寄存器）
感觉这个部分很不好理解。。。

总之在图示里面，LDTR分成两个部分，一部分是长度为15的系统段寄存器（里面存的是段选择子）；另一部分是不知道长度为多少的段描述符寄存器（自动加载），里面包括32位的线性基地址，段长度，和段属性。

LDTR对应的指令是LLDT和SLDT，他们只加载和存储LDTR寄存器的段选择子寄存器部分。因为LDT是一个段，它大概必须要通过GDT来访问，所以包含LDT的段的描述符必须存在于GDT中，我们操纵的就是这个描述符对应的段选择子。LDTR的剩余部分相当于是缓存了GDT中LDT段的描述符，包括线性基址、段长度和属性等。

发生任务切换时，LDTR自动加载新任务的LDT段的段选择子，缓存其对应的段描述符。上电时，段选择子部分自动置为0，缓存的线性基址置为0，段长度置为`0FFFFH`。

##### IDTR（中断描述符表寄存器）
IDTR的形式和GDTR是一样的，因为IDT并不是一个段，因此并不需要通过GDT来访问，因此也就没有段选择子。其余和GDTR都一样。

##### TR（任务寄存器）
因为TSS也是一个段，所以TR的形式和LDTR是一样的。上电后的情况和切换任务时的情况与LDTR相似。

### 系统寄存器
初始化和控制系统所需：
* EFLAGS寄存器中的系统flag和IOPL位，控制任务和模式切换，中断处理，指令跟踪，访问权限
* 控制寄存器（CR0，CR2,3,4）：控制系统级指令，看不懂
* debug寄存器
* GDTR，LDTR和IDTR寄存器：对应的表的基址（线性地址）和大小
* 任务寄存器：当前任务的TSS的线性地址和大小

#### EFLAGS寄存器

此处应有个图

一般只有特权级高的代码才能修改这些位。包括：
* TF（8）：陷阱，置位时开启单步调试模式，每执行一条指令就产生一个调试异常
* IF（9）：开启硬件中断，但不会影响不可屏蔽中断
* IOPL（12-13）：I/O特权级，当前运行中的程序或任务的I/O特权级，要求CPL<=IOPL才能进行I/O操作。
* NT（14）：嵌套任务，执行CLL指令，中断或异常任务时置位，通过IRET返回时清零。
……好多其他的位，暂时应该用不到

#### 控制寄存器
总之有3个比较重要的，但是把所有位都列出来太麻烦了，所以先不列了。

* CR0：控制处理器状态
  * PG（31）：置位时开启分页，不置位时，线性地址=物理地址
  * CD（30）：关闭缓存；当CD和NW位都清零时，在处理器的内部和外部缓存中开启对全部物理内存的缓存
  * NW（29）：不写通；当CD和NW位都清零时，开启写通和写回（暂时不知道这都是在说啥）
  * WP（16）：写保护，置位时禁止管程写只读页；这个位使得UNIX系统的COW方法容易实现（我倒是很想知道这个怎么实现）
  * TS（3）：任务已切换；好多说明，都不知道在说些啥
  * PE（0）：开启保护模式
* CR2：保存发生缺页异常的线性地址
* CR3：页表的物理地址，以及两个控制位（PCD和PWT，控制页表在处理器内部的缓存）。值存高20位，低12位默认为0
  * PCD（4）：禁用页级缓存；控制用于访问当前页表的一级页表的内存种类（啥？？）
  * PWT（3）：页级写通？？？

### 其他系统资源
感觉根本用不到，不看了

## 系统指令大全
一大堆乱七八糟的东西。。。暂时先不写了，太多了，烦。。。
