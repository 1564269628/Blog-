---
title: 《操作系统》第14讲：“实验5-用户线程管理”总结
urlname: os-mooc-lecture-14-summary
toc: true
tags: [操作系统, 课程总结]
---

## 课程内容概述
TODO

## 练习
来自[lab5 用户进程 在线练习](https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/05-4-lab5-quiz.md)和[lab5 spoc 思考题](https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/05-4-lab5-spoc-discussion.md)。

### 选择填空题
**下列叙述中正确的是()**

* lab5建立了用户进程，且0~3GB都是用户可访问空间，用户进程可进行正常读写
* lab5建立了用户进程，且3GB~4GB都是内核可访问空间，内核可进行正常读写
* **lab5中的第一个用户进程是内核创建的。**
* **lab5中的用户进程可通过fork创建新的用户进程。**

lab5中建立了用户进程这一点没啥问题。用户和内核可访问的空间这点有问题。简单来说，内核虚拟内存空间处于0xC0000000~0xF8000000位置（KERNBASE~KERNTOP），用户进程可访问的虚拟内存空间位于0x0080000~-0xB0000000位置（UTEXT~USERTOP）。

> 这样ucore把用户进程的虚拟地址空间分了两块，一块与内核线程一样，是所有用户进程都共享的内核虚拟地址空间，映射到同样的物理内存空间中，这样在物理内存中只需放置一份内核代码，使得用户进程从用户态进入核心态时，内核代码可以统一应对不同的内核程序；另外一块是用户虚拟地址空间，虽然虚拟地址范围一样，但映射到不同且没有交集的物理内存空间中。这样当ucore把用户进程的执行代码（ 即应用程序的执行代码） 和数据（ 即应用程序的全局变量等） 放到用户虚拟地址空间中时，确保了各个进程不会“非法”访问到其他进程的物理内存空间。

---

**lab5通过`do_execve`函数执行新的程序，为此需要完成（）**

* **更新用户进程的context**
* **更新用户进程的代码内容**
* **更新用户进程的数据内容**
* **更新用户进程的页表基址**

Lab5中的`do_execve`函数的主要功能就是，放弃当前程序的一切内存空间等资源，将新的程序填充到自己里面。所以显然上述内容都要更新。

```
// do_execve - call exit_mmap(mm)&put_pgdir(mm) to reclaim memory space of current process
//           - call load_icode to setup new memory space accroding binary prog.
int
do_execve(const char *name, size_t len, unsigned char *binary, size_t size) {
    struct mm_struct *mm = current->mm;
    if (!user_mem_check(mm, (uintptr_t)name, len, 0)) {
        return -E_INVAL;
    }
    if (len > PROC_NAME_LEN) {
        len = PROC_NAME_LEN;
    }

    char local_name[PROC_NAME_LEN + 1];
    memset(local_name, 0, sizeof(local_name));
    memcpy(local_name, name, len);

    if (mm != NULL) {
        lcr3(boot_cr3);
        if (mm_count_dec(mm) == 0) {
            exit_mmap(mm);
            put_pgdir(mm);
            mm_destroy(mm);
        }
        current->mm = NULL;
    }
    int ret;
    if ((ret = load_icode(binary, size)) != 0) {
        goto execve_exit;
    }
    set_proc_name(current, local_name);
    return 0;

execve_exit:
    do_exit(ret);
    panic("already exit: %e.\n", ret);
}
```

ucore docs中指出，此函数的主要工作流程如下：
> 首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。由于此处的initproc是内核线程，所以mm为NULL，整个处理都不会做。
接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。load_icode函数完成了整个复杂的工作。

---

**lab5通过`do_icode`函数执行新的程序，为此需要完成（）**

* **设置用户堆栈**
* **修改页表**
* **根据ELF执行文件的格式描述分配内存并填写内容**
* **设置用户态的EFLAG寄存器不可屏蔽中断**

ucore docs中给出的函数工作流程：
> 1. 调用mm_create函数来申请进程的内存管理数据结构mm所需内存空间，并对mm进行初始化；
2. 调用setup_pgdir来申请一个页目录表所需的一个页大小的内存空间，并把描述ucore内核虚空间映射的内核页表（ boot_pgdir所指） 的内容拷贝到此新目录表中，最后让mm->pgdir指向此页目录表，这就是进程新的页目录表了，且能够正确映射内核虚空间；
3. 根据应用程序执行码的起始位置来解析此ELF格式的执行程序，并调用mm_map函数根据ELF格式的执行程序说明的各个段（代码段、数据段、BSS段等） 的起始位置和大小建立对应的vma结构，并把vma插入到mm结构中，从而表明了用户进程的合法用户态虚拟地址空间；
4. 调用根据执行程序各个段的大小分配物理内存空间，并根据执行程序各个段的起始位置确定虚拟地址，并在页表中建立好物理地址和虚拟地址的映射关系，然后把执行程序各个段的内容拷贝到相应的内核虚拟地址中，至此应用程序执行码和数据已经根据编译时设定地址放置到虚拟内存中了；
5. 需要给用户进程设置用户栈，为此调用mm_mmap函数建立用户栈的vma结构，明确用户栈的位置在用户虚空间的顶端，大小为256个页，即1MB，并分配一定数量的物理内存且建立好栈的虚地址<-->物理地址映射关系；
6. 至此,进程内的内存管理vma和mm数据结构已经建立完成，于是把mm->pgdir赋值到cr3寄存器中，即更新了用户进程的虚拟内存空间，此时的initproc已经被hello的代码和数据覆盖，成为了第一个用户进程，但此时这个用户进程的执行现场还没建立好；
7. 先清空进程的中断帧，再重新设置进程的中断帧，使得在执行中断返回指令“iret”后，能够让CPU转到用户态特权级，并回到用户态内存空间，使用用户态的代码段、数据段和堆栈，且能够跳转到用户进程的第一条指令执行，并确保在用户态能够响应中断；

其中设置中断帧这一步是Lab5的练习1。

---

**关于进程管理的COW(Copy On Write)机制叙述正确的是（）**

* 父进程创建子进程需要复制父进程的内存空间
* 父进程创建子进程需要给子进程分配内核堆栈
* 父进程创建子进程需要给子进程分配用户堆栈
* **父进程创建子进程需要创建子进程的页表,但不复制父进程内存空间**

总之不需要复制也不需要分配，只是创建一个新的页表，然后和父进程页表指向相同位置。需要进行写时就新创建一页。

### 简答题

**第一个用户进程创建有什么特殊的？**

> 用户态代码段的初始化

好吧，答案是这么说的，但是我并不认同……总之，本实验中第一个用户进程是由第二个内核线程initproc通过把hello应用程序执行
码覆盖到initproc的用户虚拟内存空间来创建的。具体的大概方法是调用`kernel_execve()`函数，触发`SYS_exec`系统中断，然后继续调用`do_execve()`和`load_icode()`函数完成这一过程。其他用户进程是用户进程通过`SYS_fork`系统调用创建的（大概）。

---

**系统调用的参数传递过程？**

参见：用户态函数syscall()中的汇编代码。下面的代码摘自`user/libs/syscall.c`：
```c
static inline int
syscall(int num, ...) {
    va_list ap;
    va_start(ap, num);
    uint32_t a[MAX_ARGS];
    int i, ret;
    for (i = 0; i < MAX_ARGS; i ++) {
        a[i] = va_arg(ap, uint32_t);
    }
    va_end(ap);

    asm volatile (
        "int %1;"
        : "=a" (ret)
        : "i" (T_SYSCALL),
          "a" (num),
          "d" (a[0]),
          "c" (a[1]),
          "b" (a[2]),
          "D" (a[3]),
          "S" (a[4])
        : "cc", "memory");
    return ret;
}
```

很显然，参数是这样传递的：
* 触发INT 0x80中断（T_SYSCALL）
* eax中存放系统调用号
* edx、ecx、ebx、edi、esi中按照顺序存放前五个参数
* 返回值存放在eax中

令人感到奇怪的是，这与Linux系统在x86架构下一般的习惯并不相符。（<https://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-on-i386-and-x86-6>，其中给出的顺序是ebx、ecx、edx、esi、edi）。不过这并不是很重要，总之这个顺序与`kern/syscall/syscall.c`中对应的代码是相符的：

```
void
syscall(void) {
    struct trapframe *tf = current->tf;
    uint32_t arg[5];
    int num = tf->tf_regs.reg_eax;
    if (num >= 0 && num < NUM_SYSCALLS) {
        if (syscalls[num] != NULL) {
            arg[0] = tf->tf_regs.reg_edx;
            arg[1] = tf->tf_regs.reg_ecx;
            arg[2] = tf->tf_regs.reg_ebx;
            arg[3] = tf->tf_regs.reg_edi;
            arg[4] = tf->tf_regs.reg_esi;
            tf->tf_regs.reg_eax = syscalls[num](arg);
            return ;
        }
    }
    print_trapframe(tf);
    panic("undefined syscall %d, pid = %d, name = %s.\n",
            num, current->pid, current->name);
}
```

Ref: https://www.ibm.com/developerworks/library/l-ia/index.html

---

**getpid的返回值放在什么地方了？**

> 参见：用户态函数syscall()中的汇编代码

这个问题很平凡，只是放在eax里面了而已。（又不是fork……）

---

**ucore的内存布局中，页表、用户栈、内核栈在逻辑地址空间中的位置？**

参见`kern/mm/memlayout.h`：
```
#define VPT 0xFAC00000

#define KSTACKPAGE 2 // # of pages in kernel stack

#define KSTACKSIZE (KSTACKPAGE * PGSIZE) // sizeof kernel stack

#define USERTOP 0xB0000000

#define USTACKTOP USERTOP

#define USTACKPAGE 256 // # of pages in user stack

#define USTACKSIZE (USTACKPAGE * PGSIZE) // sizeof user stack
```

事实上，页表位于内核虚拟空间0xFAC00000~0xFB000000位置，用户栈位于用户虚拟空间?~0xB0000000位置（因为栈是向下增长的），内核栈位于内核虚拟空间……诶怎么没说内核栈在什么位置？我猜是在~0xF8000000位置吧。

这个字符画的水平十分高超：
```
/* *
 * Virtual memory map:                                          Permissions
 *                                                              kernel/user
 *
 *     4G ------------------> +---------------------------------+
 *                            |                                 |
 *                            |         Empty Memory (*)        |
 *                            |                                 |
 *                            +---------------------------------+ 0xFB000000
 *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE
 *     VPT -----------------> +---------------------------------+ 0xFAC00000
 *                            |        Invalid Memory (*)       | --/--
 *     KERNTOP -------------> +---------------------------------+ 0xF8000000
 *                            |                                 |
 *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE
 *                            |                                 |
 *     KERNBASE ------------> +---------------------------------+ 0xC0000000
 *                            |        Invalid Memory (*)       | --/--
 *     USERTOP -------------> +---------------------------------+ 0xB0000000
 *                            |           User stack            |
 *                            +---------------------------------+
 *                            |                                 |
 *                            :                                 :
 *                            |         ~~~~~~~~~~~~~~~~        |
 *                            :                                 :
 *                            |                                 |
 *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *                            |       User Program & Heap       |
 *     UTEXT ---------------> +---------------------------------+ 0x00800000
 *                            |        Invalid Memory (*)       | --/--
 *                            |  - - - - - - - - - - - - - - -  |
 *                            |    User STAB Data (optional)    |
 *     USERBASE, USTAB------> +---------------------------------+ 0x00200000
 *                            |        Invalid Memory (*)       | --/--
 *     0 -------------------> +---------------------------------+ 0x00000000
 * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.
 *     "Empty Memory" is normally unmapped, but user programs may map pages
 *     there if desired.
 *
 * */
```

---

**在do_execve中的的当前进程如何清空地址空间内容的？在什么时候开始使用新加载进程的地址空间？**

> 清空进程地址空间是在initproc所在进程地址空间
CR3设置成新建好的页表地址后，开始使用新的地址空间

这个答案简直语无伦次……总之上面已经说过`do_execve()`函数的流程了。清空地址空间是通过释放`mm_struct`结构完成的（虽然initproc并不会这么做，因为它直接用的是内核的`mm_struct`）。至于页表，`do_execve()`在释放`mm_struct`之前会先换成内核自己的页表；`load_icode()`中，设置进程的新`mm_struct`时会加载新页表（第5步）。

---

**新加载进程的第一级页表的建立代码在哪？**

在`load_icode()`的第2步中，调用了`setup_pgdir(mm)`。

---

**do_execve在处理中是如何正确区分出用户进程和线程的？并为此采取了哪些不同的处理？**

我猜这道题说的是内核线程吧。

```c
if (mm != NULL) {
    lcr3(boot_cr3);
    if (mm_count_dec(mm) == 0) {
        exit_mmap(mm);
        put_pgdir(mm);
        mm_destroy(mm);
    }
    current->mm = NULL;
}
```

内核线程的`mm`直接借用了内核自己的`mm`，所以这里处理了这一点。

---

**第一个内核线程和第一个用户进程的创建有什么不同？**

* 相应线程的内核栈创建时，多了SS和ESP的设置；
* 用户进程需要创建用户地址空间，并把用户代码复制到用户地址空间；

设置ss和esp对应lab5的练习1：在用户进程的内核栈中存放的`trapframe`中填写对应的寄存器。其次就是要`load_icode`了，不能直接调用内核中的函数。而且不能和内核共用页表，要新建自己的页表。

---

**尝试跟踪分析新创建的用户进程的开始执行过程？**

……反正我写的实验报告中是这么说的：

`load_icode`函数成功结束运行后，系统中断返回到`exit`的第一行代码。`exit`本身的执行过程在此暂时忽略。

`exit`线程执行结束之后，系统切换到`initproc`线程，它进行检查并退出。

差不多吧。

---

**为什么新进程的内核堆栈可以先于进程地址空间复制进行创建？**

内核栈在进程的内核地址空间，而各进程的内核地址空间是共享的。

---

**进程复制的代码在哪？复制了哪些内容？**



进程复制过程中有哪些修改？为什么要修改？
内核栈

页表

trapframe

context

PCB字段修改

分析第一个用户进程的创建流程，说明进程切换后执行的第一条是什么。
14.6 内存管理的copy-on-write机制
什么是写时复制？
写时复制的页表在什么时候进行复制？共享地址空间和写时复制有什么不同？
存在有多个（n>2）进程具有父子关系，且采用了COW机制的情况。这个情况与只有父子两个进程的情况相比，在设计COW时，需要注意的新问题是什么？有何解决方案？

### 实践题

**尝试在panic函数中获取并输出用户栈和内核栈的函数嵌套信息和函数调用参数信息，然后在你希望的地方人为触发panic函数，并输出上述信息。**

没写。

---

**尝试在panic函数中获取和输出页表有效逻辑地址空间范围和在内存中的逻辑地址空间范围，然后在你希望的地方人为触发panic函数，并输出上述信息。**

没写。

---

**尝试在进程运行过程中获取内核空间中各进程相同的页表项（代码段）和不同的页表项（内核堆栈）？**

没写。。。
