---
title: 《算法导论》第07章习题解答
urlname: introduction-to-algorithms-chapter-07-solutions
toc: true
mathjax: true
date: 2018-07-01 17:01:10
tags: [CLRS]
---

## Exercises
### 7.1
#### 7.1-1
Using Figure 7.1 as a model, illustrate the operation of PARTITION on the array $A = \langle 13; 19; 9; 5; 12; 8; 7; 4; 21; 2; 6; 11 \rangle$.

![Figure 7.1](fig07-1.png)

---

![](0701-1.png)

#### 7.1-2
What value of q does PARTITION return when all elements in the array $A[p .. r]$ have the same value? Modify PARTITION so that $q = \lfloor (p + r) / 2 \rfloor$ when all elements in the array $A[p .. r]$ have the same value.

---

由于$A$中所有元素都<=主元，因此i会不断增加，最后返回的是$r$。

#### 7.1-3

Give a brief argument that the running time of PARTITION on a subarray of size $n$ is $\Theta(n)$.

#### 7.1-4

How would you modify QUICKSORT to sort into nonincreasing order?

### 7.2

#### 7.2-1
Use the substitution method to prove that the recurrence $T(n) = T(n-1) + \Theta(n)$ has the solution $T(n) = \Theta(n^2)$ as claimed at the beginning of Section 7.2.

---

$$T(n) = T(n-1) + \Theta(n) = T(n - 2) + \Theta(n - 1) + \Theta(n) \\\\ = \cdots = T(0) + \Theta(\sum_{i=1}^{n} i) = T(0) + \Theta(\frac{n(n+1)}{2}) = \Theta(n^2)$$

#### 7.2-2
What is the running time of QUICKSORT when all elements of array A have the same value?

#### 7.2-3
Show that the running time of QUICKSORT is $\Theta(n^2)$ when the array A contains distinct elements and is sorted in decreasing order.

#### 7.2-4
Banks often record transactions on an account in order of the times of the transactions, but many people like to receive their bank statements with checks listed in order by check number. People usually write checks in order by check number, and merchants usually cash them with reasonable dispatch. The problem of converting time-of-transaction ordering to check-number ordering is therefore the problem of sorting almost-sorted input. Argue that the procedure INSERTION-SORT would tend to beat the procedure QUICKSORT on this problem.

#### 7.2-5
Suppose that the splits at every level of quicksort are in the proportion $1-\alpha$ to $\alpha$ where $0 < a \leq 1/2$ is a constant. Show that the minimum depth of a leaf in the recursion tree is approximately $-\lg{n} / \lg{\alpha}$ and the maximum depth is approximately $-\lg{n} / \lg{(1 - \alpha)}$ (Don’t worry about integer round-off.)

---

显然最小深度发生在划分比例始终为$\alpha$的叶结点，而最大深度发生在划分比例始终为$1 - \alpha$的叶结点。

令$n \times \alpha^{d_{min}} = 1$，解得$d_{min} = -\lg{n} / \lg{\alpha}$。

令$n \times (1 - \alpha)^{d_{max}} = 1$，解得$d_{max} = -\lg{n} / \lg{(1 - \alpha)}$。

#### 7.2-6
Argue that for any constant $0 < a \leq 1/2$ the probability is approximately $1 - 2\alpha$ that on a random input array, PARTITION produces a split more balanced than $1 - \alpha$ to $\alpha$.

---

不妨假设这个随机数组包含的元素为$1, 2, \cdots, n$。显然，对于一个随机输入数组，产生的划分的平衡程度仅取决于主元的大小，而主元取的是数组最右端的元素，因此选择每个元素作为主元的概率都是$1/n$。

如果选择$1 < i < n$作为主元，则我们得到的划分大约为$(i - 1) : (n - i)$。由于$\alpha \leq 1/2$，因此该划分比$1 - \alpha : \alpha$更平衡的情况只需满足$\max{(\frac{i - 1}{n - i}, \frac{n - i}{i - 1})} < \frac{1 - \alpha}{\alpha}$。

然后大概解出一个i的范围之类的……

### 7.3
#### 7.3-1
Why do we analyze the expected running time of a randomized algorithm and not its worst-case running time?

---

因为算法是随机的，就没有最坏运行时间这一说，只能分析平均情况了。

#### 7.3-2
When RANDOMIZED-QUICKSORT runs, how many calls are made to the randomnumber generator RANDOM in the worst case? How about in the best case? Give your answer in terms of $\Theta$-notation.

### 7.4
#### 7.4-1
Show that in the recurrence
$$T(n) = \max_{0\leq q \leq n-1}{(T(q) + T(n - q - 1))} + \Theta(n)$$

$T(n) = \Omega(n^2)$.

---

……虽然我感觉可以直接用数学归纳法证明$T(n) = \Theta(n^2)$，但是这好像不太符合要求……

#### 7.4-2
Show that quicksort’s best-case running time is $\Omega(n \lg{n})$.


#### 7.4-3
Show that the expression $q^2 + (n - q - 1)^2$ achieves a maximum over $q = 0, 1, \cdots, n-1$ when $q = 0$ or $q = n - 1$.

---

令$f(q) = q^2 + (n - q - 1)^2$，则$f'(q) = 2q - 2(n-q-1) = 4q - 2n + 2$，$f''(q) = 4$。由于二阶导数恒为正，因此区间内没有极值点，最值点位于区间端点上，即$q = 0$或$q = n - 1$。

#### 7.4-4
Show that RANDOMIZED-QUICKSORT’s expected running time is $\Omega(n \lg{n})$.

#### 7.4-5
We can improve the running time of quicksort in practice by taking advantage of the fast running time of insertion sort when its input is “nearly” sorted. Upon calling quicksort on a subarray with fewer than k elements, let it simply return without sorting the subarray. After the top-level call to quicksort returns, run insertion sort on the entire array to finish the sorting process. Argue that this sorting algorithm runs in $O(nk + n \lg{(n/k)})$ expected time. How should we pick k, both in theory and in practice?

----

此时运行时间的递归式变为如下形式：
……懒得排版了

总之大概用主方法代换一下吧

#### 7.4-6

Consider modifying the PARTITION procedure by randomly picking three elements from array A and partitioning about their median (the middle value of the three elements). Approximate the probability of getting at worst an $\alpha$-to-$(1-\alpha)$ split, as a function of $\alpha$ in the range $0 < \alpha < 1$.

## Problems
### 7.1 Hoare partition correctness
