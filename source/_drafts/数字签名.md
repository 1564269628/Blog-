---
title: 数字签名
urlname: digital-signature
toc: true
mathjax: true
date: 2018-06-07 16:50:40
tags: Cryptography
---

## 数字签名简介

### 数字签名方案的定义

下列定义来自《密码学原理与实践》7.1节：

---

一个签名方案是一个满足下列条件的五元组$(\mathcal{P}, \mathcal{A}, \mathcal{K}, \mathcal{S}, \mathcal{V})$：

1. $\mathcal{P}$是由所有可能的消息组成的一个有限集合。
2. $\mathcal{A}$是由所有可能的签名组成的一个有限集合。
3. $\mathcal{K}$为密钥空间，它是由所有可能的密钥组成的一个有限集合。
4. 对每一个$K \in \mathcal{K}$，有一个签名算法$sig_K \in \mathcal{S}$和一个相应的验证算法$ver_K \in \mathcal{V}$。对每一个消息$x \in \mathcal{P}$和每一个签名$y \in \mathcal{A}$，每一个$sig_K: \mathcal{P} \to \mathcal{A}$和$ver_K: \mathcal{P} \times \mathcal{A} \to \{true, false\}$都是满足下列条件的函数：当$y = sig(x)$时，$ver(x, y) = true$；当$y \neq sig(x)$时，$ver(x, y) = false$。由$x \in \mathcal{P}$和$y \in \mathcal{A}$组成的数据对$(x, y)$称为签名消息。

---

这个定义本身可以说是比较清晰的。为了使得签名方案是实际可用的，对于每一个可能的密钥$K$，要求$sig_K$和$ver_K$是多项式时间函数。同时，在给定一个消息$x$时，要求签名者之外的人计算出使得$ver(x, y) = true$的签名$y$在计算上是不可行的。

如果攻击者能够计算出使得$ver(x, y) = true$的数据对$(x, y)$，而$x$事先没有被签名，则签名$y$称为伪造签名。

## RSA签名方案

用RSA密码体制进行数字签名的方法和用RSA进行加密的方法是基本类似的。下面给出RSA签名方案的定义：

---

设$n = pq$，其中$p$和$q$是素数。设$\mathcal{P} = \mathcal{A} = \mathbb{Z}_n$，并定义

$$ \mathcal{K} = \{ (n, p, q, a, b): n=pq, p \text{和} q \text{为素数}, ab \equiv 1 (\bmod \phi(n)) \} $$

值$n$和$b$为公钥，值$p, q, a$为私钥。对$K = (n, p, q, a, b)$定义：

$$sig_K(x) = x^a \bmod n$$

以及

$$ver_K(x, y) = true \iff x \equiv y^b (\bmod n)$$

其中$x, y \in \mathbb{Z}_n$。

---

由于RSA加密方案和RSA签名方案完全类似，因此不再举出更多的例子了。

## ElGamal签名方案

ElGamal签名方案的定义如下：

---

设$p$是一个使得在$\mathbb{Z}_n$上的离散对数问题是难处理的素数，设$\alpha \in \mathbb{Z}_p^{* }$是一个本原元。设$\mathcal{P} = \mathbb{Z}_p^{* }$，$\mathcal{A} = \mathbb{Z}_p^{* } \times \mathbb{Z}_{p-1}^{* }$，定义：

$$\mathcal{K} = \{ (p, \alpha, a, \beta) \}$$

---

ElGamal签名方案是一种

## DSA签名方案

## 对签名方案的攻击

对签名方案的攻击模型一般可以分为以下3类：
* 唯密钥攻击（key-only attack）：攻击者拥有公钥，即验证函数$ver_K$
* 已知消息攻击（known message attack）：攻击者拥有一系列以前签名的消息，如$(x_1, y_1), (x_2, y_2), ...$
* 选择消息攻击（chosen message attack）：攻击者选择消息$x_1, x_2, ...$, 并可以得到对这些消息的签名$y_1, y_2, ...$

攻击者的目的可以分为以下3种：
* 完全破译（total break）：攻击者能够确定签名者的私钥，即签名函数$sig_K$，这样就可以对任何消息产生有效的签名
* 选择性伪造（selective forgery）：攻击者可以用某一不可忽略的概率对另外某个人选择的消息产生一个有效的签名。如果给攻击者一个消息$x$，那么他能（以某种概率）决定签名$y$，使得$ver_K(x, y) = true$
* 存在性伪造（existential forgery）：攻击者至少能为一则消息$x$产生一个有效的签名

一般来说，我们在评价一种攻击的时候，可以说成是“利用X攻击模型进行目的为Y的攻击”。

### 数字签名与Hash函数

### 对RSA签名方案的攻击

似乎以下攻击都可以在加入Hash函数时得到保护，所以就不再赘述了。

#### 基于唯密钥攻击的存在性伪造

显然，选择任意的$y$，然后根据公钥$(n, b)$计算出$x = y^b \bmod n$，就可以得到一对能够通过验证的$(x, y)$。这种做法不能自由选择$x$，因此是一种存在性伪造；因为只需要公钥就可以进行攻击，因此是一种唯密钥攻击。

#### 基于已知消息攻击的存在性伪造

假如攻击者已知两对消息和签名$(x_1, y_1), (x_2, y_2)$，则可以基于RSA的乘法特性进行攻击。令$x = x_1 x_2 \bmod n$，$y = y_1 y_2 \bmod n$，则

$$y^b \equiv (y_1 y_2)^b \equiv (x_1 x_2) ^ {ab} \equiv x^{ab} (\bmod n)$$

由（此处应有RSA密码体制中对这个结论的证明……），有$x^{ab} \equiv x (\bmod n)$，因此有$y^b \equiv x (\bmod n)$，可以通过验证。

#### 基于选择消息攻击的选择性伪造

假如需要伪造消息$x$的签名，则可以设法找到$x_1, x_2$使得$x \equiv x_1 x_2 (\bmod n)$。（我觉得只要随意选择模$n$下可以计算出乘法逆元的$0 < x_1 < n$，然后令$x_2 \equiv x x_1^{-1} (\bmod n)$即可。）得到$x_1, x_2$对应的签名$y_1, y_2$后，就可以仿照上文中“基于已知消息攻击的存在性伪造”中的方法，计算出$y = y_1 y_2 \bmod n$。

### 对ElGamal签名方案的攻击

#### 基于唯密钥攻击的存在性伪造

#### 基于已知消息攻击的存在性伪造

#### 与$k$值相关的攻击
