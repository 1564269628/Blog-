---
title: 'OSTEP第06章总结：Mechanism: Limited Direct Execution'
urlname: ostep-ch-06-summary-mechanism-limited-direct-execution
toc: true
date: 2018-08-04 19:51:55
updated: 2018-08-04 19:51:55
tags: [OSTEP, OS]
---

本章课本见[http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-mechanisms.pdf](http://pages.cs.wisc.edu/~remzi/OSTEP/cpu-mechanisms.pdf)。

---

为了通过分时共享实现CPU的虚拟化，我们需要面临以下两个主要挑战：

* 性能：分时共享的操作不应增加太多开销
* 控制：OS仍然需要对CPU具有控制能力

我们需要在保证OS对CPU的控制权的前提下高性能地实现虚拟化，为此，我们采用了一种叫做**“受限直接执行”** （limited direct execution）的技术。

>这种技术的名字未见于其他文献，大概是作者自己为这些技术的总和起出来的一个描述性的名称。不过我觉得概括得不错。

## 直接执行

“受限直接执行”中的“直接执行”部分很容易理解：就是直接在CPU上运行程序。当OS想要启动程序的时候，它就在进程描述链表中创建一个新的进程项，为它分配一些内存，从磁盘中将程序代码读入到内存中，找到入口点（如`main()`函数入口），跳转到这个入口点，然后开始运行用户代码。下图说明了这一过程：OS使用普通的`call`和`return`指令来跳转到`main()`，然后执行用户代码；用户代码退出后，跳转回OS，进行后续处理。

![直接执行协议](figure-6-1-direct-execution.png)

>作者把这种约定的方法称作一种“协议”，这让我很惊讶，但又觉得这很有道理。

单纯的直接执行肯定会出一些问题，包括但不限于：

1. 如何监控程序行为的合法性？
2. 如何实现分时共享，在必要的时候暂停当前进程，并切换到其他进程？

## 对“直接执行”的限制

### 限制进程行为：用户态和内核态，系统调用

显然我们需要对进程的行为进行一些控制。我们采用的方法（这个应该是一种common wisdom吧）是引入两种处理器模式（特权级）：**内核态**（kernel mode）和**用户态**（user mode）。

* 用户态：用户进程运行在这一模式。在此模式下运行的代码受到一些限制，比如不能进行I/O请求等特权操作；如果尝试进行特权操作，那么OS会杀死进程。
* 内核态：OS（内核）运行在这一模式。在此模式下，代码可以执行任何特权指令和受限指令。

让用户进程运行在用户态下，就可以实现对用户代码行为的限制了。但是很显然，用户代码有时候仍然需要执行一些特权操作，所以我们引入了**系统调用**（system call）（又是一种common wisdom），OS通过系统调用将一些核心功能（包括访问文件系统、创建和销毁进程、进程通信、分配内存等）谨慎地暴露给用户。

下面我们会讲一下系统调用的过程。对用户进程而言，执行系统调用和进行程序调用是很相像的，因为OS为用户进程提供的系统调用API就是一个程序调用，只是里面藏了一条`trap`指令。`trap`指令是系统调用的关键指令。执行这条指令后，会同时跳转到内核的相应代码段，并将特权级提升到内核态。`trap`指令的实现需要依赖硬件：在执行这条指令的时候，硬件将保存调用者的寄存器，这样返回时才能正常恢复这些寄存器。例如，在x86上，处理器会把PC、flags和一些其他的寄存器存储到用户进程的内核栈（kernel stack）上。然后OS就开始执行所需的操作。执行完之后，OS会执行一条特殊的`return-from-trap`指令，在跳转回用户代码的同时降低特权级（这一点与`trap`指令是对应的，而且也需要依赖硬件，恢复对应的寄存器）。

系统调用还有另一个需要注意的细节，也就是，`trap`指令如何知道要运行的是OS内部的哪些代码？显然不能允许进行系统调用的用户进程直接指定一个地址，这样进程就可以跳转到内核中的任何位置了。我们采取的方法（还是common wisdom）是在机器启动时设置**陷阱表**（trap table）：机器刚启动时处于内核态，且OS拥有控制权，此时OS会通过一些特殊指令把各种异常事件（比如硬盘中断、键盘中断和磁盘中断）的**陷阱处理程序**（trap handler）的位置告知硬件，硬件把这些地址记录下来，并且在发生系统调用和其他异常事件时跳转到对应的位置。

>我感觉在x86系统中，系统调用和异常的区别和联系很模糊，这是令我经常感觉很头大的。事实上，上面讲到的`trap`处理过程和陷阱表的设置都是和更为“通用”的异常处理相关的，而系统中断只不过是异常的一种而已——这也是需要引入系统中断编号的原因，系统中断编号不是异常编号，而是某个异常编号下面更加细分的种类。

用户进程执行系统调用时，为了明确是哪种系统调用，需要把系统调用对应的具体**系统调用号**（system-call number）存放在寄存器中或者栈上的某一位置；OS在陷阱处理程序中会检查这个编号的合法性，并执行对应的代码。这种间接处理是一种保护（protection）：用户代码必须通过编号来请求某一特定服务。

我们仍然用协议的形式来描述受限直接执行的流程：

![受限直接执行协议](figure-6-2-limited-direct-execution-protocol.png)

上图中有两个主要阶段（所有特权指令都加粗了）：

1. 启动阶段：OS通过特权指令初始化陷阱表
2. 运行用户进程阶段：
  * 初始化：OS在进程链表中分配结点，为新进程分配内存
  * 执行：通过`return-from-trap`指令跳转到用户代码
  * 执行系统调用：用户进程需要执行系统调用，通过`trap`指令跳转回OS
  * 陷阱处理程序：OS对系统调用进行处理，通过`return-from-trap`指令跳转回用户代码
  * 继续执行和退出：用户代码继续执行，直到结束，执行`exit()`系统调用跳转回OS
  * 结束：OS清理进程所用的资源

>说实话，我一直觉得和系统调用相关的东西很难理解，因为它们和具体的硬件实现联系太紧密了……x86里的左一个描述符、右一个描述符表真是令人头大……作者这里的抽象化做得不错，但是如果读完之后立即去做相应的实验，仍然会做不出来，并且埋怨课本和实践联系太松散的。

### 限制进程控制权：时钟中断，上下文切换

我们现在面临着一个哲学问题：进程在CPU上运行，就意味着OS没有运行。如果OS没有运行，那它怎么才能做一些事情呢？（提示：它确实什么也做不了）所以我们需要一些让OS重新开始运行的方法。

#### 合作方法：等待进程进行系统调用

一些系统曾经采取过的方法（比如早期版本的Macintosh系统和旧的Xerox Alto系统）被称为**合作**（cooperative）方法。此时，OS信任用户进程的行为是合理的。运行了太久的进程会定期放弃CPU的控制权，这样OS就可以决定运行一些其他进程了。

此类系统通常会有一个明确的叫做**放弃**（yield）的系统调用，它的作用是把控制权交给OS。当用户进程执行非法行为的时候，控制权也会转交给OS。

因此，在一个**合作调度系统**（cooperative scheduling system）中，OS通过等待系统调用或者进程的非法行为重新获得控制权。但是这种被动的方法可能并不理想。即使进程没有恶意，它也可能会不小心进入无限循环，从不执行系统调用，那OS怎么办？（此时，只好使用重启大法了。）

#### 非合作方法：时钟中断

如果没有硬件提供的额外支持，我们只能重启机器了。不过，硬件为我们提供了一种特性，**时钟中断**（timer interrupt）。时钟设备可以被配置为每若干毫秒就发生一次中断；当中断发生时，当前运行中的进程被暂停，OS中事先配置好的**中断处理程序**（interrupt handler）开始执行。此时OS就获得了控制权，可以暂停当前进程的运行，并且开始一个新的进程。

需要注意的是：
1. OS必须在启动时告知硬件时钟中断处理程序的位置（这一点和异常处理是相同的）
2. 在启动时，OS也需要启动定时器（或者说开启时钟中断），这也是一项特权操作

在时钟启动之后，OS就可以随时重新获得控制权，可以自由运行用户程序了。定时器也可以通过特权操作关闭，在讲到并发的时候我们会谈到这种操作。

在发生中断时，硬件有保存正在运行的程序状态的义务，这样，中断返回时，`return-from-trap`指令就可以正确恢复进程的运行。这套操作和进程主动执行系统调用而跳转到内核中的操作是类似的，需要保存若干寄存器（到内核栈中之类的）。

#### 上下文切换

（我现在突然搞不清楚异常时保存的上下文和进程切换时保存的上下文有何区别了。）
