---
title: Intel80X86架构：保护模式下的内存管理
toc: true
date: 2018-03-27 23:20:30
tags:
urlname: intel-80x86-architecture-mm-under-protected-mode
---

下面看看内存管理。内容来自Intel手册的第三卷的3-4章。

![](fig3-1_segmentation_and_paging.png)

内存管理大体可以分为两大部分：分段和分页。在保护模式下分段必须开启。分段功能可以将处理器的可寻址空间（**线性地址空间**；这个空间的大小是怎么来的呢？）分成受保护的小的连续块。

地址分为3种：
* 逻辑地址：由段选择子和偏移量组成；通过段选择子在GDT中读出描述符，进行检查后，段基址（线性地址）+offset=转换得到的线性地址
* 线性地址：未开启分页时等于物理地址；开启分页时，一般分成4K大小的页，通过页表进行寻址、换入等
* 物理地址：没啥好说的了

## 段的使用方法
### 基本扁平模型

![](fig3-2_flat_model.png)

应用程序访问的是完整的一块连续的、未分段的地址空间。至少需要两个段描述符，一个指向代码段，一个指向数据段；这两个段都映射到整个线性地址空间，也就是说，基址都是0，大小都是4GB。（然而，此时我的问题是，GDT之类的东西还存在内存中吗？那么就可以直接访问GDT表之类的？）

此时即使线性地址超出可寻址的范围也不会报错。ROM一般处于物理内存空间的大端，因为处理器从FFFF_FFF0H位置开始执行；RAM一般位于物理地址空间的小端，因为上电后，DS数据寄存器中的基址初始化为0。

### 带保护的扁平模型

![](fig3-3_protected_flat_model.png)

和基本扁平模型类似，但是段描述符中的段范围局限在物理内存实际存在的位置，如果访问不存在的存储位置，会发生GP（通用保护异常）。

（但是我并不知道，这个图中，code为什么处于顶端。）

可以定义4个段：特权级为3的用户代码段和数据段，以及特权级为0的系统代码段和数据段。这些段全都相互覆盖，在线性地址空间中基址为0。加上一个简单的页表，就可以将操作系统与用户进程隔离开（为什么？）；为每个进程创建一个页表，则可以将用户进程互相隔离（怎么隔离？到底有几个段？它们在物理空间中是否是相互重叠的？如果不是，那么如何进行映射？）

### 多段模型

![](fig3-4_multi_segment_model.png)

每个程序（或任务）拥有自己的段描述符表（是LDT吗？切换任务的时候，同时切换CS等寄存器，CS寄存器中的内容是段选择子，指向对应的描述符？）和段，段可以是共享或私有的。总之可以进行很多访问保护了。

### 分段与分页

分页机制可以把线性地址空间分成页；这些线性地址空间页随后映射到物理地址空间中。可以进行页级保护。

## 物理地址空间
保护模式下，物理地址空间大小为4GB。这个地址空间是扁平的，地址从0到FFFFFFFFH。这个空间可以映射成普通内存，只读内存和I/O。

## 逻辑和线性地址
保护模式下处理器需要进行两次地址翻译才能得到物理地址：逻辑地址翻译和线性地址空间分页。

因为必须分段，因此处理器能够访问的每一个地址都是逻辑地址。逻辑地址由16位的段选择子和32位的偏移量组成。

翻译出来的线性地址是处理器的线性地址空间中的32位地址。这个线性地址空间包含了系统中的全部段和系统段。（我的问题是，用户进程切换时如何做到它们对应的线性地址空间不同？还是根本就是相同的，但是开启了分页，页表不同？）

![](fig3-5_logical_addr_to_linear_addr.png)

把逻辑地址翻译到线性地址的过程：
* 通过段选择子中的信息确定使用的是GDT还是LDT，通过偏移量读出段描述符（事实上是缓存了段描述符，因此只当段选择子更新的时候需要这么做，否则直接读缓存的段描述符即可）
* 检查段描述符的访问权限和段的长度，确定可以访问这个段，地址没有越界
* 段基址+偏移量=线性地址

### 段选择子

![](fig3-6_segment_selector.png)

段选择子是段的16位标识符，它不直接指向段，而是指向段对应的段描述符。其中的内容包括：
* 索引值（15-3）：选择GDT或LDT中的8192个描述符之一（因为2^13=8192，所以最多能够区分8192个描述符；但是GDT或LDT中应该不一定会有这么多）。处理器将这一索引值*8（因为一个段描述符的大小是8字节），与GDTR或LDTR中的线性基址相加，得到段描述符地址。
* TI（2）：如果TI为0，则使用GDT；如果为1，则使用当前LDT（LDT也是一个段，它的描述符存在于GDT中，线性基址存在LDTR中，使用方法与GDTR类似）
* 请求特权级（Requested Privilege Level，RPL）（1-0）：段选择子的特权级。详见第五章的保护部分。（总之很复杂）

GDT的第一个表项是处理器不使用的，指向这个表项的段选择子就变成了一个“空段选择子”。这样的选择子可以用来初始化段寄存器。

应用程序可以访问段选择子（段寄存器的显式内容），但通常不会修改段选择子。

### 段寄存器
段寄存器的作用是降低地址翻译的时间和编码效率。（假设我们把段选择子也存在内存中。则完成一次地址翻译需要2次访存：加载段选择子->根据GDTR寄存器和索引加载段描述符->计算出线性地址）对于任何程序，CS（代码段）、DS（数据段）和SS（堆栈段）的寄存器中必须包含合法的段选择子。还有三个备用的数据段寄存器（ES、FS和GS），可以用于访问额外的数据段。

如果程序想要访问一个段，段的选择子必须保存在某个段寄存器中。如果想要访问别的段，必须先把段选择子加载到段寄存器中。

每个段寄存器分为两个部分：
* 可见部分：存储着段选择子
* 不可见部分（又称为“描述符缓存”或“影子寄存器”）：可见部分中的段选择子改变时，会自动把段选择子对应的段描述符缓存到这一位置

这一设计可以减少地址翻译的时间。

用于加载段寄存器的指令可以分为两类：
* 直接加载指令，包括MOV（？）、POP（？）、LDS、LES、LGS和LFS
* 间接加载指令，包括长跳转的CALL、JMP和RET指令，SYSENTER和SYSEXIT指令，以及IRET，INTn，INTO和INT3指令
MOV指令也可以用于把一个段寄存器的可见部分存储到通用寄存器中。

### 段描述符

![](fig3-8_segment_descriptor.png)

段描述符是GDT或LDT中的表项的数据结构，包含段的大小、地址、访问权限和状态信息。段描述符通常由编译器、链接器、加载器、OS或应用程序创建，应用程序不会直接创建。一个段描述符的大小为8字节，其中包含了非常丰富的信息。

段描述符中的重要信息包括：
* 段长度：段描述符中共有20位用于描述段大小的值，根据G（颗粒度）位有所不同：如果G位清零，则段的大小为1字节到1MB字节；如果G位置位，则段的大小为4KB字节到4GB字节
  * 段也分成两类：向上增长（expand-up）和向下增长（expand-down）。向上增长的段就是普通的段，偏移量只能处于0到段的大小之间；向下增长的段的偏移量需要处于偏移量+1到FFFFFFFFH（或FFFFH）之间。将这样的段的大小减小相当于在段的地址空间的小端分配新内存，这对于栈是很方便的。
* 基地址：在4GB的线性地址空间的范围内的段的基址，长度为32位。
* 类型：说明段（或门）的类型，访问方式和增长方向。对于CS、DS和系统段，这一信息的编码方式都设计不同的。
* S（描述符类型）位：S清零表示是系统段，S置位是数据段
* DPL（描述符特权级）：段的特权级，用于控制对段的访问
* P（段是否存在）位：段在内存中（置位）还是被换出了（清零）。当P清零时，除了P、DPL、S和Type部分，其他内容都可以用于存储被换出的段的信息
* D/B位：
  * 32位代码段：必须置为1
  * 16位数据和代码段：必须置为0
  * 可执行代码段：称为D位，置位表示使用32位地址，清零表示使用16位地址
  * 堆栈段（SS寄存器指向的数据段）：称为B位，如果置位则使用32位的ESP栈指针；如果清零则使用16位的SP栈指针
  * 向下扩展数据段：称为B位，如果置位则上界为FFFFFFFFH；清零则上界为FFFFH
* G（颗粒度）位：段的大小的单位是1字节还是4K字节（但基地址仍然是字节）。置位时，不检查偏移量的低12位。

### 代码段和数据段描述符

> 妈的，看了这么多具体内容我都要疯了。如果要把这些转换成可看可理解的东西，就不能从纯描述角度来叙事，而需要从用途角度来分析。比如，基地址和段的长度都是很显然需要的；其他的设置是便于兼容和编程的；诸如此类。或者关于这些内容的描述应该放到架构概述里面？但是又感觉不太合适，讲得太详细了。至少在概述里应该更详细地描述一下数据结构的具体信息，当然细节可以省略。

一些具体细节：如何通过S位和Type域确定描述符的类型、访问权限和增长方式。

一些名词：
