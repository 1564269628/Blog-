---
title: Keccak算法的原理与实现
urlname: keccak-algorithm-principle-and-implementation
toc: true
date: 2018-05-29 15:40:56
mathjax: true
tags: [密码学]
---

总之这是密码学的第二次大作业的内容之一。看起来Keccak算法更简单，所以先看Keccak。

Keccak算法是有个[官网](https://keccak.team/index.html)的，所以如果要实现的话，直接照着官网的要求去写就好了，里面有无数的相关论文。[这里](http://www.drdobbs.com/security/keccak-the-new-sha-3-encryption-standard/240154037)是一个关于Keccak的详细介绍。

## Keccak算法简介

[这个的介绍](https://pdfs.semanticscholar.org/8450/06456ff132a406444fa85aa7b5636266a8d0.pdf)还不错。

Keccak算法内部分为两个阶段：
* 吸收（输入）阶段：消息块输入到算法中并进行处理
* 挤压（输出）阶段：输出一定长度的摘要

![](high-level-keccak.png)

这两个阶段使用了同一个置换函数：KECCAK-f。

Keccak算法有几个可以调整的参数：
* b：中间状态的大小（宽度），b=r+c。算法要求$b = 25 \cdot 2^l, l=0, 1, ..., 6$，即$b \in {25, 50, 100, 200, 400, 800, 1600}$
* r：与单个消息块的长度相等，称为比特率
* c：容量

下图说明了Keccak算法内部的工作过程：
* 处理中间阶段中，每个串的长度为b
* 吸收阶段
  * 串的低（大概？）r位与第i个输入消息块异或
  * 将串通过f函数进行置换
* 挤压阶段
  * 输出串的低r位
  * 将串通过f函数进行置换

![](keccak-absorb-squeeze.png)

对于SHA-3模式，要求b=1600，此时有r=1344，c=256或r=1088，c=512。

显然，Keccak算法的重点在于f函数的实现。

### 输入和输出

Keccak使用的是一种称为P10*1的填充方法：
* 在消息的最后填充1、若干个0和1，使得消息长度为块长度的整数倍
* 最少填充2 bit，最多填充块长度+1 bit

在SHA-3模式下，显然输出的r是1344或1088位。在这种情况下，只需保留低位作为输出，丢弃多余的位就可以了。

### Keccak-f函数（置换）

每个输入的b位二进制数都会被映射到一个b位的二进制数，且是一一映射。

这个函数会循环$n_r$次。每一轮的输入都有b=r+c位。轮数取决于参数l：$n_r = 12 + 2l$，也就相当于是l与b相关。

| 内部状态bit数$b$ | 循环次数$n_r$ |
| ----- | ----- |
| 25 | 12 |
| 50 | 14 |
| 100 | 16 |
| 200 | 18 |
| 400 | 20 |
| 800 | 22 |
| 1600 | 24 |

对于SHA-3模式，$n_r = 24$。

在每一轮的操作中，除了常数`RC[i]`不同以外，其他部分都是相同的。

![](keccak-f-internal-structure.png)

从上图可以看出，每一轮中都包含如下五步：$\theta, \rho, \pi, \chi, \iota$。每一步都会改变整个状态。状态可以看做是一个5*5*w的数组（立方体），其中$w = 2^l$（对于SHA-3模式，w=64）。

![](keccak-cube-array.png)

对于给定的(x, y)坐标，称对应的一片为lane。执行对应的5步时，必须先执行$\theta$，剩余的四步的顺序随意。

#### Theta步

在这一步中，可以简单地把状态数组看做是一个5*5的数组，数组中的每一个元素是宽度为w的二进制字。如果将这一数组记作A(x, y)，则算法会执行以下步骤：

$$C[x] = A[x, 0] \oplus A[x, 1] \oplus A[x, 2] \oplus A[x, 3] \oplus A[x, 4], x = 0, 1, 2, 3, 4$$

$$D[x] = C[x-1] \oplus rot(C[x+1], 1), x = 0, 1, 2, 3, 4$$

$$A[x, y] = A[x, y] \oplus D[x], x = 0, 1, 2, 3, 4$$

其中`C[x]`和`D[x]`都是长度为5的数组，其中的元素是宽度为w的二进制字。`rot`函数表示循环左移。

大概可以这么说：每一位都被代替成了它邻近的10位和自己的异或和。

![](keccak-f-step-theta.png)

#### Rho和Pi步

这两个步骤基于状态数组A计算出一个附加的5*5数组B，B的元素是宽度为w的二进制字。可以用下面的伪代码表示这两步的过程：

$$B[y, 2x+3y] = rot(A[x, y], r[x, y]), x,y=0,1,2,3,4$$

其中`r[x, y]`的值来自一个常数表，称为旋转常数（rotation constants）。

事实上，这两步主要做的是这一件事情：把状态数组A的25个二进制字拿出来，分别循环左移一定距离（这是$\rho$，或者说**r**otation做的），并放置在附加数组B的新位置（这是$\pi$，或者说**p**ermutation做的）。

下表是不同坐标对应的旋转常数（虽然不是很懂为什么是这样的排列顺序？）：

|     | x=3 | x=4 | x=0 | x=1 | x=2 |
| --- | --- | --- | --- | --- | --- |
| y=2 | 25 | 39 | 3 | 10 | 43 |
| y=1 | 55 | 20 | 36 | 44 | 6 |
| y=0 | 28 | 27 | 0 | 1 | 62 |
| y=4 | 21 | 8 | 41 | 45 | 15 |

#### Chi步

这一步对上一步中得到的B数组进行处理，并把处理结果放回状态数组A中。这一步处理的主要对象是宽度为w的二进制字。操作的伪代码如下：

$$A[x, y] = B[x, y] \oplus ((\overline{B}[x+1, y]) \land B[x+2, y]), x,y=0, 1, 2, 3, 4$$

这一步的功能是很显然的。

![](keccak-f-step-chi.png)

#### Iota步

这一步是非常简单明了的。它在状态数组的`[0, 0]`位置加上一个预先定义好的常量（`RC[i]`）：

$$A[0, 0] = A[0, 0] \oplus RC[i]$$

i是当前的轮数。由于$n_r$最大为24，因此只需要24个这样的常数。常数表如下：

```
RC[ 0] = 0x0000000000000001
RC[ 1] = 0x0000000000008082
RC[ 2] = 0x800000000000808A
RC[ 3] = 0x8000000080008000
RC[ 4] = 0x000000000000808B
RC[ 5] = 0x0000000080000001
RC[ 6] = 0x8000000080008081
RC[ 7] = 0x8000000000008009
RC[ 8] = 0x000000000000008A
RC[ 9] = 0x0000000000000088
RC[10] = 0x0000000080008009
RC[11] = 0x000000008000000A
RC[12] = 0x000000008000808B
RC[13] = 0x800000000000008B
RC[14] = 0x8000000000008089
RC[15] = 0x8000000000008003
RC[16] = 0x8000000000008002
RC[17] = 0x8000000000000080
RC[18] = 0x000000000000800A
RC[19] = 0x800000008000000A
RC[20] = 0x8000000080008081
RC[21] = 0x8000000000008080
RC[22] = 0x0000000080000001
RC[23] = 0x8000000080008008
```

## 实现

但是实现这个算法还是有很多需要注意的细节的……

出现了很多有趣的问题。比如x和y的顺序。如何padding。等等。
