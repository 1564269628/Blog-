---
title: 《操作系统》第11讲：“进程和线程”总结
urlname: os-mooc-lecture-11-summary
toc: true
date: 2018-04-14 16:18:16
tags: [操作系统, 课程总结]
---

## 课程内容概述
这节课的内容主要是一些原理性的介绍。
* 进程
  * 进程简介
  * 进程状态模型
* 线程
  * 线程的概念
  * 线程的实现方式

TODO

### 进程
#### 进程简介
#### 进程状态模型
### 线程
#### 线程的概念
#### 线程的实现方式

## 练习
来自[lec11 进程与线程　在线练习](https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/05-1-quiz.md)和[lec11 进程／线程概念spoc练习](https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/05-1-spoc-discussion.md)。

### 选择填空题
**进程与程序的关系描述正确的是（）**
* **进程是指一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程**
* 进程是一个具有一定独立功能的程序
* 程序是一个动态执行的进程
* **进程包含了正在运行的一个程序的所有状态信息**

显然，进程的定义是一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。它除了包含程序本身（为了运行程序，这是必须的），还包含正在运行的一个程序的所有状态信息。

所以，进程不止是“一个具有一定独立功能的程序”，它还包含了状态信息。进程才是一个动态执行的程序，反了。

---

**关于进程控制块的描述正确的是（）**

* **操作系统用进程控制块来描述进程的基本情况以及运行变化的过程**
* **进程控制块是进程存在的唯一标志**
* **每个进程都在操作系统中有一个对应的进程控制块**
* **操作系统管理控制进程运行所用的信息集合是进程控制块**

都对。（这道题就没有什么出的意义了……）

---

**关于进程的生命周期的描述正确的是（）**

* **内核选择一个就绪态的进程，让它占用处理机并执行，此时进程处于运行态**
* **进程请求并等待系统服务，无法马上完成，此时进程处于等待态**
* **进程执行的当前时间片用完了，此时进程处于就绪态**
* **进程退出了，但还没被父进程回收，此时进程处于zombie态**

都对。当然，这时并没有讲到僵尸进程和孤儿进程的概念。总之，僵尸进程就是本身已经退出，但是资源还没有被父进程回收的进程。孤儿进程就是父进程已经退出，但是自己还没有退出的进程。在uCore中，孤儿进程会被回收作为initproc的子进程，因此并不会出现浪费资源的情况。（大概）

---

**操作系统来维护一组队列，表示系统中所有进程的当前状态，有关管理进程的描述正确的是（）**

* **就绪态进程维护在进程就绪队列中**
* **等待态进程维护在进程等待队列中**
* 运行态进程维护在进程运行队列中
* zombie态进程不在任何队列中

好的。就绪进程显然是需要一个队列的（然后通过调度算法选择下一个运行的进程）。[实验指导书](https://chyyuu.gitbooks.io/ucore_os_docs/content/lab7/lab7_3_1_experiment.html)中指出，ucore中设计了等待队列wait_queue。当进程无法进入临界区（即无法获得信号量）时，可让进程进入等待队列，这时的进程处于等待状态（也可称为阻塞状态），从而会让实验六中的调度器选择一个处于就绪状态（即RUNNABLE STATE）的进程，进行进程切换，让新进程有机会占用CPU执行，从而让整个系统的运行更加高效。而因为当前处于运行态的进程只能有一个，所以不需要队列。至于僵尸进程是否会在某个队列中……我又参考了[实验指导书](https://chyyuu.gitbooks.io/ucore_os_docs/content/lab5/lab5_3_3_process_exit_wait.html)，但是并没有发现关于这件事的说明。总之，uCore中似乎没有一个专门的僵尸状态进程队列，但是这些僵尸进程都是在父进程的子进程链表中的。

在Piazza上有一个问答（[（课堂提问）三状态进程模型与其队列](https://piazza.com/class/i5j09fnsl7k5x0?cid=742)），作者对此的回答见[这个链接](https://github.com/qq775193759/OS_ANSWER/blob/master/3_states.md)。但我觉得这是一个原理层面的讨论，而非uCore的实际实现状况。

以下代码来自`lab5/kern/process/proc.c`，是`SYS_EXIT`系统调用的实现，并没有发现有什么队列。
```
// do_exit - called by sys_exit
//   1. call exit_mmap & put_pgdir & mm_destroy to free the almost all memory space of process
//   2. set process' state as PROC_ZOMBIE, then call wakeup_proc(parent) to ask parent reclaim itself.
//   3. call scheduler to switch to other process
int
do_exit(int error_code) {
    if (current == idleproc) {
        panic("idleproc exit.\n");
    }
    if (current == initproc) {
        panic("initproc exit.\n");
    }

    struct mm_struct *mm = current->mm;
    if (mm != NULL) {
        lcr3(boot_cr3);
        if (mm_count_dec(mm) == 0) {
            exit_mmap(mm);
            put_pgdir(mm);
            mm_destroy(mm);
        }
        current->mm = NULL;
    }
    current->state = PROC_ZOMBIE;
    current->exit_code = error_code;

    bool intr_flag;
    struct proc_struct *proc;
    local_intr_save(intr_flag);
    {
        proc = current->parent;
        if (proc->wait_state == WT_CHILD) {
            wakeup_proc(proc);
        }
        while (current->cptr != NULL) {
            proc = current->cptr;
            current->cptr = proc->optr;

            proc->yptr = NULL;
            if ((proc->optr = initproc->cptr) != NULL) {
                initproc->cptr->yptr = proc;
            }
            proc->parent = initproc;
            initproc->cptr = proc;
            if (proc->state == PROC_ZOMBIE) {
                if (initproc->wait_state == WT_CHILD) {
                    wakeup_proc(initproc);
                }
            }
        }
    }
    local_intr_restore(intr_flag);

    schedule();
    panic("do_exit will not return!! %d.\n", current->pid);
}
```

---

**有关线程或进程的描述正确的是（）**

* **进程是资源分配单位，线程是CPU调度单位**
* **进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，如寄存器和栈**
* **线程能减少并发执行的时间和空间开销**
* **同一进程的各线程间共享内存和文件资源，可不通过内核进行直接通信**

总之，线程中独立的内容是栈、指令指针和寄存器现场。其余页表、打开文件等资源是共享的。

---

**常见的线程种类有（）**

* **用户线程**
* **内核线程**
* **轻量级进程**

Linux中提供的是轻权线程（参考[Linux 线程实现机制分析](https://www.ibm.com/developerworks/cn/linux/kernel/l-thread/)）。Windows提供的似乎是内核线程。至于哪些库提供的是用户线程，我发现我从未深入思考过这个问题……

---

**内核线程的描述正确的是()**

* **由内核维护内核线程的线程控制块**
* 由用户线程库维护内核线程的线程控制块
* 内核无法调度内核线程
* 内核线程间无法共享所属进程的资源

显然TCB此时是由内核维护和直接调度的。当然线程可以共享资源，要不然要线程有何用。

### 简答题
**什么是程序？什么是进程？**

程序：对实现预期目的一系列动作的执行过程的描述，由一系列操作指令的序列组成。

进程：具有一定独立功能的程序在一个数据集合上的一次动态执行过程。

我觉得可以说，进程=程序+状态（寄存器、指令指针、堆栈指针……）+资源（内存空间、打开的文件……）

---

**进程有哪些组成部分？**

程序、数据、执行状态（CPU状态、内存数据状态）

所以在这里内存被算成是一种数据了。好吧，可以，但是我觉得寻址方式（分段方式）并不能严格地算作是一种数据。

---

**请举例说明进程的独立性和制约性的含义。**

进程的独立性是指进程是资源分配和调度的基本单位。

进程的制约性是因为他们有共享资源或通信。

我怎么都没有听说过这两个词。不过还是有一点道理的。

---

**程序和进程联系和区别是什么？**

联系：程序是进程的组成部分之一；同一个程序可对应多个不同进程；

区别：进程是动态的过程，程序是静态的代码序列；进程是暂时的，程序是永久的。

（当然，程序也不是永久的，删了就没了）

---

**进程控制块的功能是什么？**

管理和控制进程运行。

---

**进程控制块中包括什么信息？**

* 进程基本信息：进程标识
* 运行状态：处理机现场
* 进程控制信息：调度、通信、资源占用
  * PC（代码）
  * SP（栈顶）
  * 其他寄存器
  * PID：进程标识信息
  * UID：进程所有者的ID
  * 调度优先级
  * 打开文件列表

**ucore的进程控制块数据结构定义中有哪些字段？有什么作用？**

参见：`lab4/kern/process/proc.h`：
```
struct proc_struct {
    enum proc_state state;                      // Process state
    int pid;                                    // Process ID
    int runs;                                   // the running times of process
    uintptr_t kstack;                           // Process kernel stack
    volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?
    struct proc_struct *parent;                 // the parent process
    struct mm_struct *mm;                       // Process's memory management field
    struct context context;                     // Switch here to run process
    struct trapframe *tf;                       // Trap frame for current interrupt
    uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)
    uint32_t flags;                             // Process flag
    char name[PROC_NAME_LEN + 1];               // Process name
    list_entry_t list_link;                     // Process link list
    list_entry_t hash_link;                     // Process hash list
};
```

到Lab8中，就多了一些东西（`lab8/kern/process/proc.h`）：
```
struct proc_struct {
    enum proc_state state;                      // Process state
    int pid;                                    // Process ID
    int runs;                                   // the running times of Proces
    uintptr_t kstack;                           // Process kernel stack
    volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?
    struct proc_struct *parent;                 // the parent process
    struct mm_struct *mm;                       // Process's memory management field
    struct context context;                     // Switch here to run process
    struct trapframe *tf;                       // Trap frame for current interrupt
    uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)
    uint32_t flags;                             // Process flag
    char name[PROC_NAME_LEN + 1];               // Process name
    list_entry_t list_link;                     // Process link list
    list_entry_t hash_link;                     // Process hash list
    int exit_code;                              // exit code (be sent to parent proc)
    uint32_t wait_state;                        // waiting state
    struct proc_struct *cptr, *yptr, *optr;     // relations between processes
    struct run_queue *rq;                       // running queue contains Process
    list_entry_t run_link;                      // the entry linked in run queue
    int time_slice;                             // time slice for occupying the CPU
    skew_heap_entry_t lab6_run_pool;            // FOR LAB6 ONLY: the entry in the run pool
    uint32_t lab6_stride;                       // FOR LAB6 ONLY: the current stride of the process
    uint32_t lab6_priority;                     // FOR LAB6 ONLY: the priority of process, set by lab6_set_priority(uint32_t)
    struct files_struct *filesp;                // the file related info(pwd, files_count, files_array, fs_semaphore) of process
};
```

---

**进程生命周期中的相关事件有些什么？它们对应的进程状态变化是什么？**

进程生命周期：创建、执行、等待、抢占、唤醒、结束

进程状态：创建、就绪、运行、等待、退出

进程状态变迁事件：抢占、唤醒、结束等

这个时候就需要这张图：
![进程状态变化](proc_state.jpg)

---

**运行、就绪和等待三种状态的含义？7个状态转换事件的触发条件是什么？**

* 运行：占用CPU执行指令
* 就绪：已获取所有其他资源，等待CPU资源
* 等待：等待某事件发生，处于暂停状态

转换事件：
* 启动（NULL->创建）
* 进入就绪队列（创建->就绪）
* 被调度（就绪->运行）
* 等待事件（运行->等待）
* 时间片用完（运行->就绪）
* 事件发生（等待->就绪）
* 结束（运行->退出）

---

**引入挂起状态的目的是什么？**

为减少进程占用内存而把进程控制信息映像到外存中。挂起只在虚存不发达的时候比较有用，现在已经是时代的眼泪了。

---

**引入挂起状态后，状态转换事件和触发条件有什么变化？**

就绪被分成了就绪挂起和就绪两个状态，等待被分成了等待挂起和等待两个状态。

多了两个变迁事件：激活（等待挂起->等待，或就绪挂起->就绪）和挂起（等待->等待挂起，或就绪->就绪挂起）。

---

**内存中的什么内容放到外存中，就算是挂起状态？**

进程内核栈被放到外存（ucore中没有挂起状态）

这题超纲了.jpg

总之，在有虚存管理的系统中，连进程内核栈都要放到外存中，大概系统都快炸了。

---

**引入线程的目的是什么？**

在同一地址空间内实现并发的函数执行。方便通信和共享数据，降低新建线程的开销。

---

**什么是线程？**

线程是进程中描述指令流执行状态的组成部分，是CPU调度的基本单位。

---

**进程与线程的联系和区别是什么？**

进程是资源分配单位：进程地址空间、进程占用资源

线程是CPU调度单位：CPU寄存器信息、堆栈信息、指令执行信息

进程内的多个线程共享相同的地址空间

进程只管理处理机，线程管理各自的寄存器和堆栈

结论：线程=进程-共享资源

---

**什么是用户线程？**

用户线程是以用户函数库形式提供的线程实现机制。由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。操作系统内核中仍然只有PCB来进行处理机调度，不感知应用态的多线程。用户态的线程模块为线程构建各自的控制模块，完成多个线程的交替执行和同步。

---

**用户线程的线程控制块保存在用户地址空间还是在内核地址空间？**

用户地址空间。这大概是显然的。

---

**用户线程与内核线程的区别是什么？**

* 用户线程是由函数库在用户态实现的线程机制
* 内核线程是由内核通过系统调用实现的线程机制

| 线程类型 | 用户线程 | 内核线程 |
| ------ | ----- | ----- |
| 实现方式 | 由函数库在用户态实现 | 由内核通过系统调用实现 |
| TCB的保存位置 | TCB存放在用户空间，由线程库函数维护 | TCB保存在内核空间，由内核维护 |
| 运行开销 | 小 | 大（因为需要系统调用） |
| 线程阻塞的影响范围 | 整个进程 | 单个线程 |
| 处理机调度 | 只能按进程分配CPU时间，因此每个线程的时间片较少 | 可以以线程为单位进行CPU时间分配 |

---

**同一进程内的不同线程可以共用一个相同的内核栈吗？**

用户线程是可以的。大概只有一个进程才有一个专用的内核栈。

---

**同一进程内的不同线程可以共用一个相同的用户栈吗？**

不可以。因为不同的线程代表了不同的程序执行流，每个执行流都需要一个单独的栈和指令指针和寄存器，不然会乱套的。

### 实践题
#### 用户线程堆栈的实现
**请尝试描述用户线程堆栈的可能维护方法。**

这个问题真是一时回答不了啊。可能需要观看一些实际的线程库实现才能回答。

#### 阅读简易进程管理系统的代码

**熟悉和理解下面的简化进程管理系统中的进程状态变化情况。**

* [简化的三状态进程管理子系统使用帮助](https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep7-process-run.md)
* [简化的三状态进程管理子系统实现脚本](https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep7-process-run.py)

这个子系统似乎来自于OSTEP的作业。这个程序叫`process-run.py`，是一个进程状态转换模拟器。进程可以处于以下几种状态之一：
* 运行（RUNNING）：进程正在使用CPU
* 就绪（READY）：进程已准备好使用CPU，但其他程序正在使用CPU
* 等待（WAITING）：进程正等待I/O请求完成
* 退出（DONE）：进程已结束执行

运行以下命令以浏览程序帮助：
```
prompt> ./process-run.py -h
```
或
```
prompt> python process-run.py -h
```

然后就会打印出以下内容：
```
Usage: process-run.py [options]

Options:
  -h, --help            show this help message and exit
  -s SEED, --seed=SEED  the random seed
  -l PROCESS_LIST, --processlist=PROCESS_LIST
                        a comma-separated list of processes to run, in the
                        form X1:Y1,X2:Y2,... where X is the number of
                        instructions that process should run, and Y the
                        chances (from 0 to 100) that an instruction will use
                        the CPU or issue an IO
  -L IO_LENGTH, --iolength=IO_LENGTH
                        how long an IO takes
  -S PROCESS_SWITCH_BEHAVIOR, --switch=PROCESS_SWITCH_BEHAVIOR
                        when to switch between processes: SWITCH_ON_IO,
                        SWITCH_ON_END
  -I IO_DONE_BEHAVIOR, --iodone=IO_DONE_BEHAVIOR
                        type of behavior when IO ends: IO_RUN_LATER,
                        IO_RUN_IMMEDIATE
  -c                    compute answers for me
  -p, --printstats      print statistics at end; only useful with -c flag
                        (otherwise stats are not printed)
```

其中最重要的参数是`-l PROCESS_LIST`，这个参数指定了每个运行进程的行为。一个进程由若干条指令组成，每条指令只能做这两件事之一：
* 使用CPU
* 发出I/O请求（并等待请求完成）
当进程仅仅是占用CPU（并且完全不进行I/O的时候），它应该会简单地在`RUNNING`（运行态）和`READY`（就绪态）之间切换。下面是一个单进程的不进行I/O的例子：

```
prompt> ./process-run.py -l 5:100 -p
```

输出是：
```
Produce a trace of what would happen when you run these processes:
Process 0
  cpu
  cpu
  cpu
  cpu
  cpu

Important behaviors:
  System will switch when
the current process is FINISHED or ISSUES AN IO
  After IOs, the process issuing the IO will
run LATER (when it is its turn)
```

此处我们输入的参数是`5:100`，意为只有一个进程，它有五条指令，且每条指令不进行I/O的概率都是100%。如果加上`-c`（`prompt> ./process-run.py -l 5:100 -c`），程序就会计算出答案：
```
Time PID: 0 CPU IOs
1 RUN:cpu 1
2 RUN:cpu 1
3 RUN:cpu 1
4 RUN:cpu 1
5 RUN:cpu 1
```

结果并不是很有意思：进程只是运行完成并结束了而已，没有进行任何I/O操作。现在可以尝试同时运行两个进程：
```
prompt> ./process-run.py -l 5:100,5:100
Produce a trace of what would happen when you run these processes:
Process 0
  cpu
  cpu
  cpu
  cpu
  cpu

Process 1
  cpu
  cpu
  cpu
  cpu
  cpu

Important behaviors:
  System will switch when
the current process is FINISHED or ISSUES AN IO
  After IOs, the process issuing the IO will
run LATER (when it is its turn)
```

在这种情况下，两个不同的进程在运行，不过都没有进行I/O操作。下面加入`-c`查看具体运行过程，输出为：
```
Time PID: 0 PID: 1 CPU IOs
1 RUN:cpu READY 1
2 RUN:cpu READY 1
3 RUN:cpu READY 1
4 RUN:cpu READY 1
5 RUN:cpu READY 1
6 DONE RUN:cpu 1
7 DONE RUN:cpu 1
8 DONE RUN:cpu 1
9 DONE RUN:cpu 1
10 DONE RUN:cpu 1
```

可以看出，PID为0的进程先运行，在运行过程中，PID为1的进程一直处于`READY`状态等待；直到前一个进程运行完进入`DONE`状态之后，它才开始运行。

下一个例子中的进程只进行I/O请求。
```
prompt> ./process-run.py -l 3:0
Process 0
  io
  io
  io

Important behaviors:
  System will switch when
the current process is FINISHED or ISSUES AN IO
  After IOs, the process issuing the IO will
run LATER (when it is its turn)
```

此时跟踪运行会输出什么呢？

```
Time PID: 0 CPU IOs
1 RUN:io-start 1
2 WAITING 1
3 WAITING 1
4 WAITING 1
5 WAITING 1
6* RUN:io-start 1
7 WAITING 1
8 WAITING 1
9 WAITING 1
10 WAITING 1
11* RUN:io-start 1
12 WAITING 1
13 WAITING 1
14 WAITING 1
15 WAITING 1
16* DONE
```

上述进程只进行了3次I/O。每次发出I/O请求时，进程都会进入`WAITING`状态；当设备在进行I/O时，CPU空闲了。

下面让我们来打印一些统计信息（加入`-p`）：
```
Stats: Total Time 16
Stats: CPU Busy 3 (18.75%)
Stats: IO Busy  12 (75.00%)
```

这一模拟过程花费了16个时钟周期，但CPU在超过80%的时间内都是空闲的。从另一个角度来说，I/O设备倒是很繁忙。总的来说，我们希望所有设备都很繁忙，因为这样可以更好地利用资源。

---

总的来说这就是个玩具，可以更好地帮助理解进程的切换和等待。不过它的功能也实在是少，似乎就没有抢占这一说，都是顺序执行到主动让出CPU控制权（退出或需要执行I/O请求）。随便输入了一个命令：
```
python process-run.py -l 3:50,3:50 -c -p
```

输出结果是这样，PID=0的进程进行了1次I/O，2次CPU操作；PID=1的进程进行了1次CPU操作，1次I/O，1次CPU操作。
```
Time    PID: 0      PID: 1      CPU     IOs
1       RUN:io      READY       1
2       WAITING     RUN:cpu     1       1
3       WAITING     RUN:io      1       1
4       WAITING     WAITING             2
5       WAITING     WAITING             2
6*      RUN:io      WAITING     1       1
7       WAITING     WAITING             2
8*      WAITING     RUN:cpu     1       1
9       WAITING     DONE                1
10      WAITING     DONE                1
11*     RUN:cpu     DONE        1


Stats: Total Time 11
Stats: CPU Busy 6 (54.55%)
Stats: IO Busy  9 (81.82%)
```

#### 实现不同的进程管理子系统

**设计一个简化的进程管理子系统，可以管理并调度如下简化进程。在理解[参考代码](https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab4/process-concept-homework.py)的基础上，完成＂YOUR CODE"部分的内容。然后通过测试用例和比较自己的实现与往届同学的结果，评价自己的实现是否正确。可２个人一组。**

##### 进程的状态
* RUNNING - 进程正在使用CPU
* READY - 进程可使用CPU
* DONE - 进程结束

##### 进程的行为
* 使用CPU,
* 发出YIELD请求,放弃使用CPU

##### 进程调度
* 使用FIFO/FCFS：先来先服务,
  * 先查找位于proc_info队列的curr_proc元素(当前进程)之后的进程(curr_proc+1..end)是否处于READY态，
  * 再查找位于proc_info队列的curr_proc元素(当前进程)之前的进程(begin..curr_proc-1)是否处于READY态
  * 如都没有，继续执行curr_proc直到结束

##### 关键模拟变量
* 进程控制块
```
PROC_CODE = 'code_'
PROC_PC = 'pc_'
PROC_ID = 'pid_'
PROC_STATE = 'proc_state_'
```
* 当前进程 curr_proc
* 进程列表：proc_info是就绪进程的队列（list），
在命令行（如下所示）需要说明每进程的行为特征：（1）使用CPU；（2）等待I/O
```
   -l PROCESS_LIST, --processlist= X1:Y1,X2:Y2,...
   X是进程的执行指令数;
   Y是执行CPU的比例(0..100) ，如果是100，表示不会发出yield操作
```
* 进程切换行为：系统决定何时(when)切换进程:进程结束或进程发出yield请求

##### 进程执行
```
instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)
```

##### 关键函数
* 系统执行过程：run
* 执行状态切换函数:　move_to_ready/running/done　
* 调度函数：next_proc

##### 执行实例
###### 例1
```
$./process-simulation.py -l 5:50
Process 0
  yld
  yld
  cpu
  cpu
  yld

Important behaviors:
  System will switch when the current process is FINISHED or ISSUES AN YIELD
Time     PID: 0
  1     RUN:yld
  2     RUN:yld
  3     RUN:cpu
  4     RUN:cpu
  5     RUN:yld
```

###### 例2
```
$./process-simulation.py  -l 5:50,5:50
Produce a trace of what would happen when you run these processes:
Process 0
  yld
  yld
  cpu
  cpu
  yld

Process 1
  cpu
  yld
  cpu
  cpu
  yld

Important behaviors:
  System will switch when the current process is FINISHED or ISSUES AN YIELD
Time     PID: 0     PID: 1
  1     RUN:yld      READY
  2       READY    RUN:cpu
  3       READY    RUN:yld
  4     RUN:yld      READY
  5       READY    RUN:cpu
  6       READY    RUN:cpu
  7       READY    RUN:yld
  8     RUN:cpu      READY
  9     RUN:cpu      READY
 10     RUN:yld      READY
 11     RUNNING       DONE
```
（虽然这个要求的输出着实有点奇怪，PID=1的进程在执行完毕之后仍然保持`READY`状态，直到另一个进程yield才切换状态到结束。不过这也不是不行，就是有点浪费资源。）

##### 代码
总体来说，这个代码十分简单，所以就不多加说明了。输出已改为Py3，参考了[这份代码](https://github.com/DrustZ/OS_SPOC_hw/blob/master/hw10/process-concept-homework.py)。
```
#! /usr/bin/env python

import sys
from optparse import OptionParser
import random

## process states
STATE_RUNNING = 'RUNNING'
STATE_READY = 'READY'
STATE_DONE = 'DONE'

## members of process structure
PROC_CODE = 'code_'
PROC_PC = 'pc_'
PROC_ID = 'pid_'
PROC_STATE = 'proc_state_'

## things a process can do
DO_COMPUTE = 'cpu'
DO_YIELD = 'yld'


class scheduler:
    def __init__(self):
        ## keep set of instructions for each of the processes
        self.proc_info = {}
        return

    def new_process(self):
        proc_id = len(self.proc_info)
        self.proc_info[proc_id] = {}
        self.proc_info[proc_id][PROC_PC] = 0
        self.proc_info[proc_id][PROC_ID] = proc_id
        self.proc_info[proc_id][PROC_CODE] = []
        self.proc_info[proc_id][PROC_STATE] = STATE_READY
        return proc_id

    def load(self, program_description):
        proc_id = self.new_process()
        tmp = program_description.split(':')
        if len(tmp) != 2:
            print('Bad description (%s): Must be number <x:y>')
            print('  where X is the number of instructions')
            print('  and Y is the percent change that an instruction is CPU not YIELD')
            exit(1)

        num_instructions, chance_cpu = int(tmp[0]), float(tmp[1])/100.0
        for i in range(num_instructions):
            if random.random() < chance_cpu:
                self.proc_info[proc_id][PROC_CODE].append(DO_COMPUTE)
            else:
                self.proc_info[proc_id][PROC_CODE].append(DO_YIELD)
        return

    #change to READY STATE, the current proc's state should be expected
    #此说明不清，实际应该是，仅当当前进程的状态为expected时，才转到READY状态
    #if pid==-1, then pid=self.curr_proc
    def move_to_ready(self, expected, pid=-1):
        #YACP CODE
        if self.proc_info[self.curr_proc][PROC_STATE] != expected:
            return
        if pid == -1:
            pid = self.curr_proc
        self.proc_info[pid][PROC_STATE] = STATE_READY
        return

    #change to RUNNING STATE, the current proc's state should be expected
    def move_to_running(self, expected):
        #YACP CODE
        if self.proc_info[self.curr_proc][PROC_STATE] != expected:
            return
        self.proc_info[self.curr_proc][PROC_STATE] = STATE_RUNNING
        return

    #change to DONE STATE, the current proc's state should be expected
    def move_to_done(self, expected):
        #YACP CODE
        if self.proc_info[self.curr_proc][PROC_STATE] != expected:
            return
        self.proc_info[self.curr_proc][PROC_STATE] = STATE_DONE
        return

    #choose next proc using FIFO/FCFS scheduling, If pid==-1, then pid=self.curr_proc
    def next_proc(self, pid=-1):
        #YACP CODE
        cur = 0
        if pid == -1:
            pid = self.curr_proc
        cur = pid
        cur = (cur + 1) % self.get_num_processes()
        while self.proc_info[cur][PROC_STATE] == STATE_DONE:
            if cur == pid:
                return
            #print("DEBUG: cur=" + str(cur))
            cur = (cur + 1) % self.get_num_processes()
        self.curr_proc = cur
        self.move_to_running(STATE_READY)
        return

    def get_num_processes(self):
        return len(self.proc_info)

    def get_num_instructions(self, pid):
        return len(self.proc_info[pid][PROC_CODE])

    def get_instruction(self, pid, index):
        return self.proc_info[pid][PROC_CODE][index]

    def get_num_active(self):
        num_active = 0
        for pid in range(len(self.proc_info)):
            if self.proc_info[pid][PROC_STATE] != STATE_DONE:
                num_active += 1
        return num_active

    def get_num_runnable(self):
        num_active = 0
        for pid in range(len(self.proc_info)):
            if self.proc_info[pid][PROC_STATE] == STATE_READY or \
                   self.proc_info[pid][PROC_STATE] == STATE_RUNNING:
                num_active += 1
        return num_active

    def space(self, num_columns):
        for i in range(num_columns):
            print('%10s' % ' ', end='')

    def check_if_done(self):
        if len(self.proc_info[self.curr_proc][PROC_CODE]) == 0:
            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING:
                self.move_to_done(STATE_RUNNING)
                self.next_proc()
        return

    def run(self):
        clock_tick = 0

        if len(self.proc_info) == 0:
            return

        ## make first one active
        self.curr_proc = 0
        self.move_to_running(STATE_READY)

        ## OUTPUT: heade`[rs for each column
        print('%s' % 'Time', end='')
        for pid in range(len(self.proc_info)):
            print('%10s' % ('PID:%2d' % (pid)), end='')

        print('')

        ## init statistics
        cpu_busy = 0

        while self.get_num_active() > 0:
            clock_tick += 1

            ## if current proc is RUNNING and has an instruction, execute it
            ## statistics clock_tick
            instruction_to_execute = ''
            if self.proc_info[self.curr_proc][PROC_STATE] == STATE_RUNNING and \
                   len(self.proc_info[self.curr_proc][PROC_CODE]) > 0:
                #YACP CODE
                instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)

            ## OUTPUT: print what everyone is up to
            print('%3d ' % clock_tick, end='')
            for pid in range(len(self.proc_info)):
                if pid == self.curr_proc and instruction_to_execute != '':
                    print('%10s' % ('RUN:'+instruction_to_execute), end='')
                else:
                    print('%10s' % (self.proc_info[pid][PROC_STATE]), end='')

            print('')

            ## if this is an YIELD instruction, switch to ready state
            ## and add an io completion in the future
            if instruction_to_execute == DO_YIELD:
                #YACP CODE
                self.move_to_ready(STATE_RUNNING)
                self.next_proc();

            ## ENDCASE: check if currently running thing is out of instructions
            self.check_if_done()
        return (clock_tick)

#
## PARSE ARGUMENTS
#

parser = OptionParser()
parser.add_option('-s', '--seed', default=0, help='the random seed', action='store', type='int', dest='seed')
parser.add_option('-l', '--processlist', default='',
                  help='a comma-separated list of processes to run, in the form X1:Y1,X2:Y2,... where X is the number of instructions that process should run, and Y the chances (from 0 to 100) that an instruction will use the CPU or issue an YIELD',
                  action='store', type='string', dest='process_list')
parser.add_option('-p', '--printstats', help='print statistics at end; only useful with -c flag (otherwise stats are not printed)', action='store_true', default=False, dest='print_stats')
(options, args) = parser.parse_args()

random.seed(options.seed)

s = scheduler()

## example process description (10:100,10:100)
for p in options.process_list.split(','):
    s.load(p)


print('Produce a trace of what would happen when you run these processes:')
for pid in range(s.get_num_processes()):
    print('Process %d' % pid)
    for inst in range(s.get_num_instructions(pid)):
        print('  %s' % s.get_instruction(pid, inst))
    print('')
print('Important behaviors:')
print('  System will switch when the current process is FINISHED or ISSUES AN YIELD')

(clock_tick) = s.run()

if options.print_stats:
    print('')
    print('Stats: Total Time %d' % clock_tick)
    print('')
```
