---
title: 《操作系统》第12讲：“进程控制”总结
urlname: os-mooc-lecture-12-summary
toc: true
date: 2018-04-17 20:48:16
tags: [操作系统, 课程总结]
---

## 课程内容概述

## 练习
来自[lec12进程控制在线练习](https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/05-2-quiz.md)和[lec12进程／线程控制spoc练习](https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/05-2-spoc-discussion.md)。

### 选择填空题
**关于进程切换描述正确的是（）**

* **进程切换会暂停当前运行进程，使其从运行状态变成就绪等其他状态**
* **进程切换要保存当前进程的上下文**
* **进程切换要恢复下一个进程的上下文**
* 进程切换的进程上下文不包括CPU的寄存器等硬件信息

上下文显然是包括通用寄存器和CR3等的信息的。

---

**关于ucore os中创建新进程的描述正确的是（）**

* **fork()创建子进程中，会复制父进程的所有变量和内存**
* **子进程的fork()返回0**
* **父进程的fork()在创建子进程成功后，返回子进程标识符**
* **fork()创建子进程中，会复制父进程的页表**

都对。当然，事实上可以用COW机制实现fork，这样就不会复制内存，而只是分配了一个新的页表，页表项只读地指向父进程的页，需要写时才新建页。以及fork如果不成功则会返回负值。

---

**关于进程加载执行的描述正确的是（）**

* **系统调用exec()加载新程序取代当前运行进程**
* **系统调用exec()允许进程“加载”一个完全不同的程序，并从main开始执行**
* **exec调用成功时，它是相同的进程，但是运行了不同的程序**
* **exec调用成功时，代码段、堆栈和堆(heap)等完全重写了**

都对。总之调用fork之后调用exec就相当于新建进程了。（虽然这样看来fork直接复制的意义就没有，不过我们有COW了。）

---

**有关管理进程等待的描述正确的是（）**

* **wait()系统调用用于父进程等待子进程的结束**
* **子进程结束时通过exit()向父进程返回一个值**
* **当某子进程调用exit()时,唤醒父进程，将exit()返回值作为父进程中wait的返回值**
* **进程结束执行时调用exit()，完成进程的部分占用资源的回收**

都对。当然这个描述的是父进程先wait，子进程再exit的过程。如果是子进程先exit，则它会变成僵尸进程；一旦父进程调用wait，则返回任意一个处于僵尸状态的子进程，回收它的资源。

### 简答题
**进程切换的可能时机有哪些？**

* 时间片用完
* 被高优先级进程抢先
* 进入等待状态
* 进程结束
* 主动放弃控制权，进入就绪状态

---

**ucore进程控制块proc_struct数据结构内容有些什么？**

进程基本信息

进程状态信息

进程执行现场保存

进程队列指针

分析ucore的进程切换代码，说明ucore的进程切换触发时机和进程切换的判断时机都有哪些。
schedule

proc_run

switch_to

ucore的进程控制块数据结构是如何组织的？主要字段分别表示什么？有哪些函数对它进行了修改？有哪些函数用到它？
arch_proc_struct
mm_struct
need_resched
wait_state
run_link、list_link、hash_link
12.2 进程创建
fork()的返回值是唯一的吗？父进程和子进程的返回值是不同的。请找到相应的赋值代码。
新进程创建时的进程标识是如何设置的？请指明相关代码。
get_pid();

fork()的例子中进程标识的赋值顺序说明进程的执行顺序。
请在ucore启动时显示空闲进程（idleproc）和初始进程（initproc）的进程标识。
请在ucore启动时显示空闲线程（idleproc）和初始进程(initproc)的进程控制块中的“pde_t *pgdir”的内容。它们是否一致？为什么？
12.3 进程加载
加载进程后，新进程进入就绪状态，它开始执行时的第一条指令的位置，在elf中保存在什么地方？在加载后，保存在什么地方？
第一个用户进程执行的代码在哪里？它是什么时候加载到内存中的？
12.4 进程等待与退出
试分析wait()和exit()的结果放在什么地方？exit()是在什么时候放进去的？wait()在什么地方取到出的？
试分析ucore操作系统内核是如何把子进程exit()的返回值传递给父进程wait()的？
什么是僵尸进程和孤儿进程？
https://piazza.com/class/i5j09fnsl7k5x0?cid=753

试分析sleep()系统调用的实现。在什么地方设置的定时器？它对应的等待队列是哪个？它的唤醒操作在什么地方？
通常的函数调用和函数返回都是一一对应的。有不是一一对应的例外情况？如果有，请举例说明。
小组思考题
(1) (spoc)设计一个简化的进程管理子系统，可以管理并调度如下简化进程.给出了参考代码，请理解代码，并完成＂YOUR CODE"部分的内容．　可２个人一组

进程的状态
 - RUNNING - 进程正在使用CPU
 - READY   - 进程可使用CPU
 - WAIT    - 进程等待I/O完成
 - DONE    - 进程结束
进程的行为
 - 使用CPU,
 - 发出YIELD请求,放弃使用CPU
 - 发出I/O操作请求,放弃使用CPU
进程调度
使用FIFO/FCFS：先来先服务, 只有进程done, yield, io时才会执行切换
先查找位于proc_info队列的curr_proc元素(当前进程)之后的进程(curr_proc+1..end)是否处于READY态，
再查找位于proc_info队列的curr_proc元素(当前进程)之前的进程(begin..curr_proc-1)是否处于READY态
如都没有，继续执行curr_proc直到结束
关键模拟变量
io_length : IO操作的执行时间
进程控制块
PROC_CODE = 'code_'
PROC_PC = 'pc_'
PROC_ID = 'pid_'
PROC_STATE = 'proc_state_'
当前进程 curr_proc
进程列表：proc_info是就绪进程的队列（list），
在命令行（如下所示）需要说明每进程的行为特征：（１）使用CPU ;(2)等待I/O
   -l PROCESS_LIST, --processlist= X1:Y1,X2:Y2,...
   X 是进程的执行指令数;
   Ｙ是执行yield指令（进程放弃CPU,进入READY状态）的比例(0..100)
   Ｚ是执行I/O请求指令（进程放弃CPU,进入WAIT状态）的比例(0..100)
进程切换行为：系统决定何时(when)切换进程:进程结束或进程发出yield请求
进程执行
instruction_to_execute = self.proc_info[self.curr_proc][PROC_CODE].pop(0)
关键函数
系统执行过程：run
执行状态切换函数:　move_to_ready/running/done　
调度函数：next_proc
执行实例
例1
$./process-simulation.py  -l 5:30:30,5:40:30 -c
Produce a trace of what would happen when you run these processes:
Process 0
  io
  io
  yld
  cpu
  yld

Process 1
  yld
  io
  yld
  yld
  yld

Important behaviors:
  System will switch when the current process is FINISHED or ISSUES AN YIELD or IO
Time     PID: 0     PID: 1        CPU        IOs
  1      RUN:io      READY          1            
  2     WAITING    RUN:yld          1          1
  3     WAITING     RUN:io          1          1
  4     WAITING    WAITING                     2
  5     WAITING    WAITING                     2
  6*     RUN:io    WAITING          1          1
  7     WAITING    WAITING                     2
  8*    WAITING    RUN:yld          1          1
  9     WAITING    RUN:yld          1          1
 10     WAITING    RUN:yld          1          1
 11*    RUN:yld       DONE          1            
 12     RUN:cpu       DONE          1            
 13     RUN:yld       DONE          1            

### 实践题
