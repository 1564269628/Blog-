---
title: 《操作系统》第15讲：“处理机调度”总结
urlname: os-mooc-lecture-15-summary
toc: true
tags: [操作系统, 课程总结]
---

## 课程内容概述
TODO

## 练习
来自[调度算法概念(lec 15) spoc 思考题](https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/06-1-spoc-discussion.md)和[lec15处理器调度在线练习](https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/06-1-quiz.md)。

### 选择填空题
**若当前进程因时间片用完而让出处理机时，该进程应转变为（）状态。**

* **就绪**
* 等待
* 运行
* 完成

这是显然的，因为只是当前时间片用完了，并没有触发等待事件。

---

**最高响应比优先算法的特点是（）**

* 有利于短作业但不利于长作业
* **有利于短作业又兼顾到长作业**
* 不利于短作业也不利于长作业
* 不利于短作业但有利于长作业

最高响应比优先算法的策略是，选择就绪队列中响应比R值最高的进程。其中：
* R=(w+s)/s
* w：等待时间（waiting time）
* s：执行时间（service time）（预估的）

这是个好算法，缺点是更新开销太大。

---

**在单处理器的多进程系统中，进程什么时候占用处理器和能占用多长时间，取决于（）**

* 进程相应的程序段的长度
* 进程总共需要运行时间多少
* **进程自身和进程调度策略**
* 进程完成什么功能

这个讲法不算非常严谨了。在多级队列调度算法中，不同功能的进程就处于不同的队列中，调度策略也有差别；最高响应比优先算法中，调度策略也与预估的进程运行时间有关。但是总之第2和4个选项也包含在3中。

---

**时间片轮转调度算法是为了（）**

* **多个终端都能得到系统的及时响应**
* 先来先服务
* 优先级高的进程先使用CPU
* 紧急事件优先处理

RR算法就是不断按时间片切换进程。先来先服务应该说的是FCFS。优先级高的进程先使用CPU说的应该是多级反馈队列调度算法或者多级队列调度算法。紧急事件优先处理大概是多级反馈队列调度算法……（不确定）

---

**下面关于硬时限（hard deadlines）和软时限（soft deadlines）的描述错误的是（）**

* 如果错过了硬时限，将会发生严重的后果
* **硬时限是通过硬件实现的，软时限是通过软件实现的**
* 如果软时限没有被满足，系统也可以继续运行
* 硬时限可以保证系统的确定性

这个错误选项就属于望文生义了。定义如下：
* 硬时限（Hard deadline）
  * 错过任务时限会导致灾难性或非常严重的后果
  * 必须验证，在最坏情况下能够满足时限
* 软时限（soft deadline）
  * 通常要求满足任务时限
  * 尽量满足

---

**在基于优先级的可抢占的调度机制中，当系统强制使高优先级任务等待低优先级任务时，会发生（）**

* **优先级反转**
* 优先级重置
* 系统错误
* 死循环

优先级反置（priority inversion）的定义：操作系统中出现高优先级进程长时间等待低优先级进程所占用资源的现象。

不过这个似乎不是系统强制的问题……

### 简答题

**处理机调度的功能是什么？**

处理机调度：管理处理机执行能力的资源的功能
* 选线程：从就绪队列中挑选下一个占用CPU运行的线程
* 选CPU：从多个可用CPU中挑选就绪线程可使用的CPU资源

---

**在什么时候可以进行处理机调度？**

调度时机的所有可能：
* 占用CPU运行的线程的主动放弃（退出、等待）
* 当前线程被抢先（时间片用完、高优先级线程就绪）

---

**当操作系统的处理机调度导致线程切换时，暂停线程的当前指令指针可能在什么位置？用户态代码或内核代码？给出理由。**

似乎答案应该是“都有可能”。可能在用户态这点是显然的。至于在内核态，答案中指出，系统调用返回时可能出现线程切换（不是很懂）。

至于ucore自己的实现，ucore docs中是这么说的：
>但如果把ucore操作系统也看成是一个特殊的内核进程或多个内核线程的集合，那ucore是否也是可抢占的呢？其实ucore内核执行是不可抢占的（ nonpreemptive） ，即在执行“任意”内核代码时，CPU控制权可被强制剥夺。这里需要注意，不是在所有情况下ucore内核执行都是不可抢占的，有以下几种“固定”情况是例外：
1. 进行同步互斥操作，比如争抢一个信号量、锁（ lab7中会详细分析） ；
2. 进行磁盘读写等耗时的异步操作，由于等待完成的耗时太长，ucore会调用shcedule让其他就绪进程执行。
这几种情况其实都是由于当前进程所需的某个资源（ 也可称为事件） 无法得到满足，无法继续执行下去，从而不得不主动放弃对CPU的控制权。如果参照用户进程任何位置都可被内核打断并放弃CPU控制权的情况，这些在内核中放弃CPU控制权的执行地点是“固定”而不是“任意”的，不能体现内核任意位置都可抢占性的特点。

---

**处理机的使用模式有什么特征？**

* CPU与I/O交替使用
  * 因为发生I/O之后就被抢占了
* 每次占用CPU执行指令的时间长度分布多数在10ms以内
  * 课件中指出，大部分执行的时间在8ms之内

---

**处理机调度的目标是什么？**

* CPU利用率（CPU使用率、吞吐量、周转时间、等待时间）
  * CPU使用率：CPU处于忙状态的**时间百分比**
  * 吞吐量：单位时间内完成的**进程数量**
  * 周转时间：进程从初始化到结束（包括等待）的**总时间**
  * 就绪等待时间：进程在就绪队列中的**总时间**
* 用户感受（周转时间、等待时间、响应时间、响应时间的方差）
  * 响应时间：处理用户的输入请求的时间
  * 响应时间的方差：差不多就是响应时间的波动吧……
* 公平性（CPU时间分配公平性）
  * 保证每个进程占用相同的CPU时间
  * 保证每个进程的等待时间相同

---

**尝试描述下列处理机调度算法的工作原理和算法优缺点。**

* 先来先服务算法（FCFS）
* 短进程优先算法（SPN、SJF）
* 最高响应比优先算法（HRRN）

答案中给出了这样的提示：
> 就绪队列的排队依据：到达时间、进程预期执行时间、按响应比R=(w+s)/s
> 算法特征：平均等待时间、等待时间方差、资源利用率

工作原理：
* 先来先服务算法（FCFS，First Come First Served）：按就绪队列中的先后顺序进行排队
* 短进程优先算法：按作业执行时间的长短进行排队
  * SPN（Shortest Process Next）：选择就绪队列中执行时间最短的进程占用CPU进入运行状态
  * SJF（Shortest Job First，短作业优先算法）：不知道这个和SPN有何区别，大概只是作业和进程的定义不同吧……
• 最高响应比优先算法（HRRN，Highest Response Ratio Next）：考虑进程在就绪队列中的等待时间，计算响应比，选择响应比最高的进程

| 比较 | FCFS | SPN | HRRN |
| --- | ----- | --- | ---- |
| 平均等待时间 | 波动大 | 最小 | 不会饥饿 |
| 资源利用率 | 低 | ？ | ？ |

---

**为什么短进程优先算法的平均周转时间最优？**

可以证明知进程优先算法的调度顺序的平均周转时间是最短的。把短的都排在前面了，这很显然。

---

**如何调试你的调度算法？**

监控调度算法的执行状态、调度结果、算法特征等信息。

等下，怎么还有这种题目……

---

**尝试描述下列处理机调度算法的工作原理和算法优缺点。**
* 时间片轮转算法（RR）
* 多级反馈队列算法（MLFQ）
* 公平共享调度算法（FSS）

答案中给出了这样的提示：
> 让出CPU的条件：进程执行时间
> 就绪队列排队依据：多队列、多种排队依据、依据进程特征调整所在队列
> 算法特征：响应时间、平均周转时间、不同类型进程的调度差异

* RR
  * 思路：
    * 时间片结束时，按FCFS算法切换到下一个就绪进程
    * 每隔n-1个时间片，进程执行一个时间片q
  * 优点：平均等待时间稳定
  * 缺点：太不灵活了
* MLFQ
  * 思路：
    * 进程可在不同队列间移动的多级队列算法
    * 时间片大小随优先级级别增加而增加
    * 如进程在当前的时间片没有完成，则降到下一个优先级
  * 优点：及时反馈
  * 缺点：不知道！
* FSS
  * 思路：
    * 控制用户对系统资源的访问
    * 一些用户组比其他用户组更重要
    * 保证不重要的组无法垄断资源
	* 未使用的资源按比例分配
	* 没有达到资源使用率目标的组获得更高的优先级
  * 优点：公平
  * 缺点：因为公平，所以牺牲了一些效率

---

**RR算法选择时间片长度的依据有哪些？**

* 进程切换开销
* 进程当前操作占用的CPU时间
* 切换开销与响应时间的折中权衡

时间片选择的经验规则：
* 过大：等待时间太长，极限情况退化成FCFS
* 过小：反应迅速，但上下文切换的开销过大，影响系统吞吐量
* 时间片长度选择的经验规则：维持上下文切换开销处于1%之内，一般在10ms左右

---

**请描述在MLFQ中，如何提升或降低进程的优先级？**

* I/O操作后提升优先级（事实上这是可选的）
* 时间片用完后降低优先级（除非已经到了最后一级）

---

**尝试跟踪ucore中进程切换和调度算法的就绪进程选择过程。**

中断响应、进程的中断现场保存、中断处理、调度判断、进程切换、新进程的中断现场恢复、新进程的继续执行

感觉这个已经在实验报告里讲了很多了……

何时会调用`schedule()`函数在Lab5的报告中已经说明过了，此处不再赘述。在调用该函数之后，就会进行调度，选择下一个运行的进程。

```
void
schedule(void) {
    bool intr_flag;
    struct proc_struct *next;
    local_intr_save(intr_flag);
    {
        current->need_resched = 0;
        if (current->state == PROC_RUNNABLE) {
            sched_class_enqueue(current);
        }
        if ((next = sched_class_pick_next()) != NULL) {
            sched_class_dequeue(next);
        }
        if (next == NULL) {
            next = idleproc;
        }
        next->runs ++;
        if (next != current) {
            proc_run(next);
        }
    }
    local_intr_restore(intr_flag);
}
```

首先关中断，将当前进程置为不需要重新调度。如果当前进程仍然为`PROC_RUNNABLE`状态，则调用`sched_class_enqueue()`，将它加入到运行队列最后，设置其最大时间片数量。之后调用`sched_class_pick_next()`，得到运行队列头部的进程，将其出队（`sched_class_dequeue()`），准备接下来运行它。如果运行队列已为空，则转到`idleproc`。最后开中断，开始运行新进程。

当发生时钟中断时，调用`sched_class_proc_tick()`，将正在运行的进程的时间片数量-1。如果当前进程的时间片数量已经减少到0，则将进程的`need_resched`变量置为1，随后调用`schedule()`函数。

---

**为什么要引入调度框架？定义调度算法接口需要考虑哪些因素？**

引入调度框架的目的：分离调度操作和调度策略，以支持多种调度算法。

定义调度算法接口的考虑因素：调度算法需要的调度操作类型、调度算法在各调度操作中的体现方式。

ucore中的调度框架大概是这样的，据说有很好的扩展性。

`sched_class`的代码如下：
```
// The introduction of scheduling classes is borrrowed from Linux, and makes the
// core scheduler quite extensible. These classes (the scheduler modules) encapsulate
// the scheduling policies.
struct sched_class {
    // the name of sched_class
    const char *name;
    // Init the run queue
    void (*init)(struct run_queue *rq);
    // put the proc into runqueue, and this function must be called with rq_lock
    void (*enqueue)(struct run_queue *rq, struct proc_struct *proc);
    // get the proc out runqueue, and this function must be called with rq_lock
    void (*dequeue)(struct run_queue *rq, struct proc_struct *proc);
    // choose the next runnable task
    struct proc_struct *(*pick_next)(struct run_queue *rq);
    // dealer of the time-tick
    void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);
    /* for SMP support in the future
     *  load_balance
     *     void (*load_balance)(struct rq* rq);
     *  get some proc from this rq, used in load_balance,
     *  return value is the num of gotten proc
     *  int (*get_proc)(struct rq* rq, struct proc* procs_moved[]);
     */
};
```
其中：
* `init`：初始化运行队列，这一函数会在`sched_init()`中被调用
* `enqueue`：将进程加入运行队列；在进程进入`PROC_RUNNABLE`状态时会调用这一函数，如在`schedule()`中从运行态转入就绪态，以及`wakeup_proc`中进入就绪态时
* `dequeue`：将进程移出运行队列；在进程离开`PROC_RUNNABLE`状态时会调用这一函数，如在`schedule()`中将就绪态进程转为运行态时
* `pick_next`：从运行队列中选择下一个进程来运行，在`schedule()`中会调用这一函数
* `proc_tick`：更新正在运行的进程的已用时间片数量，在`trap_dispatch`中处理时间中断时会调用这一函数

---

**什么是实时操作系统？**

实时操作系统是保证在一定时间限制内完成特定功能的操作系统。

参考： http://baike.baidu.com/item/%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F

---

**什么是可调度性？**

可调度性表示一个实时操作系统能够满足任务时限要求。

---

**尝试描述下列处理机调度算法的工作原理和算法优缺点。**

* 速率单调调度算法(RM, Rate Monotonic)
* 最早截止时间优先算法 (EDF, Earliest Deadline First)

任务优先级定义：按周期大小排队、按截止时间先后排队
* RM
  * 通过周期安排优先级
  * 周期越短，优先级越高
  * 执行周期最短的任务
* EDF
  * 截止时间越早优先级越高
  * 执行截止时间最少的任务

RM的可调度条件：CPU利用率小于ln2时，是可调度的。

EDF的可调度条件：CPU利用率小于100%。

---

**多处理机调度中每个处理机一个就绪队列与整个系统一个就绪队列有什么不同？**

区别：调度开销、负载均衡程度

以及，调度程序对共享资源的访问需要进行同步。

---

**什么是优先级反置现象？**

操作系统中出现高优先级进程长时间等待低优先级进程所占用资源的现象。

产生的原因大概是复杂的资源分配关系。

---

**什么是优先级继承(Priority Inheritance)和优先级天花板协议(priority ceiling protocol)？它们的区别是什么？**

优先级继承：占用资源的低优先级进程继承申请资源的高优先级进程的优先级。**只在占有资源的低优先级进程被阻塞时，才提高占有资源进程的优先级。** 这样设计的原因是，优先级升高之后，原先低优先级的进程就会更快执行完，释放资源。释放资源之后，它的优先级就会降低，转为申请资源的高优先级进程执行。

优先级天花板协议：占用资源进程的优先级和所有可能申请该资源的进程的最高优先级相同。**不管是否发生等待，都提升占用资源进程的优先级。** 这一做法假设进程会尽快处理完资源并释放，可能会出现优先级滥用的情况。

区别：提升占用资源的低优先级进程的优先级的时机不同。

---

**ppt中“优先级继承”页里的图示有误，你能指出来吗？**

为什么会有这种坑爹题目……

![](priority-inheritance.png)

好像也没看出什么大错来，除了T2线程中没有绘制占用和释放资源的过程，以及T1线程中释放资源s的位置可能有点问题。

### 实践题

**尝试在ucore上写一个外排序程序，然后分析它的执行时间分布统计（每次切换后开始执行时间和放弃CPU的时间、当前用户和内核栈信息）。**

没写（不过大概不难……）

---

**在Linux上有一个应用程序time，可以统计应用程序的执行时间信息。请分析它是如何统计进程执行时间信息的。如可能，请在ucore上实现相同功能的应用程序。下面是可能的参考。**

* [Linux用户态程序计时方式详解](http://www.cnblogs.com/clover-toeic/p/3845210.html)
* [Get Source Code for any Linux Command](http://www.thegeekstuff.com/2010/02/get-source-code-for-any-linux-command/)
* [How does time command work](http://unix.stackexchange.com/questions/29800/how-does-time-command-work)
* https://github.com/illumos/illumos-gate/blob/master/usr/src/cmd/time/time.c

太烦了，先不看了。

---

**尝试获取一个操作系统的调度算法的性能统计数据（CPU使用率、进程执行）。**

……

---

**通过观察FIFO、SJF和RR调度算法的[模拟程序](https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep8-scheduler.py)运行结果及其[描述文档](https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep8-scheduler.md)，理解其工作原理和算法特征。**

这个模拟程序是py2的，我已经修改成了py3的版本（[ostep8-scheduler.py](https://gist.github.com/YetAnotherCP/6453b2b9dde0606e7204f7febaa1c14d#file-ostep8-scheduler-py)）。这个模拟器很简单，使用方法如下：

* 输入`python ostep8-scheduler.py -p FIFO -j 3 -s 100`，输出：
```
ARG policy FIFO
ARG jobs 3
ARG maxlen 10
ARG seed 100

Here is the job list, with the run time of each job:
  Job 0 ( length = 2 )
  Job 1 ( length = 5 )
  Job 2 ( length = 8 )


Compute the turnaround time, response time, and wait time for each job.
When you are done, run this program again, with the same arguments,
but with -c, which will thus provide you with the answers. You can use
-s <somenumber> or your own job list (-l 10,15,20 for example)
to generate different problems for yourself.
```
* 输入`python ostep8-scheduler.py -p FIFO -j 3 -s 100 -c`，输出：
```
ARG policy FIFO
ARG jobs 3
ARG maxlen 10
ARG seed 100

Here is the job list, with the run time of each job:
  Job 0 ( length = 2 )
  Job 1 ( length = 5 )
  Job 2 ( length = 8 )


** Solutions **

Execution trace:
  [ time   0 ] Run job 0 for 2.00 secs ( DONE at 2.00 )
  [ time   2 ] Run job 1 for 5.00 secs ( DONE at 7.00 )
  [ time   7 ] Run job 2 for 8.00 secs ( DONE at 15.00 )

Final statistics:
  Job   0 -- Response: 0.00  Turnaround 2.00  Wait 0.00
  Job   1 -- Response: 2.00  Turnaround 7.00  Wait 2.00
  Job   2 -- Response: 7.00  Turnaround 15.00  Wait 7.00

  Average -- Response: 3.00  Turnaround 8.00  Wait 3.00
```

因为FIFO、SJF和RR本身也很简单，在此不再赘述了。

---

**通过观察MLFQ调度算法的[模拟程序](https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep9-mlfq.py)运行结果及其[描述文档](https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep9-mlfq.md)，理解其工作原理和算法特征。**

py3版本的模拟程序：[ostep9-mlfq.py](https://gist.github.com/YetAnotherCP/6453b2b9dde0606e7204f7febaa1c14d#file-ostep9-mlfq-py)

这个的使用方法类似，可以用`-h`来查看全部配置方法。此处实现的MLFQ调度算法的模拟流程大致如下：
* 初始化若干个队列及其对应的时间片的长度，把进程全部排列在最高优先级的队列中
* 对于每个时间片，当进程还没有全部执行完毕时
  * 检查选项中是否开启了`BOOST`，即定时将全部进程放回最高优先级队列；如果是，则对进程进行处理
  * 检查当前时刻是否有进程的I/O操作执行完毕；如果执行完了，则将进程放入对应优先级的队列中
    * 如果选项中开启了`iobump`，则将该进程放入队头位置；否则放入队尾
  * 找到优先级最高的非空队列，将队头的进程运行一个时间片；如果队列均为空则IDLE
  * 如果该进程运行结束，则将它从队头移除
  * 如果该进程发出I/O请求，则将它从队头移除。
    * 如果选项中开启了`stay`，则发出I/O请求后进程优先级不会变化（虽然这里我不是很理解，没有看到，如果不开启`stay`，进程优先级会提高的代码……）
  * 如果该进程耗尽了当前时间片，则将它从队头移除，并降低其优先级。
* 打印统计信息

---

**通过观察彩票调度算法([Lottery scheduling](https://en.wikipedia.org/wiki/Lottery_scheduling))的[模拟程序](https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep10-lottery.py)运行结果及其[描述文档](https://github.com/chyyuu/os_tutorial_lab/blob/master/ostep/ostep10-lottery.md)，理解其工作原理和算法特征。**

py3版本的模拟程序：[ostep10-lottery.py](https://gist.github.com/YetAnotherCP/6453b2b9dde0606e7204f7febaa1c14d#file-ostep10-lottery-py)

彩票调度算法的思想很简单：用彩票数量表示请求资源（在这里可以直接说是时间片）的优先级，彩票越多，表示优先级越高；每次在系统中抽取一张彩票，然后让彩票的所有者开始运行。

程序中的实现方法类似，比较简单。

---

**有兴趣的同学，请阅读下面论文，然后说明实时调度面临的主要困难是什么？**
* [Buttazzo, “Rate monotonic vs. EDF: Judgement Day”, EMSOFT 2003.](http://www.eecs.umich.edu/courses/eecs571/reading/rm-vs-edf.pdf)
* [单调速率及其扩展算法的可调度性判定](http://www.jos.org.cn/ch/reader/create_pdf.aspx?file_no=20040602)

没有兴趣。（至少暂时没有。）

---

**在单CPU情况下，基于以前的OS知识，能否设计一个更简单的方法（也许执行效率会低一些）解决优先级反置现象？**

好问题。我还没有仔细去想。

---

**参考往届同学的处理机调度算法实现练习，从下列8个算法中选择一个你感兴趣的调度算法，对其实现进行完善，并分析算法特征。可参考[scheduler-homework.py](https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab6/scheduler-homework.py)代码。**
(1)理解并实现FIFO调度算法
(2)理解并实现SJF调度算法
(3)理解并实现RR调度算法
(4)理解并实现MLFQ调度算法
(5)理解并实现stride调度算法
(6)理解并实现EDF实时调度算法
(7)理解并实现RM实时调度算法
(8)理解并实现优先级反置方法
* [2016春季-第十五讲 课堂思考题回答-向勇班](https://piazza.com/class/i5j09fnsl7k5x0?cid=803)
* [陈渝班-2016春季-第15讲 课堂思考题回答](https://piazza.com/class/i5j09fnsl7k5x0?cid=806)

这个似乎太耗费时间了，我还没有去写。如果有时间的话，写出来可以好好比较一下各个算法在相同的数据集上的表现。
