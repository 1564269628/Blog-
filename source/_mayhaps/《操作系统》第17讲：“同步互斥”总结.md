---
title: 《操作系统》第17讲：“同步互斥”总结
urlname: os-mooc-lecture-17-summary
toc: true
tags: [操作系统, 课程总结]
---

## 课程内容概述

* 背景
  * 什么是并发进程
  * 为什么需要并发进程
  * 实现并发进程的基本思路
* 一个现实生活中的同步问题
  * 几种解决方案
  * 进程通常的交互关系及其带来的问题
* 临界区的定义
* 临界区的实现方法
  * 禁用硬件中断
  * 基于软件的同步方法
    * 共享变量
    * Peterson算法
    * Dekkers算法
    * Eisenberg & McGuire算法
  * 基于硬件原语的抽象同步方法

### 背景
#### 什么是并发进程
首先对比了独立进程和并发进程的概念。
* 独立进程：
  * 不和其他进程共享资源或状态
  * 确定性：输入状态决定结果
  * 可重现：能够重现起始条件
  * 调度顺序不重要
* 并发进程：
  * 在多个进程间有资源共享
  * 不确定性：输入状态不能完全决定结果
  * 不可重现：调度具有随机性

不过我们希望并发进程能够保持结果的正确性。从这个意义上来讲，我们期望并发进程的部分结果和状态是可预测的，但另一部分结果和状态是不确定的（如调度顺序、中断时机等）。事实上，我们要做的事情就是在考虑这种不确定性的基础上保证结果的正确性。

#### 进程并发执行的好处
* 进程需要与计算机中的其他进程和设备进行协作
* 共享资源
* 加速
  * I/O操作和CPU计算可以并行
  * 程序可划分成多个模块放在多个处理器上并行执行
* 模块化
  * 将大程序分解成小程序
* 使系统易于复用和扩展

### 一个现实生活中的同步问题

#### 几种解决方案

#### 进程通常的交互关系及其带来的问题

| 进程相互感知的程度	交互关系	进程相互的影响
| 相互不感知（完全不了解其他进程的存在）	独立	一个进程的操作对其他进程的结果无影响
| 间接感知（双方都与第三方交互，如共享资源）	通过共享进行协作	一个进程的结果依赖于共享资源的状态
| 直接感知（双方直接交互，如通信）	通过通信进行协作	一个进程的结果依赖于从其他进程获得的信息

导致的进程的三种关系：
* 互斥（mutual exclusion）：一个进程占用资源，其他进程不能使用，需要等待使用资源进程的释放
* 死锁（deadlock）：多个进程各自占用部分资源，循环等待
* 饥饿（starvation）：其他进程可能轮流占用资源，一个进程一直得不到资源

## 练习
来自[lec17 同步互斥 在线练习](https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/07-1-quiz.md)和[同步互斥(lec 17) spoc 思考题](https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/07-1-spoc-discussion.md)。

### 选择填空题
**临界资源是什么类型的共享资源（）**

* 临界资源不是共享资源
* 用户共享资源
* **互斥共享资源**
* 同时共享资源

课堂上似乎没有强调临界资源的定义。互斥共享大概是正确的，不过我觉得限制同时共享的用户数量也算是一种互斥共享。

---

**操作系统中，两个或多个并发进程各自占有某种资源而又都等待别的进程释放它们所占有的资源的现象叫做什么（）**

* 饥饿
* **死锁**
* 死机
* 死循环

这个的答案是显然的。之后的课上会讲到死锁的预防和解决方法。

---

**共享变量是指（）访问的变量**

* 只能被系统进程
* 只能被多个进程互斥
* 只能被用户进程
* **可被多个进程**

当然，理论上来说，正确实现的共享变量是可以由多个进程互斥访问的变量。但是如果不正确实现那我也没办法……

---

**要想进程互斥地进入各自的同类资源的临界区，需要（）**

* 在进程间互斥使用共享资源
* 在进程间非互斥使用临界资源
* **在进程间互斥地使用临界资源**
* 在进程间不使用临界资源

总之差不多是这个意思吧。

---

**锁的实现方法有哪几种（）**

* **禁用中断**
* **软件方法**
* 添加硬件设备
* **原子操作指令**

有三种课上都提到了。至于添加硬件设备……想象一下，大概可能是添加一个新的芯片，其中存储了各种锁的状态，然后通过指令来修改状态？那就和原子操作指令没差别了。

---

**一个进程由阻塞队列进入就绪队列，可能发生了哪种情况（）**

* **一个进程释放一种资源**
* 系统新创建了一个进程
* 一个进程从就绪队列进入阻塞队列
* 一个在阻塞队列中的进程被系统取消了

系统新创建一个进程之后，这个进程一般会直接进入就绪队列。从就绪队列进入阻塞队列可能是因为它请求的资源被别人占据了。一个在阻塞队列中的进程被系统取消大概不会发生什么事。进程释放资源之后，其他等待资源的进程大概会被唤醒（见之后的信号量实现）。

### 简答题
**请给出程序正确性的定义或解释。**

程序正确性的定义：程序执行的结果是实现预期的功能，并且是确定的和可重现的。

我们只能在确定的限制条件下来讨论“正确性”的定义或解释，没有无条件的“正确”。

虽然这个我并不知道“确定的限制条件”到底有多确定。那么，shuffle类算法和基于硬件指令的锁能否判断其正确性呢？那当然也是可以的。

---

**在一个新运行环境中程序行为与原来的预期不一致，是错误吗？**

如果预期行为包括明确的运行环境的限定，这就不是错误；否则就是错误的。（很有道理。）

---

**程序并发执行有什么好处和障碍？**

好处：
* 共享资源
* 加速处理
* 方便管理：模块化
障碍：
* 会出现各种同步互斥问题

---

**什么是原子操作？**

原子操作是指一次不存在任何中断或失败的操作，要么操作成功完成，要么操作没有执行，不会出现部分执行的状态。

---

**家庭采购中的同步问题的5种解决方案的核心思路是什么？举例描述可能的漏洞。**

思路的关键点：有人去买，不会重复买；合理的枚举分类。方案的具体内容见课堂内容概述。

* 方案一：先检查，后加相同的标签；漏洞是可能重复采购；
* 方案二：先加相同的标签，后检查；漏洞是会出现没人去买的情况；
* 方案三：先加不同的标签，后检查；漏洞是会出现没人去买的情况；
* 方案四：先加不同的标签，后进行非对称检查；经枚举判断，结果是不会出现漏洞；
* 方案五：原子操作，不会出现漏洞。

---

**家庭采购中的同步问题与操作系统中进程同步有什么区别？**

* 操作系统的进程切换比人的操作切换快；
* 操作系统的进程对外界环境的感知手段比人少。

这两点是非常好的概括了。简单来说，以方案三为例：如果两个人要同时在冰箱上贴便笺，他们同时贴了便笺后检查发现有对方的便笺便不再去买面包这一点在现实生活中是不太可能发生的……两个人的动作是真正的“并行”，冰箱门（至少对两个人来说）也是真正的“共享资源”，不需要互斥访问。

---

**如何通过枚举和分类方法检查同步算法的正确性？**

合理定义枚举分类标准是检查同步算法正确性的关键。

不过最简单的一种方法就是枚举不同状态下在不同位置打断算法的后果。

---

**尝试描述方案四的正确性。**

方案四的代码：
```
leave note_1;
while (note_2) {
    do nothing;
}
if (no bread) {
    buy bread;
}
remove note_1;

leave note_2;
if (no note_1) {
    if (no bread) {
        buy bread;
    }
}
remove note_2;
```

依据谁先加标签和加第二个标签的时间进行情况划分。
* 进程1先加便笺1
  * 如果加完便笺1就被打断，则进程2留下便笺2后会发现已有便笺1，不会进入关键区，并取回便笺2
  * 之后检查是否有进程2的便笺2；如果有，说明进程2正在准备进入关键区，于是进程1**自旋等待**
  * 在关键区中，如果被打断，则进程2会发现已有便笺1，不会进入关键区，并取回便笺2
* 进程2先加便笺2
  * 如果加完便笺2就被打断，则进程1留下便笺1后会发现已有便笺2，不会进入关键区，并取回便笺1
  * 之后检查是否有进程1的便笺1；如果有，说明进程1正在准备进入关键区，于是进程2**取回便笺2并放弃控制权**
  * 在关键区中，如果被打断，则进程1会发现已有便笺2，不会进入关键区，并取回便笺1

---

**举例说明，互斥、死锁和饥饿的定义是什么？**

* 互斥：一个进程占用资源，其它进程不能使用
* 死锁：多个进程各占用部分资源，形成循环等待
  * 如A占有资源1，请求资源2；B占有资源2，请求资源1；结果A和B都无法继续向下执行了
* 饥饿：其他进程可能轮流占用资源，一个进程一直得不到资源
  * 常见于优先级低的进程；类似于进程调度中公平性没有得到保证的情况，不过从时间片资源扩展了

---

**什么是临界区？**

操作临界资源的互斥执行代码片段。（虽然我们一般会写成操作共享资源的代码片段……）

---

**临界区的访问规则是什么？**
* 空闲则入：如果当前没有其他进程位于临界区中，则可以进入临界区
* 忙则等待：如果已经有其他进程进入临界区，则等待其他进程退出
* 有限等待：等待其他进程的时间应该是有限的；这也就意味着，自旋锁的实现方法需要抢占式的调度器，否则将会无限等待下去
* 让权等待（可选）：不能进入临界区的进程应释放CPU（如转换到阻塞状态）；类似于条件变量等待队列的实现

---

**禁用中断是如何实现对临界区的访问控制的？有什么优缺点？**

禁用中断可以阻止其他进程对临界区访问进程的打断。

优点是简单；缺点是无法中断，临界区代码故障可以导致系统崩溃，其他进程可能出现饥饿。

事实上，最近的讨论（在查看Intel手册之后）表明，禁用中断并不能阻止其他进程打断临界区进程，因为将EFLAGS的IF位置零只能禁用可屏蔽的外部中断；而INT系统调用甚至不是中断，而是异常，所以无法屏蔽。所以禁用中断没意义，还是得自己用TS指令实现互斥锁。

---

**Test&Set原子操作是否可以实现Exchange原子操作? Exchange原子操作是否可以实现Test&Set原子操作?**

这两条指令在实现原子操作的功能上是等价的。

17.4 基于软件的同步方法
软件同步方法中的5种解决方案（三种尝试方案、Peterson算法和Eisenberg算法）的核心思路是什么？举例描述可能的漏洞。
方案一：turn 表示允许进入临界区的线程标识； 方案漏洞：交替进入临界区；

方案二：flag[i] 表示线程i是否在临界区； 先判断，后修改变量； 方案漏洞：并发判断后，可能出现同时进入临界区；

方案二：flag[i] 表示线程i想要进入临界区； 先修改变量，后判断； 方案漏洞：并发修改变量后，可能出现都无法进入临界区的情况；

Peterson算法：turn 表示进入临界区的线程标识，flag[i] 表示线程i想要进入临界区； 先修改变量，后判断；后修改者等待； 只适用于两个进程； 方案正确性枚举判断：按写变量的顺序进行情况分类

Eisenberg算法：flag[i] 表示线程i想要进入临界区，turn 表示进入临界区的线程标识（有多个想进入时）； 进入区：先修改flag，后判断是否有多个想进入；后修改者等待； 退出区：修改turn； 适用于多个进程； 方案正确性枚举判断：按写变量flag[i]的顺序和变量turn当前值进行情况分类

尝试通过枚举和分类方法检查Peterson算法的正确性。

尝试准确描述Eisenberg同步算法，并通过枚举和分类方法检查其正确性。

4.下列二线程同步机制是否有误？请给出分析．

CONCEPT: A shared variable named turn is used to keep track of whose turn it is to enter the critical section.
INITIALIZATION:

	shared int turn;
	...
	turn = i ;
ENTRY PROTOCOL (for Process i ):
	/* wait until it's our turn */
	while (turn != i ) {
	}
EXIT PROTOCOL (for Process i ):
	/* pass the turn on */
	turn = j ;
5.下列二线程同步机制是否有误？请给出分析．

CONCEPT: A shared Boolean array named flags contains a flag for each process. The flag values are BUSY when the process is in its critical section (using the resource), or FREE when it is not.
INITIALIZATION:

	typedef char boolean;
	...
	shared boolean flags[n - 1];
	...
	flags[i ] = FREE;
	...
	flags[j ] = FREE;
	...
ENTRY PROTOCOL (for Process i ):
	/* wait while the other process is in its CS */
	while (flags[j ] == BUSY) {
	}
-->
	/* claim the resource */
	flags[i ] = BUSY;
EXIT PROTOCOL (for Process i ):
	/* release the resource */
	flags[i ] = FREE;

6.下列二线程同步机制是否有误？请给出分析．

CONCEPT: Again we use a shared Boolean array as in Algorithm 2. Each process sets its flag before  testing the other flag, thus avoiding the problem of violating mutual exclusion.
INITIALIZATION:

	typedef char boolean;
	...
	shared boolean flags[n -1];
	...
	flags[i ] = FREE;
	...
	flags[j ] = FREE;
	...
ENTRY PROTOCOL (for Process i ):
	/* claim the resource */
	flags[i ] = BUSY;
-->
	/* wait if the other process is using the resource */
	while (flags[j ] == BUSY) {
	}
EXIT PROTOCOL (for Process i ):
	/* release the resource */
	flags[i ] = FREE;
7.下列二线程同步机制是否有误？请给出分析．

CONCEPT: To avoid the deadlock problem of Algorithm 3, we periodically clear and reset our own flag while waiting for the other one.
INITIALIZATION:

	typedef char boolean;
	...
	shared boolean flags[n -1];
	...
	flags[i ] = FREE;
	...
	flags[j ] = FREE;
	...
ENTRY PROTOCOL (for Process i ):
	/* claim the resource */
	flags[i ] = BUSY;
-->
	/* wait if the other process is using the resource */
	while (flags[j ] == BUSY) {
		flags[i ] = FREE;
		delay a while ;
		flags[i ] = BUSY;
	}
EXIT PROTOCOL (for Process i ):
	/* release the resource */
	flags[i ] = FREE;

8.下列二线程同步机制是否有误？请给出分析．

CONCEPT: Both the turn variable and the status flags are combined in a way which we (the requesting process) set our flag and then check our neighbor's flag.

INITIALIZATION:

	typedef char boolean;
	...
	shared boolean flags[n -1];
	shared int turn;
	...
	turn = i ;
	...
	flags[i ] = FREE;
	...
	flags[j ] = FREE;
	...
ENTRY PROTOCOL (for Process i ):
	/* claim the resource */
	flags[i ] = BUSY;

	/* wait if the other process is using the resource */
	while (flags[j ] == BUSY) {

		/* if waiting for the resource, also wait our turn */
		if (turn != i ) {

			/* but release the resource while waiting */
			flags[i ] = FREE;
			while (turn != i ) {
			}
			flags[i ] = BUSY;
		}

	}
EXIT PROTOCOL (for Process i ):
	/* pass the turn on, and release the resource */
	turn = j ;
	flags[i ] = FREE;

9.下列二线程同步机制是否有误？请给出分析．

CONCEPT: Both the turn variable and the status flags are used.

INITIALIZATION:

	typedef char boolean;
	...
	shared boolean flags[n -1];
	shared int turn;
	...
	turn = i ;
	...
	flags[i ] = FREE;
	...
	flags[j ] = FREE;
	...
ENTRY PROTOCOL (for Process i ):
	/* claim the resource */
	flags[i ] = BUSY;

	/* give away the turn */
	turn = j ;
	/* wait while the other process is using the resource *and* has the turn */
	while ((flags[j ] == BUSY) && (turn != i )) {
	}
EXIT PROTOCOL (for Process i ):
	/* release the resource */
	flags[i ] = FREE;

10.下列N线程同步机制是否有误？请给出分析．

CONCEPT: The turn variable and status flags are used as in Dekker's algorithm for the 2-process case. The flags now have three possible values: WAITING for a process in the entry protocol, waiting for the resource' ACTIVE for a process in the critical section, using the resource; and IDLE for other cases.

Process priority is maintained in circular order beginning with the one holding the turn. Each process begins the entry protocol by scanning all processes from the one with the turn up to itself. These are the only processes that might have to go first if there is competition.

If the scan finds all processes idle, the process advances tentatively to the ACTIVE state. However, it is still possible that another process which started scanning later but belongs before us will also reach this state. We check one more time to be sure there are no active processes.

INITIALIZATION:

	shared enum states {IDLE, WAITING, ACTIVE} flags[n -1];
	shared int turn;
	int index;	/* not shared! */
	...
	turn = 0;
	...
	for (index=0; index<n; index++) {
		flags[index] = IDLE;
	}
ENTRY PROTOCOL (for Process i ):

	repeat {

		/* announce that we need the resource */
		flags[i] = WAITING;

		/* scan processes from the one with the turn up to ourselves. */
		/* repeat if necessary until the scan finds all processes idle */
		index = turn;
		while (index != i) {
			if (flag[index] != IDLE) index = turn;
			else index = index+1 mod n;
		}

		/* now tentatively claim the resource */
		flags[i] = ACTIVE;

		/* find the first active process besides ourselves, if any */
		index = 0;
		while ((index < n) && ((index == i) || (flags[index] != ACTIVE))) {
			index = index+1;
		}

	/* if there were no other active processes, AND if we have the turn
	   or else whoever has it is idle, then proceed.  Otherwise, repeat
	   the whole sequence. */
	} until ((index >= n) && ((turn == i) || (flags[turn] == IDLE)));

	/* claim the turn and proceed */
	turn = i;
EXIT PROTOCOL (for Process i ):

	/* find a process which is not IDLE */
	/* (if there are no others, we will find ourselves) */
	index = turn+1 mod n;
	while (flags[index] == IDLE) {
		index = index+1 mod n;
	}

	/* give the turn to someone that needs it, or keep it */
	turn = index;

	/* we're finished now */
	flag[i] = IDLE;

11.下列N线程同步机制是否有误？请给出分析．

CONCEPT: Both status values and turn values are used. The status array is expanded to an integer value for each process, which is used to track that process' progress in scanning the status of other processes. The turn value is also expanded to an integer array. Its values represent the relative ordering for each pair of processes.


INITIALIZATION:

shared int flags[NUMPROCS];
shared int turn[NUMPROCS - 1];
int index;

for (index = 0; index < (NUMPROCS); index++) {

	flags[index] = -1
}


for (index = 0; index < (NUMPROCS-1); index++) {
	turn[index] = 0;
}

ENTRY PROTOCOL (for Process i):
/* repeat for all partners */
for (count = 0; count < (NUMPROCS-1); count++) {

	flags[i] = count;
	turn[count] = i;

	"wait until (for all k != i, flag[k]<count) or (turn[count] != i)"

}

EXIT PROTOCOL (for Process i):
/* tell everyone we are finished */
flags[i] = -1;
12.下列N线程同步机制是否有误？请给出分析．

CONCEPT: A process waiting to enter its critical section chooses a number. This number must be greater than all other numbers currently in use. There is a global shared array of current numbers for each process. The entering process checks all other processes sequentially, and waits for each one which has a lower number. Ties are possible; these are resolved using process IDs.

INITIALIZATION:

	typedef char boolean;
	...
	shared boolean choosing[n]
	shared int num[n];
	...
	for (j=0; j < n; j++) {
		num[j] = 0;
	}
	...
ENTRY PROTOCOL (for Process i):
	/* choose a number */
	choosing[i] = TRUE;
	num[i] = max(num[0], ..., num[n-1]) + 1;
	choosing[i] = FALSE;

	/* for all other processes */
	for (j=0; j < n; j++) {

		/* wait if the process is currently choosing */
		while (choosing[j]) {}

		/* wait if the process has a number and comes ahead of us */
		if ((num[j] > 0) &&
		  ((num[j] < num[i]) ||
		  (num[j] == num[i]) && (j < i))) {
			while (num[j] > 0) {}
		}
	}

EXIT PROTOCOL (for Process i):
	/* clear our number */
	num[i] = 0;
13.(spoc)基于“python, ruby, C, C++，LISP、JavaScript”等语言模拟实现Eisenberg同步算法，并给出覆盖所有枚举分类的测试用例，在实现报告写出设计思路和测试结果分析。

17.5 高级抽象的同步方法
如何证明TS指令和交换指令的等价性？
利用一条指令来实现另一条指令的功能；

自旋锁（spinlock）和无忙等待锁是如何实现同步的？它们有什么不同？
自旋锁是基于TS指令实现同步的，进入区的等待是占用CPU的；

无忙等待锁是在自旋锁的基础上加一个等待队列和进程切换，进入区的等待是不占用CPU的；

为什么硬件原子操作指令能简化同步算法的实现？
原子操作指令是硬件实现的，与进程数目无关；

缺点是，等待时占用CPU，可能出现饥饿和死锁

### 实践题
