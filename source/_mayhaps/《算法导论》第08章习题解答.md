---
title: 《算法导论》第08章习题解答
urlname: introduction-to-algorithms-chapter-08-solutions
toc: true
mathjax: true
date: 2018-07-02 21:35:25
tags: [CLRS]
---

## Exercises
### 8.1
#### 8.1-1

What is the smallest possible depth of a leaf in a decision tree for a comparison sort?

---

为了说明一个序列是有序的，至少需要n-1次比较（依次比较每两个相邻的元素）。因此决策树的叶结点的最小深度应该是n-1。

#### 8.1-2

Obtain asymptotically tight bounds on $\lg{(n!)}$ without using Stirling’s approximation. Instead, evaluate the summation $\sum_{k=1}^{n} \lg{k}$ using techniques from Section A.2.

---

A.2.中介绍了如下几种确定算法的运行时间的和的界：
* 数学归纳法
* 确定级数中各项的界
* 分割求和
* 通过积分求和的近似

不妨假设$n$是2的倍数。

$$\sum_{k=1}^{n} \lg{k} \\\\ = \sum_{k=1}^{n/2} \lg{k} + \sum_{k=n/2+1}^{n} \lg{k} \\\\ > (\frac{n}{2} - 1)\lg{2} + \frac{n}{2} \lg{\frac{n}{2}} \\\\ = \frac{n}{2}\lg{2} - \lg{2} + \frac{n}{2}\lg{n} - \frac{n}{2}\lg{2} \\\\= \frac{n}{2}\lg{n} - \lg{2} \\\\ = \Theta(n \lg{n})$$

因此$\sum_{k=1}^{n} \lg{k} = \Omega(n \lg{n})$。

#### 8.1-3

Show that there is no comparison sort whose running time is linear for at least half of the $n!$ inputs of length n. What about a fraction of $1/n$ of the inputs of length n? What about a fraction $1/2^n$?

#### 8.1-4

Suppose that you are given a sequence of n elements to sort. The input sequence consists of $n/k$ subsequences, each containing $k$ elements. The elements in a given subsequence are all smaller than the elements in the succeeding subsequence and larger than the elements in the preceding subsequence. Thus, all that is needed to sort the whole sequence of length $n$ is to sort the $k$ elements in each of the $n/k$ subsequences. Show an $\Omega(n \lg{k})$ lower bound on the number of comparisons needed to solve this variant of the sorting problem. (Hint: It is not rigorous to simply combine the lower bounds for the individual subsequences.)

### 8.2
#### 8.2-1
Using Figure 8.2 as a model, illustrate the operation of COUNTING-SORT on the array $A = \langle 6, 0, 2, 0, 1, 3, 4, 6, 1, 3, 2 \rangle$.

#### 8.2-2
Prove that COUNTING-SORT is stable.

#### 8.2-3
Suppose that we were to rewrite the `for` loop header in line 10 of the COUNTINGSORT as

`10  for j = 1 to A.length`

Show that the algorithm still works properly. Is the modified algorithm stable?

#### 8.2-4
Describe an algorithm that, given n integers in the range 0 to k, preprocesses its input and then answers any query about how many of the n integers fall into a range $[a..b]$ in $O(1)$ time. Your algorithm should use $\Theta(n + k)$ preprocessing time.

### 8.3

#### 8.3-1
Using Figure 8.3 as a model, illustrate the operation of RADIX-SORT on the following list of English words: COW, DOG, SEA, RUG, ROW, MOB, BOX, TAB, BAR, EAR, TAR, DIG, BIG, TEA, NOW, FOX.

#### 8.3-2
Which of the following sorting algorithms are stable: insertion sort, merge sort, heapsort, and quicksort? Give a simple scheme that makes any sorting algorithm stable. How much additional time and space does your scheme entail?

#### 8.3-3
Use induction to prove that radix sort works. Where does your proof need the assumption that the intermediate sort is stable?

#### 8.3-4
Show how to sort n integers in the range 0 to $n^3 - 1$ in $O(n)$ time.

#### 8.3-5
In the first card-sorting algorithm in this section, exactly how many sorting passes are needed to sort d-digit decimal numbers in the worst case? How many piles of cards would an operator need to keep track of in the worst case?

### 8.4
#### 8.4-1
Using Figure 8.4 as a model, illustrate the operation of BUCKET-SORT on the array $A = \langle 0.79, 0.13, 0.16, 0.64, 0.39, 0.20, 0.89, 0.53, 0.71, 0.42 \rangle$.

#### 8.4-2
Explain why the worst-case running time for bucket sort is $\Theta(n^2)$. What simple change to the algorithm preserves its linear average-case running time and makes its worst-case running time $O(n \lg{n})$?

#### 8.4-3
Let $X$ be a random variable that is equal to the number of heads in two flips of a fair coin. What is $E[X^2]$? What is $E^2[X]$?

#### 8.4-4
We are given n points in the unit circle, $p_i = (x_i, y_i)$, such that $0 < x_i^2 + y_i^2 \leq 1$ for $i = 1, 2, \cdots, n$. Suppose that the points are uniformly distributed; that is, the probability of finding a point in any region of the circle is proportional to the area of that region. Design an algorithm with an average-case running time of $\Theta(n)$ to sort the $n$ points by their distances $d_i = \sqrt{x_i^2 + y_i^2}$ from the origin. (Hint: Design the bucket sizes in BUCKET-SORT to reflect the uniform distribution of the points in the unit circle.)

#### 8.4-5
A *probability distribution function* $P(x)$ for a random variable $X$ is defined by $P(x) = Pr{X \leq x}$. Suppose that we draw a list of n random variables $X_1, X_2, \cdots X_n$ from a continuous probability distribution function $P$ that is computable in $O(1)$ time. Give an algorithm that sorts these numbers in linear averagecase time.
