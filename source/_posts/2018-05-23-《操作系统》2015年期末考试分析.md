---
title: 《操作系统》2015年期末考试分析
urlname: os-mooc-2015-final-exam-analysis
toc: true
date: 2018-05-23 01:36:22
updated: 2018-05-23 01:36:22
tags: OS
---

试题来自[]()。这个卷子实在过于长了，不仅莫名有一个完整的缓冲区问题的实现，还有一堆ucore代码需要阅读和填空。

## 一（10分）

在用`do_execve`启动一个用户态进程时，ucore需要完成很多准备工作，这些工作有的在内核态完成，有的在用户态完成。请判断下列事项是否是ucore在正常完成`do_execve`中所需要的，如果是，指出它完成于内核态还是用户态（通过修改`trapframe`，在`iret`时改变寄存器的过程被认为是在内核态完成）。

1. 初始化进程所使用的栈
2. 在栈上准备argc和argv的内容
3. 将argc和argv作为用户main函数的参数放到栈上
4. 设置EIP为用户main函数的地址
5. 设置系统调用的返回值

---

1. 需要；内核态
2. 需要；内核态
3. <del>需要；内核态</del>不需要；用户态
4. <del>需要；内核态</del>不需要；用户态
5. 不需要

这个题出的很没有意义啊，系统调用返回之后几乎就要立即跳转到用户进程指令的第一条了。

以下内容摘自ucore docs Lab5：
> 最终通过`do_execve`函数来完成用户进程的创建工作。此函数的主要工作流程如下：
* 首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。由于此处的initproc是内核线程，所以mm为NULL，整个处理都不会做。
* 接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。load_icode函数完成了整个复杂的工作。
……
load_icode函数的工作：
1. 初始化mm
2. 分配和设置页目录表
3. 解析ELF文件，建立vma，初始化进程的用户态虚拟地址空间
4. 分配物理内存空间，建立页表映射关系，拷贝程序内容
5. 设置用户栈
6. 将页目录表基地址加载到CR3寄存器中
7. 重设进程中断帧，准备切换到用户态
至此，用户进程的用户环境已经搭建完毕。此时initproc将按产生系统调用的函数调用路径原路返回，执行中断返回指令“iret”（位于trapentry.S的最后一句） 后，将切换到用户进程hello的第一条语句位置_start处（位于user/libs/initcode.S的第三句） 开始执行。

2018.5.25 UPD：
tsz同学指出，事实上这道题和第六大题的代码内容直接相关。从中可以看出，`user/libs/initcode.S`做的就是在用户态为`main`函数设置参数的工作。所以3和4的答案应该修改一下。事实证明，想当然是不好的。

## 二 VSFS（18分）

这道题和[MOOC期末考试题](/post/os-mooc-final-exam-analysis)中的第20题一模一样，所以略。

## 三 进程状态变化（16分）

在ucore中`enum proc_state`的定义包含以下四个值：
* `PROC_UNINIT`
* `PROC_SLEEPING`
* `PROC_RUNNABLE`
* `PROC_ZOMBIE`
请解释每一种状态的含义，以及各状态之间可能的迁移。

---

* `PROC_UNINIT`：刚申请完进程控制块，进程还未被初始化
* `PROC_SLEEPING`：进程处于等待状态
* `PROC_RUNNABLE`：进程处于就绪或运行状态
* `PROC_ZOMBIE`：僵尸状态，进程已经退出，等待父进程进一步回收资源

以下内容（进程的正常生命周期）摘自ucore docs Lab6：
> 进程的正常生命周期如下：
* 进程首先在cpu初始化或者`sys_fork`的时候被创建，当为该进程分配了一个进程控制块之后，该进程进入`uninit`态(在`proc.c`中`alloc_proc`)。
* 当进程完全完成初始化之后，该进程转为`runnable`态。
* 当到达调度点时，由调度器`sched_class`根据运行队列`rq`的内容来判断一个进程是否应该被运行，即把处于`runnable`态的进程转换成`running`状态，从而占用CPU执行。
* `running`态的进程通过`wait`等系统调用被阻塞，进入`sleeping`态。
* `sleeping`态的进程被`wakeup`变成`runnable`态的进程。
* `running`态的进程主动`exit`变成`zombie`态，然后由其父进程完成对其资源的最后释放，子进程的进程控制块成为`unused`。
* 所有从`runnable`态变成其他状态的进程都要出运行队列，反之，被放入某个运行队列中。

以下内容摘自[进程运行状态转变过程](https://chyyuu.gitbooks.io/simple_os_book/content/zh/chapter-4/process_status_change.html)：

```
process state changing:

  alloc_proc                                 RUNNING
      +                                   +--<----<--+
      +                                   + proc_run +
      V                                   +-->---->--+
PROC_UNINIT -- proc_init/wakeup_proc --> PROC_RUNNABLE -- try_free_pages/do_wait/do_sleep --> PROC_SLEEPING --
                                           A      +                                                           +
                                           |      +--- do_exit --> PROC_ZOMBIE                                +
                                           +                                                                  +
                                           -----------------------wakeup_proc----------------------------------
```

## 四 Stride调度算法（15分）

假设在lab6测试stride scheduling的过程中，采用如下默认配置：BigStride为0x7FFFFFFF，CPU时间片为50ms，测试过程包含五个进程，其初始<del>stride</del>pass均为1，优先级分别为1、2、3、4、5，测试时间为10s。下面给出了五种修改上述配置的方式，试讨论：对于每一种改动，测试结果相比改动之前是否会发生明显的变化？如果是，结果会变得更接近于理想情况，还是远离理想情况？

1. BigStride改为120
2. CPU时间片改为5ms
3. 五个进程的初始pass改为100
4. 五个进程的优先级设为2、4、6、8、10
5. 测试时间延长到20s

---

在测试时间10s的情况下，时间片总个数为200。

1. 如果将BigStride改为120，则stride最大为120，不会溢出，而且120能够整除1、2、3、4、5，更能够保证进程的pass按优先级推进，因此会更接近于理想情况
2. 时间片总个数变成2000，因为进程stride有偏差，因此会远离理想情况
3. 因为100这个值相比各个进程的stride太小了，所以应该不会有明显变化
4. 不会有明显变化
5. 同2，更远离理想情况

这个题目中不同学长的答案大相径庭，所以我选了一种我觉得合理的。事实上，Stride调度算法的论文中讨论了一下误差问题：在stride和优先级精确地成反比的情况下，各个线程之间按比例分配到的时间片数量的误差不超过1，也就是说，总误差是O(nc)（nc是线程数量）。所以大概stride计算不准确造成的影响是比较大的。

## 五 生产者-消费者问题（10分）

生产者-消费者问题是指，一组生产者进程和一组消费者进程共享一个初始为空、大小为3（不如说是BUFFER_SIZE）的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个生产者放入消息，或者一个消费者从中取出消息。

下面是生产者-消费者问题的一个实现和测试结果。请回答下面问题：
1. 请用伪码给出信号量的PV操作实现。
2. 这个实现正确吗？如果不正确，给出你的正确实现。
3. 这两个测试用例能发现该实现中的可能错误吗？如果不能，请给出你的尽可能完整的测试用例。

```
==== producer-consumer.cpp ====
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#include <cstring>
#include <unistd.h>
#include <string>
#include <cstdlib>
#include <new> // ::operator new[]

using namespace std;

#define BUFFER_SIZE 3
#define SLEEP_SPAN 5
#define WORK_SPAN 4

#define PRODUCER 0
#define CONSUMER 1

int iflag = 0;
int oflag = 0;
sem_t empty, full, mutex;
int empty_count, full_count;
int data_num = 0;
int num = 0;

int buffer[BUFFER_SIZE] = {};

int p_task_done = -1;
int c_task_done = -1;

struct arg_struct {
    arg_struct(int _id, int _start, int _work, string _indent): id(_id), start(_start), work(_work), indent(_indent) {}
    arg_struct(int _id): id(_id), start(0), work(0), indent(string("")) {}
    int id;
    int start;
    int work;
    string indent;
};

void* producer(void* argv){
    arg_struct arg = *(arg_struct*)argv;
    int id = arg.id;
    const char* indent = arg.indent.c_str();

    sleep(arg.start);

    printf("%sSTART\n", indent);

    sem_wait(&mutex);  /* 顺序错了 */
    printf("%saMUTEX\n", indent);

    sem_wait(&empty);  /* 顺序错了 */
    printf("%saEMPTY\n", indent);

    printf("%sENTER\n", indent);

    int time = rand() % SLEEP_SPAN;
    sleep(arg.work);

    p_task_done++;
    printf("%sProd %d\n", indent, p_task_done);

    buffer[iflag] = p_task_done;

    if (empty_count == 0) printf("Error: Produce while no empty\n");
    iflag = (iflag + 1) % BUFFER_SIZE;
    empty_count--;
    full_count++;

    printf("%sEXIT\n", indent);

    sem_post(&mutex);
    printf("%srMUTEX\n", indent);

    sem_post(&full);
    printf("%srFULL\n", indent);

    return NULL;
}

void* consumer(void* argv){
    arg_struct arg = *(arg_struct*)argv;
    int id = arg.id;
    const char* indent = arg.indent.c_str();

    sleep(arg.start);

    printf("%sSTART\n", indent);
    sem_wait(&full);
    printf("%saFULL\n", indent);

    sem_wait(&mutex);
    printf("%saMUTEX\n", indent);

    printf("%sENTER\n", indent);

    sleep(arg.work);

    ++c_task_done;
    if (full_count == 0) printf("Error: Consume while no full\n");

    int tmp = buffer[oflag];
    printf("%sCons %d\n", indent, tmp);

    oflag = (oflag + 1) % BUFFER_SIZE;
    if (c_task_done != tmp) printf("Error: Consume data wrong\n");
    if (c_task_done > p_task_done) printf("Error: Over-consume!\n");

    full_count--;
    empty_count++;

    printf("%sEXIT\n", indent);

    sem_post(&mutex);
    printf("%srMUTEX\n", indent);

    sem_post(&empty);
    printf("%srEMPTY\n", indent);

    return NULL;
}

#define N 3
void testcase_producer_consumer(int ThreadNumber, int inst[2 * N][3]) {
    pthread_t * p_consumer = new pthread_t[ThreadNumber];
    pthread_t * p_producer = new pthread_t[ThreadNumber];

    int c_count = 0, p_count = 0;

    printf("testcase_producer_consumer:\n");
    /* For managed creation of 'ThreadNumber' threads */
    int st_time = 0;
    /* Print the first line */
    int tmp_c = 0, tmp_p = 0;
    for (int i = 0; i < ThreadNumber; i++) {
        if (inst[i][0] == PRODUCER) {
            printf("P%d\t", tmp_p++);
        } else if (inst[i][0] == CONSUMER) {
            printf("C%d\t", tmp_c++);
        }
    }
    printf("\n");

    /* Create Producers and Consumers according to $inst*/
    int rc;
    string indent("");
    for (int i = 0; i < ThreadNumber; i++) {
        if (inst[i][0] == PRODUCER)  {
            rc = pthread_create(p_producer + p_count, NULL, producer, new arg_struct(p_count, inst[i][1],
            inst[i][2], indent));
            if (rc) printf("ERROR\n");
            p_count++;
        } else if (inst[i][0] == CONSUMER){
            rc = pthread_create(p_consumer + c_count, NULL, consumer, new arg_struct(c_count, inst[i][1],             inst[i][2], indent));
            if (rc) printf("ERROR\n");
            c_count++;
        }
        indent += '\t';
    }

    /* wait until every thread finishes*/
    for (int i = 0; i < p_count; i++) {
        pthread_join(p_producer[i], NULL);
    }

    for (int i = 0; i < c_count; i++) {
        pthread_join(p_consumer[i], NULL);
    }

    delete[] p_producer;
    delete[] p_consumer;
}

int main(int argc, char** argv) {
    srand((unsigned)time(NULL));

    memset(buffer, 0, sizeof(int) * BUFFER_SIZE);

    sem_init(&mutex, 0, 1);
    sem_init(&empty, 0, BUFFER_SIZE);
    sem_init(&full, 0, 0);

    empty_count = BUFFER_SIZE;
    full_count = 0;

    /* For managed creation of 2 * N threads */
    int ThreadNumber = 2 * N ;
    int st_time = 0;
    int inst[2 * N][3] = {
        /* { Consumer or Producer to be create?,
        When does it start to work after being created?, st_stime += N means it starts N seconcds later than the previous P/C
        How long does it work after it enters critical zone? } */
        {CONSUMER, st_time += 0, 2},
        {CONSUMER, st_time += 1, 2},
        {CONSUMER, st_time += 2, 2},
        {PRODUCER, st_time += 3, 2},
        {PRODUCER, st_time += 4, 2},
        {PRODUCER, st_time += 5, 2}
    };
    testcase_producer_consumer(ThreadNumber, inst);
    st_time = 0;

    int inst2[2 * N][3] = {
        {PRODUCER, st_time += 0, 2},
        {PRODUCER, st_time += 1, 2},
        {CONSUMER, st_time += 2, 2},
        {CONSUMER, st_time += 3, 2},
        {PRODUCER, st_time += 4, 2},
        {CONSUMER, st_time += 5, 2}
    };
    testcase_producer_consumer(ThreadNumber, inst2);
    return 0;
}
```

测试用例的执行输出结果：
```
xyong@ubuntu-xyong:~/work$ gcc producer-consumer.cpp -lpthread -lstdc++
xyong@ubuntu-xyong:~/work$ ./a.out
testcase_producer_consumer:
C0    C1    C2    P0    P1    P2
START
      START
            START
                  START
                  aMUTEX
                  aEMPTY
                  ENTER
                  Prod 0
                  EXIT
                  rMUTEX
                  rFULL
aFULL
aMUTEX
ENTER
                        START
Cons 0
EXIT
                        aMUTEX
                        aEMPTY
                        ENTER
rMUTEX
rEMPTY
                        Prod 1
                        EXIT
                        rMUTEX
                        rFULL
      aFULL
      aMUTEX
      ENTER
      Cons 1
      EXIT
      rMUTEX
      rEMPTY
                        START
                        aMUTEX
                        aEMPTY
                        ENTER
                        Prod 2
                        EXIT
                        rMUTEX
                        rFULL
            aFULL
            aMUTEX
            ENTER
            Cons 2
            EXIT
            rMUTEX
            rEMPTY

testcase_producer_consumer:
P0    P1    C0    C1    P2    C2
START
aMUTEX
aEMPTY
ENTER
      START
Prod 3
EXIT
rMUTEX
rFULL
      aMUTEX
      aEMPTY
      ENTER
            START
            aFULL
      Prod 4
      EXIT
      rMUTEX
      rFULL
            aMUTEX
            ENTER
                  START
                  aFULL
            Cons 3
            EXIT
            rMUTEX
            rEMPTY
                  aMUTEX
                  ENTER
                  Cons 4
                  EXIT
                  rMUTEX
                  rEMPTY
                        START
                        aMUTEX
                        aEMPTY
                        ENTER
                        Prod 5
                        EXIT
                        rMUTEX
                        rFULL
                              START
                              aFULL
                              aMUTEX
                              ENTER
                              Cons 5
                              EXIT
                              rMUTEX
                              rEMPTY
xyong@ubuntu-xyong:~/work$
```

---

这道题真是又臭又长……

信号量PV操作的伪代码：这个是十分简单了。
```
P() {
    sem--;
    if (sem < 0) {
        Add this thread t to q;
        block(p);
    }
}

V() {
    sem++;
    if (sem <= 0) {
        Remove a thread t from q;
        wakeup(t);
    }
}
```

这个实现是否正确？答案是不正确。producer线程的实现中获取`mutex`和`empty`信号量的顺序反了。总的来说，把这两个换一下就好了。

题目中给出的两个测试样例是这样的：
```
int inst[2 * N][3] = {
    /* { Consumer or Producer to be create?,
    When does it start to work after being created?, st_stime += N means it starts N seconcds later than the previous P/C
    How long does it work after it enters critical zone? } */
    {CONSUMER, st_time += 0, 2},
    {CONSUMER, st_time += 1, 2},
    {CONSUMER, st_time += 2, 2},
    {PRODUCER, st_time += 3, 2},
    {PRODUCER, st_time += 4, 2},
    {PRODUCER, st_time += 5, 2}
};

int inst2[2 * N][3] = {
    {PRODUCER, st_time += 0, 2},
    {PRODUCER, st_time += 1, 2},
    {CONSUMER, st_time += 2, 2},
    {CONSUMER, st_time += 3, 2},
    {PRODUCER, st_time += 4, 2},
    {CONSUMER, st_time += 5, 2}
};
```

我给出的测试样例是这样的：
```
int inst2[2 * N][3] = {
    {PRODUCER, st_time += 0, 2},
    {PRODUCER, st_time += 1, 2},
    {PRODUCER, st_time += 2, 2},
    {PRODUCER, st_time += 3, 2},
    {CONSUMER, st_time += 4, 2},
    {CONSUMER, st_time += 5, 2}
};
```

题目中并没有要求Producer和Consumer的数量必须为3个。从理论上来说，只要Producer比Consumer大的个数在3个（也就是缓冲区的大小）以内，都能正常结束。但是在错误实现中会发生这样的问题：P1-P3生产完之后，P4获得`mutex`后开始在`empty`信号量上等待。但是，由于它占据了`mutex`，因此C1和C2无法进入临界区进行消费，于是也不会对`empty`信号量执行V操作，发生死锁。

## 六 ucore用户进程（16分）

下面是关于ucore中用户程序的生命历程的代码。请完成下面填空和代码补全。

### （1）
在`sh`的命令行上输入`args 1`启动用户程序`args`，则`sh`会调用（__1__）创建新进程并调用（__2__）将`args`加载到该进程的地址空间中。（回答系统调用名称即可）

1. `SYS_fork`
2. `SYS_exec`

---

这一题使我觉得我应该复习一下ucore里的各种系统调用、实现方法及其作用。

### （2）
将`args`从硬盘加载主要由`load_icode`完成，请补全以下代码。

```
// load_icode - called by sys_exec-->do_execve

static int
load_icode(int fd, int argc, char **kargv) {
    /* LAB8:EXERCISE2 YOUR CODE HINT:how to load the file with handler fd in to process's memory? how to setup argc/argv?
    * MACROs or Functions:
    * mm_create - create a mm
    * setup_pgdir - setup pgdir in mm
    * load_icode_read - read raw data content of program file
    * mm_map - build new vma
    * pgdir_alloc_page - allocate new memory for TEXT/DATA/BSS/stack parts
    * lcr3 - update Page Directory Addr Register -- CR3
    */
    /* (1) create a new mm for current process
    * (2) create a new PDT, and mm->pgdir= kernel virtual addr of PDT
    * (3) copy TEXT/DATA/BSS parts in binary to memory space of process
    * (3.1) read raw data content in file and resolve elfhdr
    * (3.2) read raw data content in file and resolve proghdr based on info in elfhdr
    * (3.3) call mm_map to build vma related to TEXT/DATA
    * (3.4) callpgdir_alloc_page to allocate page for TEXT/DATA, read contents in file
    * and copy them into the new allocated pages
    * (3.5) callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages
    * (4) call mm_map to setup user stack, and put parameters into user stack
    * (5) setup current process's mm, cr3, reset pgidr (using lcr3 MARCO)
    * (6) setup uargc and uargv in user stacks
    * (7) setup trapframe for user environment
    * (8) if up steps failed, you should cleanup the env.
    */
    assert(argc >= 0 && argc <= EXEC_MAX_ARG_NUM);

    if (current->mm != NULL) {
        panic("load_icode: current->mm must be empty.\n");
    }

    int ret = -E_NO_MEM;
    struct mm_struct *mm;
    if ((mm = mm_create()) == NULL) {
        goto bad_mm;
    }
    if (setup_pgdir(mm) != 0) {
        goto bad_pgdir_cleanup_mm;
    }

    struct Page *page;

    struct elfhdr __elf, *elf = &__elf;
    /* 2a */
    if ((ret = load_icode_read(fd, elf, _(2a)_, 0)) != 0) {
        goto bad_elf_cleanup_pgdir;
    }

    if (elf->e_magic != ELF_MAGIC) {
        ret = -E_INVAL_ELF;
        goto bad_elf_cleanup_pgdir;
    }

    struct proghdr __ph, *ph = &__ph;
    uint32_t vm_flags, perm, phnum;
    for (phnum = 0; phnum < elf->e_phnum; phnum ++) {
        off_t phoff = elf->e_phoff + sizeof(struct proghdr) * phnum;
        if ((ret = load_icode_read(fd, ph, sizeof(struct proghdr), phoff)) != 0) {
            goto bad_cleanup_mmap;
        }
        if (ph->p_type != ELF_PT_LOAD) {
            /* 2b */
            _(2b)_
        }
        if (ph->p_filesz > ph->p_memsz) {
            ret = -E_INVAL_ELF;
            goto bad_cleanup_mmap;
        }
        if (ph->p_filesz == 0) {
            continue ;
        }
        vm_flags = 0, perm = PTE_U;
        if (ph->p_flags & ELF_PF_X) vm_flags |= VM_EXEC;
        if (ph->p_flags & ELF_PF_W) vm_flags |= VM_WRITE;
        if (ph->p_flags & ELF_PF_R) vm_flags |= VM_READ;
        if (vm_flags & VM_WRITE) perm |= PTE_W;
        if ((ret = mm_map(mm, ph->p_va, ph->p_memsz, vm_flags, NULL)) != 0) {
            goto bad_cleanup_mmap;
        }
        off_t offset = ph->p_offset;
        size_t off, size;
        uintptr_t start = ph->p_va, end, la = ROUNDDOWN(start, PGSIZE);

        ret = -E_NO_MEM;

        end = ph->p_va + ph->p_filesz;
        while (start < end) {
            if ((page = pgdir_alloc_page(mm->pgdir, la, perm)) == NULL) {
                ret = -E_NO_MEM;
                goto bad_cleanup_mmap;
            }
            off = start - la, size = PGSIZE - off, la += PGSIZE;
            if (end < la) {
                size -= la - end;
            }
            if ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != 0) {
                goto bad_cleanup_mmap;
            }
            start += size, offset += size;
        }
        end = ph->p_va + ph->p_memsz;

        if (start < la) {
            /* ph->p_memsz == ph->p_filesz */
            if (start == end) {
                continue ;
            }
            off = start + PGSIZE - la, size = PGSIZE - off;
            if (end < la) {
                size -= la - end;
            }
            memset(page2kva(page) + off, 0, size);
            start += size;
            assert((end < la && start == end) || (end >= la && start == la));
        }
        while (start < end) {
            if ((page = pgdir_alloc_page(mm->pgdir, la, perm)) == NULL) {
                ret = -E_NO_MEM;
                goto bad_cleanup_mmap;
            }
            off = start - la, size = PGSIZE - off, la += PGSIZE;
            if (end < la) {
                size -= la - end;
            }
            memset(page2kva(page) + off, 0, size);
            start += size;
        }
    }
    sysfile_close(fd);

    vm_flags = VM_READ | VM_WRITE | VM_STACK;
    /* 2c */
    if ((ret = mm_map(mm, _(2c)_, USTACKSIZE, vm_flags, NULL)) != 0) {
        goto bad_cleanup_mmap;
    }
    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-PGSIZE , PTE_USER) != NULL);
    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-2*PGSIZE , PTE_USER) != NULL);
    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-3*PGSIZE , PTE_USER) != NULL);
    assert(pgdir_alloc_page(mm->pgdir, USTACKTOP-4*PGSIZE , PTE_USER) != NULL);

    mm_count_inc(mm);
    current->mm = mm;
    current->cr3 = PADDR(mm->pgdir);
    lcr3(PADDR(mm->pgdir));

    //setup argc, argv
    uint32_t argv_size=0, i;
    for (i = 0; i < argc; i ++) {
        argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1;
    }

    uintptr_t stacktop = USTACKTOP - (argv_size/sizeof(long)+1)*sizeof(long);
    char** uargv=(char **)(stacktop - argc * sizeof(char *));

    argv_size = 0;
    for (i = 0; i < argc; i ++) {
        uargv[i] = strcpy((char *)(stacktop + argv_size ), kargv[i]);
        /* 2d */
        _(2d)_
    }

    stacktop = (uintptr_t)uargv - sizeof(int);
    /* 2e */
    *(int *)stacktop = _(2e)_;

    struct trapframe *tf = current->tf;
    memset(tf, 0, sizeof(struct trapframe));
    tf->tf_cs = USER_CS;
    tf->tf_ds = tf->tf_es = tf->tf_ss = USER_DS;
    tf->tf_esp = stacktop;
    tf->tf_eip = elf->e_entry;
    tf->tf_eflags = FL_IF;
    ret = 0;
out:
    return ret;
bad_cleanup_mmap:
    exit_mmap(mm);
bad_elf_cleanup_pgdir:
    put_pgdir(mm);
bad_pgdir_cleanup_mm:
    mm_destroy(mm);
bad_mm:
    goto out;
}
```

1. `sizeof(struct elfhdr)`（读一个`elfhdr`大小的文件数据）
2. `goto bad_cleanup_mmap;`（这个很简单：已经设置了`pgdir`和`mm`了，因此如果失败需要清理；而且周围都是跳转到这里）
3. `USTACKTOP - USTACKSIZE`（这段大概是映射用户栈空间，不过我并不是很明白）
4. `argv_size += strnlen(kargv[i], EXEC_MAX_ARG_LEN + 1) + 1;`（得到当前的参数的长度）
5. `argc`（把argc放到栈顶；之所以是栈顶，是因为gcc是从右向左压栈的）

---

这种默写代码的题目实在是无聊死了。

### （3）

完成加载后会从内核态回到用户态，请补全此时的用户栈图示。（假定为写入部分全部初始化为0，注意使用小尾端）

| 地址 | 内容 |
| --- | --- |
| 0xb0000000 | - |
| 0xaffffffc | 00 31 00 00 |
| 0xaffffff8 | 61 72 67 73 // 'args' |
| 0xaffffff4 | (3a) |
| 0xaffffff0 | (3b) |
| 0xafffffec | (3c) |
| 0xafffffe8 | (3d) |

此时并不会直接进入main函数，而是执行以下代码，请简述其作用。

```
//////// user/libs/initcode.S //////////
.text
.globl _start
_start:
    movl $0x0, %ebp

    movl (%esp), %ebx
    lea 0x4(%esp), %ecx

    subl $0x20, %esp

    pushl %ecx
    pushl %ebx

    call umain
1: jmp 1b

////////// user/libs/umain.c ////////////
#include <ulib.h>
#include <unistd.h>
#include <file.h>
#include <stat.h>
int main(int argc, char *argv[]);
static int
initfd(int fd2, const char *path, uint32_t open_flags) {
    int fd1, ret;
    if ((fd1 = open(path, open_flags)) < 0) {
        return fd1;
    }
    if (fd1 != fd2) {
        close(fd2);
        ret = dup2(fd1, fd2);
        close(fd1);
    }
    return ret;
}

void
umain(int argc, char *argv[]) {
    int fd;
    if ((fd = initfd(0, "stdin:", O_RDONLY)) < 0) {
        warn("open <stdin> failed: %e.\n", fd);
    }
    if ((fd = initfd(1, "stdout:", O_WRONLY)) < 0) {
        warn("open <stdout> failed: %e.\n", fd);
    }
    int ret = main(argc, argv);
    exit(ret);
}
```

---

<!--
恕我直言，我一开始不知道这道题在说什么。大概调用用户程序`args`的时候会有两个参数：`int argc`和`char** argv`，其中`argc = 2`，`argv = ['args', '1']`。

```
//setup argc, argv
uint32_t argv_size=0, i;
for (i = 0; i < argc; i ++) {
    argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1;
}
```
上述内容执行完之后，得到`argv_size = 6`。

```
uintptr_t stacktop = USTACKTOP - (argv_size/sizeof(long)+1)*sizeof(long);
char** uargv=(char **)(stacktop - argc * sizeof(char *));
```

```
argv_size = 0;
for (i = 0; i < argc; i ++) {
	uargv[i] = strcpy((char *)(stacktop + argv_size ), kargv[i]);
	argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1;
}
```

```
stacktop = (uintptr_t)uargv - sizeof(int);
*(int *)stacktop = argc;
```

然后学长答案是这样：

| 地址 | 内容 |
| --- | --- |
| 0xb0000000 | - |
| 0xaffffffc | 00 31 00 00 |
| 0xaffffff8 | 61 72 67 73 // 'args' |
| 0xaffffff4 | fd ff ff ff |
| 0xaffffff0 | f8 ff ff ff |
| 0xafffffec | 02 00 00 00 |
| 0xafffffe8 | 00 00 00 00 |

恕我直言，我也看不懂。
-->

2018.5.25 UPD：（感谢tsz和xzh同学关于此题的讨论）

不妨把填充栈帧的代码段拿出来细看一下。

```
//setup argc, argv
uint32_t argv_size=0, i;
for (i = 0; i < argc; i ++) {
    argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + 1)+1;
}

// 在栈中预留函数参数的位置
uintptr_t stacktop = USTACKTOP - (argv_size/sizeof(long)+1)*sizeof(long);
// 在栈中预留函数参数指针的位置
char** uargv=(char **)(stacktop - argc * sizeof(char *));

argv_size = 0;
for (i = 0; i < argc; i ++) {
    // 从低地址到高地址填各参数指针，顺便把参数内容拷进去
    uargv[i] = strcpy((char *)(stacktop + argv_size ), kargv[i]);
    // argv_size += 长度
    argv_size += strnlen(kargv[i], EXEC_MAX_ARG_LEN + 1) + 1;
}

// 把argc放入栈中
stacktop = (uintptr_t)uargv - sizeof(int);
*(int *)stacktop = argv;
```

事实上，这段代码的目的，就是从栈底到栈顶，依次存参数内容（所有参数拼起来）、各参数的指针（`char **argv`）和argc存进去。实际上，被调用的进程`args`有两个实际参数：进程名`"argc"`和参数`"1"`（注意这两者都是字符串）。于是结果变成了这样：
* 参数`"1\0"`存在`0xaffffffd`开始的2个字节中
* 参数`"args\0"`存在`0xaffffff8`开始的5个字节中
* 参数`"1\0"`所在的地址`0xaffffffd`存在`0xaffffff4`开始的4个字节中（注意大小端）
* 参数`"args\0"`所在的地址`0xaffffff8`存在`0xaffffff0`开始的4个字节中（注意大小端）
* `argc`存放在`0xafffffec`开始的4个字节中（注意大小端）

| 地址 | 内容 | 说明 |
| --- | --- | ----- |
| `0xb0000000` | - | - |
| `0xaffffffc` | `00 31 00 00` | 字符串"1"（和"args"的`\0`） |
| `0xaffffff8` | `61 72 67 73` | 字符串"args" |
| `0xaffffff4` | `fd ff ff af` | "1"的地址 |
| `0xaffffff0` | `f8 ff ff af` | "args"的地址 |
| `0xafffffec` | `02 00 00 00` | `argv = 2` |
| `0xafffffe8` | `00 00 00 00` | - |

后面代码的作用据说是为umain函数压入argc和argv，调整esp，打开stdin/stdout，然后调用main。总之，打开stdin/stdout这个部分我好像看懂了；压入argc和argv的本质就是利用gcc调用了函数。

### （4）
虽然main函数以`return 0;`结束，但此后程序仍在用户态，经过（__4a__）进入内核态，参考`do_exit`代码，其主要完成了页表和文件描述符的释放、设置进程状态和返回值、唤醒等待中的父进程、（__4b__）。（`while`循环部分）

`do_exit`中该进程占用的内存并未完全释放，例如（__4c__），它们将在（__4d__）中被释放。

```
int
do_exit(int error_code) {
	if (current == idleproc) {
    	panic("idleproc exit.\n");
	}
	if (current == initproc) {
		panic("initproc exit.\n");
	}

	struct mm_struct *mm = current->mm;
	if (mm != NULL) {
		lcr3(boot_cr3);
		if (mm_count_dec(mm) == 0) {
			exit_mmap(mm);
			put_pgdir(mm);
			mm_destroy(mm);
		}
		current->mm = NULL;
	}
	put_fs(current); //for LAB8
	current->state = PROC_ZOMBIE;
	current->exit_code = error_code;

	bool intr_flag;
	struct proc_struct *proc;
	local_intr_save(intr_flag);
	{
		proc = current->parent;
		if (proc->wait_state == WT_CHILD) {
			wakeup_proc(proc);
		}
		while (current->cptr != NULL) {
			proc = current->cptr;
			current->cptr = proc->optr;

			proc->yptr = NULL;
			if ((proc->optr = initproc->cptr) != NULL) {
				initproc->cptr->yptr = proc;
			}

			proc->parent = initproc;
			initproc->cptr = proc;
				if (proc->state == PROC_ZOMBIE) {
					if (initproc->wait_state == WT_CHILD) {
						wakeup_proc(initproc);
				}
			}
		}
	}
	local_intr_restore(intr_flag);

	schedule();
	panic("do_exit will not return!! %d.\n", current->pid);
}
```

---

1. `exit`系统调用
2. 把子进程逐个放入initproc的子进程中，如果发现子进程已经为僵尸状态且initproc进入WT_CHILD状态，则唤醒initproc回收子进程
3. 进程控制块
4. 父进程的`do_wait`（或者说被唤醒的执行了wait或wait_pid的父进程）

这道题反而比较简单了。

```
parent:           proc->parent  (proc is children)
children:         proc->cptr    (proc is parent)
older sibling:    proc->optr    (proc is younger sibling)
younger sibling:  proc->yptr    (proc is older sibling)
```

## 七 磁盘调度（15分）

一磁盘逆时针旋转，磁盘有3个磁道和一个磁头，每个磁道有12个扇区。最外侧磁道0包含扇区0~11，中间侧磁道1包含扇区12~23，最内侧磁道包含扇区24~35。如下图所示，可以看到磁头初始位置在外侧磁道的扇区6的中间位置，扇区10与扇区6在一个磁道上。

![磁盘示意图](simple-disk.png)

完成一次磁盘扇区的访问请求时间包括：
* 寻道时间（seek time）
* 旋转时间（rotational time）
* 传输时间（transfer time）

如，ucore发出访问请求序列为['10']，即只有一次对扇区10的访问请求，则磁盘花费的访问请求时间如下：

```
REQUESTS ['10']
Block:  10  Seek:0   Rotate:105   Transfer:30    Total:135
TOTALS  10  Seek:0   Rotate:105   Transfer:30    Total:135
```

表示寻道时间是0个时间单位，旋转时间是105个时间单位，总共的磁盘访问请求的时间是135。注意，相邻磁头移动一个磁道的时间是40个时间单位；从扇区6到扇区9，旋转了90度；而为了进行传输，需要从扇区9~10的中间位置开始，从扇区10~11的中间位置结束。所以需要再旋转15度，即旋转了105度，而每旋转1度花费1个时间单位，所以旋转花费了105个实践单位。

1. 若采用FIFO磁盘调度策略，访问请求序列为['10', '12', '24', '1']，请按执行先后顺序列出完成每个磁盘请求的寻道时间（seek time），旋转时间（rotational time），传输时间（transfer time）。
2. 若采用SSFT磁盘调度策略，访问请求序列为['10', '12', '24', '1']，请按执行先后顺序列出完成每个磁盘请求的寻道时间（seek time），旋转时间（rotational time），传输时间（transfer time）。

---

<!--
FIFO策略：
* 10
  * 磁道不变
  * 旋转：105
  * 传输：30
* 12
  * 寻道：40
  * 旋转：60
  * 传输：30
* 24
  * 寻道：40
  * 旋转：360
  * 传输：30
* 1
  * 寻道：80
  * 旋转：30
  * 传输：30

以及恕我无法理解学长答案。他给出的计算结果是：
```
REQUESTS ['10']
Block:  10  Seek:0   Rotate:105   Transfer:30    Total:135
Block:  12  Seek:40  Rotate:350   Transfer:30    Total:420
Block:  24  Seek:40  Rotate:290   Transfer:30    Total:360
Block:   1  Seek:80  Rotate:280   Transfer:30    Total:390
```

SSFT策略：
* 10
  * 磁道不变
  * 旋转：105
  * 传输：30
* 1
  * 磁道不变
  * 旋转：90
  * 传输：30
* 12
  * 寻道：40
  * 旋转：330
  * 传输：30
* 24
  * 寻道：40
  * 旋转：360
  * 传输：30

经过查证，我发现这个题目用的似乎是OSTEP中的模拟程序（<https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8>）。但是我认为程序说明自相矛盾，无法理解。
-->

2018.5.25 UPD：（感谢zp、wj等人关于这道题的讨论）

这个题目用的似乎是OSTEP中的模拟程序（<https://github.com/chyyuu/ucore_os_lab/blob/master/related_info/lab8>）。事实上，需要注意的一点是：磁盘在旋转过程中可以进行寻道。

FIFO策略：

| 请求 | 旋转时间 | 寻道时间 | 传输时间 | 总时间 | 图示 |
| --- | ------- | ------ | ----- | ------- | ------- |
| 10 | 105 | 0 | 30 | 135 | ![](disk-fifo-1.png) |
| 12 | 30 | 40 | 30 | 70 | - |
| 24 | 330 | 40 | 30 | 320 | - |
| 1 | 30 | 80 | 30 | 110 | - |

SSFT策略：

| 请求 | 旋转时间 | 寻道时间 | 传输时间 | 总时间 | 图示 |
| --- | ------- | ------ | ----- | ------- | ------- |
| 10 | 105 | 0 | 30 | 135 | - |
| 1 | 60 | 0 | 30 | 90 | - |
| 12 | 300 | 40 | 30 | 330 | - |
| 24 | 330 | 40 | 30 | 360 | - |

这个答案仍然和学长给出的不尽相同：

```
REQUESTS ['10']
Block:  10  Seek:0   Rotate:105   Transfer:30    Total:135
Block:  12  Seek:40  Rotate:350   Transfer:30    Total:420
Block:  24  Seek:40  Rotate:290   Transfer:30    Total:360
Block:   1  Seek:80  Rotate:280   Transfer:30    Total:390
```

可能之后有时间的时候还需要进行分析吧。
