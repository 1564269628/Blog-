---
title: DGit简介
urlname: introducing-dgit-translation
toc: true
date: 2018-07-05 21:46:43
updated: 2018-07-06 09:50:00
tags: [Github, Spokes, Translation]
---

这篇文章翻译自[Introducing DGit](https://githubengineering.com/introducing-dgit/)，我加入了一些自己的注解。（大部分翻译来自谷歌翻译，水平比我更高，只有少数地方译错，我感觉翻译行业的前景很不乐观。）

---

Edit：[DGit现在改名叫Spokes了](http://githubengineering.com/building-resilience-in-spokes/)

GitHub在数百台服务器<a href="#note1" id="note1ref"><sup>1</sup></a>上托管了超过3500万个存储库和超过3000万个Gists。在过去的一年中，我们构建了DGit，这是一种新的分布式存储系统，可显著提高对Git内容的提取和存储的可用性（availability），可靠性（reliability）和性能（performance）。

DGit是“Distributed Git”的缩写。正如许多读者已经知道的那样，Git本身是分布式的——Git存储库的任何副本都包含项目整个历史记录中的每个文件，分支和提交。DGit使用Git的这个属性在三个不同的服务器上保存每个存储库的三个副本。即使其中一个服务器出现故障，DGit的设计也能够使存储库的可用性不会发生中断。即使在极端情况下，存储库的两个副本同时不可用，存储库仍然可读（readable）；即，提取（fetch），克隆（clone）和大多数Web UI仍然能够继续工作。

DGit在应用程序层执行复制，而不是在磁盘层执行复制。不妨把这些副本看做是三个通过Git协议保持同步的松散耦合的Git仓库，而不是相同的充满了仓库的磁盘映像。此设计使我们能够以极大的灵活性确定仓库副本的存储位置以及用哪个副本进行读取操作。

如果需要使文件服务器脱机，则DGit会自动确定哪些仓库的副本少于三个，并在其他文件服务器上创建这些存储库的新副本。此“修复”过程将所有剩余的服务器用作源和目标。由于“修复”过程的吞吐量是N-N<a href="#note2" id="note2ref"><sup>2</sup></a>，因此速度非常快。所有这一切都没有任何停机时间。

## DGit只使用普通的Git

大多数最终用户将其Git仓库作为对象、包文件和引用存储在单个`.git`目录中。他们使用Git命令行客户端、GitHub Desktop等图形客户端或Visual Studio等IDE中内置的Git支持来访问仓库。可能会令人惊讶的是，GitHub的仓库存储层DGit是使用相同的技术构建的。为什么不使用SAN<a href="#note3" id="note3ref"><sup>3</sup></a>，一个分布式文件系统？或者其他的能够将持久存储数据的问题抽象化的神奇的云技术？

答案很简单：它速度快，而且很健壮。

Git对延迟非常敏感。一个简单的`git log`或者`git blame`命令可能需要顺序加载和遍历数千个Git对象。如果这些低级磁盘访问存在任何延迟，则性能会受到严重影响。因此，将仓库存储在分布式文件系统中是不可行的。Git是为访问高速磁盘而优化的，因此DGit文件服务器将仓库存储在本地高速SSD上。

在更高的层次上，Git还经过优化，可以在通过协议在Git仓库之间之间高效更新（例如，推送和提取）。因此，我们使用这些协议来保持DGit副本同步。

Git是一种成熟且经过良好测试的技术。为什么有一级方程式赛车可用时要重新发明轮子？

GitHub的理念始终是，通过尽可能接近用户使用Git的方式，在我们的服务器上使用Git<a href="#note4" id="note4ref"><sup>4</sup></a>。DGit延续了这一传统。如果我们发现性能瓶颈或其他问题，我们有几个核心的Git和libgit2贡献者会解决这些问题，并将补丁提交到人人可用的开源项目。我们在Git方面的经验和专业知识使其成为用于DGit复制操作的的最优选择。

## 使用DGit前后的GitHub架构

之前，我们使用现有的磁盘层复制技术（即RAID和[DRBD](https://docs.linbit.com/)<a href="#note5" id="note5ref"><sup>5</sup></a>）保存了仓库数据的副本。我们将文件服务器成对组织起来，每个活动文件服务器都有一个通过交叉电缆连接的专用在线备份服务器。每个磁盘有四个副本：主文件服务器上通过RAID保存两个副本，另外两个副本使用DRBD保存在该文件服务器的热备份上。如果文件服务器出现任何问题——例如，硬件故障，软件崩溃或过载情况——一名人类将确认故障并命令备用服务器接管。因此，冗余级别是良好的，但故障转移过程需要手动干预，并且不可避免地导致故障服务器上的仓库在一段时间内不可用。为了尽量减少此类事件，我们始终将仓库存储在专用且高度可靠的服务器上。

现在改为使用DGit，每个仓库都存储在三个服务器上，这三个服务器独立地分布在我们的大群文件服务器中。DGit自动选择托管每个仓库的服务器，使这些副本保持同步，并选择处理每个传入的读取请求最的佳服务器。写操作会同时被导入到三个副本中，仅仅当至少两个副本确认写入成功时才会提交。

![文件服务器复制](fileservers.png)

现在GitHub把仓库存储在一个名为`github-dfs`的集群中——`dfs`是“DGit file server”的缩写。这些仓库存储在这些文件服务器上的本地磁盘中，并通过Git和[libgit2](https://libgit2.github.com/)进行服务。此集群的客户端包括Web前端和与用户的Git客户端通信的代理。

![GitHub架构](architecture.png)

## DGit的优势

DGit为GitHub用户和内部GitHub基础架构团队都提供了许多优势。它也是实现更多即将到来的创新的关键基础。

* 文件服务器不再必须作为成对的相同服务器部署，彼此靠近，并通过交叉电缆一对一连接。我们现在可以在任何空间配置中使用异构的文件服务器池。
* 在开始使用DGit之前，当整个服务器发生故障时，需要尽快将其替换，因为其备份服务器运行时没有备用服务器。两个服务器一起中断可能会使数十万个仓库无法访问。现在，当服务器出现故障时，DGit会快速制作其托管的仓库的新副本，并在整个集群中自动分发它们。
* 路由故障的破坏性大大减小了。我们不必重新启动并重新同步整个服务器，只需停止到服务器的路由流量，直到它恢复。现在可以安全地重启生产服务器，没有过渡期。由于服务器中断对DGit的破坏性较小，我们不再需要等待人类确认中断; 我们可以立即绕过它。
* 我们不再需要保留大多数时间都在闲置的热备用文件服务器。在DGit中，每个CPU和所有内存都可用于处理用户流量。虽然像push这样的写操作必须转到仓库的每个副本，但是任何副本都可以提供读操作。由于读操作的数量远远超过写操作，因此每个仓库现在可以处理的流量几乎是以前的三倍。下图显示了`git`处理在旧文件服务器（蓝色）和DGit服务器（绿色）上分别引起的CPU负载。蓝线标识活动服务器的平均值; 它们的热备件不包括在内。DGit服务器上的负载较低：峰值时大约低三倍，而低谷时大约低两倍。由于所有文件服务器都有无法在副本之间分配的后台维护任务，因此低谷性能的改进没有三倍那么多。

![DGit减少了CPU负载](cpu-load.png)

* DGit可以自动平衡磁盘和CPU热点。添加服务器根本不需要计划：DGit只是随机地将现有仓库移动到新服务器，直到磁盘空间和CPU负载恢复平衡。随着现有仓库的扩展或缩小，DGit会移动它们以保持磁盘空间平衡。随着仓库受欢迎程度的增加或降低，DGit会转移负载以缓解CPU和内存热点。在下图中，一个DGit服务器集群（以红色显示）大部分已满，直到我们添加了一个新的服务器集群（以蓝色显示），其中包含更大的磁盘，以减轻磁盘空间压力。第三个集群（绿色）有两个服务器接收仓库，一个服务器放弃它们。继续移动存储库，直到所有服务器的磁盘空闲空间比例相近。

![磁盘平衡图](disk-balancing.png)

* DGit减少了存储库之间的命运共享（fate sharing）<a href="#note6" id="note6ref"><sup>6</sup></a>。在使用DGit之前，一组固定的仓库一起存储在单个服务器上和该服务器的备用服务器上。如果一个存储库太大，代价太昂贵或太受欢迎，那么该文件服务器上的其他仓库可能会变慢。在使用DGit之后，可以通过其他副本服务其他的仓库，这些副本不太可能与繁忙仓库的其他副本位于相同的服务器上。
* 副本的分离意味着我们可以将存储库的副本放在不同的可用区域中，甚至可以放在不同的数据中心中。可用性得到改善，我们（终于）可以通过在地理上靠近用户的服务器为用户提供内容。

## DGit的试运行

DGit带来的变化是巨大的，所以我们一直在逐步推广它。DGit最复杂的特性是，复制不再是透明的：现在，每个存储库都显式存储在三台服务器上，而不是一台有自动同步热备份的服务器上。因此，DGit不能再依靠DRBD和RAID控制器来保持副本同步，必须实现自己的序列化处理（serializability）<a href="#note7" id="note7ref"><sup>7</sup></a>，锁定（locking），故障检测（failure detection）和二次同步（resynchronization）<a href="#note8" id="note8ref"><sup>8</sup></a>。我们将在以后的帖子中探讨这些内容丰富的主题。这些足以说明，在依赖DGit存储客户数据之前，我们需要彻底测试这些功能。我们的部署经过多个步骤：

* 我们首先移动了DGit开发人员的个人仓库。
* 我们移动了一些私人的，GitHub拥有的仓库，这些仓库不属于运行网站的一部分。我们首先在每个存储库中打开一个issue，请求我们的同事的允许。这既是一个礼貌的预先通知，也是一种开始向GitHub其余部分解释DGit的方法。
* 我们移动了GitHub的其余大部分私有仓库。
* 我们停止移动存仓库大约三个月，同时我们进行了大量测试，对DGit相关流程进行自动化，为DGit撰写了操作级别的文档，并且（咳咳）修复了偶尔发生的错误。
* 经过三个月的稳定运行后，我们移动了大多数GitHub拥有的公共存储库，以及外部用户拥有的那些存储库的fork。例如，[Linguist](https://github.com/github/linguist)的拥有者是GitHub，但其大约1,500个fork属于外部用户。托管公共仓库测试了DGit处理大型仓库的网络和更高流量负载的能力。
* 我们开始移动不属于GitHub的公共仓库。我们立即从GitHub的[showcases](https://github.com/explore)和[流行仓库](https://github.com/trending)中找出一些有很多分支的繁忙的仓库：包括[Ruby](https://github.com/ruby/ruby)、[Rails](https://github.com/rails/rails)、[Bootstrap](https://github.com/twbs/bootstrap)和[D3](https://github.com/mbostock/d3)等等，并且搬运了它们。我们的目标是在DGit中尽可能多地获取流量和不同的使用模式，同时仍然手工采集一小部分仓库的数据。
* 距离我们第一次移动自己的仓库六个月后，令人满意的是，DGit能够很好地托管网站，于是我们开始批量移动仓库。

![DGit中存储库的百分比](growth.png)

在试运行阶段，我们不断尝试关闭服务器，有时会同时关闭几个服务器，此时它们正在提供实时生产流量。用户操作并没有受到影响。

在撰写本文时，58％的存储库和96％的Gists（占Git操作的67％）都迁移到了DGit中。我们正在尽快将剩余的文件服务器对转换为DGit服务器。

## 结论

GitHub始终致力于快速可靠地获取，推送和查看仓库。在未来几年内，我们将使用DGit作为我们的仓库存储层以实现这些目标，同时进行横向扩展并提高容错能力。

在接下来的一个月里，我们将发布更多对DGit背后的技术进行深入研究的帖子。

## 总结

我之前曾经在网上看到一篇相关的评论帖子，但是现在找不到了，我明天再找……

## 注解
<a id="note1" href="#note1ref"><sup>1</sup></a>这个服务器的数量比我想象的要少。（或者谷歌翻译错了，应该是成百上千台。）

<a id="note2" href="#note2ref"><sup>2</sup></a>大概是因为源可以有多个，目标也可以有多个。不过这个吞吐量可能翻译错了，我也不懂“N-by-N”具体是什么意思。

<a id="note3" href="#note3ref"><sup>3</sup></a>关于SAN（摘自维基百科）：
>存储区域网络（英语：storage area network，缩写作 SAN）是一种连接外接存储设备和服务器的架构。人们采用包括光纤通道技术、磁盘阵列、磁带柜、光盘柜的各种技术进行实现。该架构的特点是，连接到服务器的存储设备，将被操作系统视为直接连接的存储设备。除针对大型企业的企业级存储方案外，随着在2000年后价格和复杂度的降低，越来越多的中小型企业也在逐步采用该项技术。

它访问的是磁盘设备，而不是文件。
<a id="note4" href="#note4ref"><sup>4</sup></a>虽然我现在并不理解这个传统的存在意义和价值。

<a id="note5" href="#note5ref"><sup>5</sup></a>DRBD=Distributed Replicated Block Device，一个基于软件在不同宿主之间创建块设备（硬盘、翻去、逻辑分区等）的镜像的存储复制服务。功能特性包括：

* 实时
* 透明
* 同步或异步

（[https://docs.linbit.com/docs/users-guide-9.0/#p-intro](https://docs.linbit.com/docs/users-guide-9.0/#p-intro)）

<a id="note6" href="#note6ref"><sup>6</sup></a>关于命运共享：
>命运共享（Fate Sharing）建议将所有必要的状态放在通信端点，这些状态用于维护一个互动的通信关联（例如虚拟连接）。由于这个原因，导致通信失效的情况也会导致一个或更多端点失效，这样显然会导致整个通信的失败。命运共享是一种通过虚拟连接（例如，由TCP实现的连接）维持活动的设计理念，即便网络在一段时间内失效。命运共享也支持一种“带智能终端主机的哑网络”模型。

（[端到端原则与命运共享原则](https://blog.csdn.net/qq_37653144/article/details/80297681)；还是没太看懂）

<a id="note7" href="#note7ref"><sup>7</sup></a>可串行化（[Database Conflict Serializability \[数据库冲突可串行化\]](https://csruiliu.github.io/blog/2018/02/15/db-serialization/)）：
>多个事务[Transaction]的并发执行是正确的，当且仅当其结果与按某一次串行地执行这些事务时的结果相同，称这种调度策略为可串行化的调度。–数据库系统概论第四版

<a id="note8" href="#note8ref"><sup>8</sup></a>查了之后，发现一堆心脏病疗法，仍然无法很好地认识什么是resynchronization。
