---
title: 如何伸缩Spokes
urlname: stretching-spokes-translation
toc: true
date: 2018-07-08 03:40:34
updated: 2018-07-10 02:53:00
tags: [Github, Spokes, Translation]
---

这篇文章翻译自[Stretching Spokes](https://githubengineering.com/stretching-spokes/)，我加入了一些自己的注解。

---

GitHub的Spokes系统存储了Git仓库的多个分布式副本。本文讨论了如何把把Spokes为仓库制作的副本分散到相互之间距离很远的的数据中心。

## Spokes的背景

GitHub开发了一个名为Spokes的系统来存储我们用户的Git仓库的多个副本，并使副本保持同步。Spokes使用多种策略来确保在大多数情况下每个Git更新都能安全地复制到所有副本，并且在所有情况下至少能够复制到严格多数个副本。Spoke取代了在文件系统块级别进行复制的旧系统，改为在Git应用程序级别进行复制。

![Spokes的push操作](spokes-diagram.jpg)

每个对Git仓库的push操作都会通过代理，这一代理会透明地将操作复制到多个文件服务器。早期版本的Spoke需要代理与所有副本之间都能够进行低延迟通信，以维持较高的更新速率。因此，副本之间的距离必须比较近。

但是，将仓库副本的位置分离的优点是众所周知的：

* 副本分散得越开，在影响一片较大地理区域的灾难中（例如飓风、地震和外星人入侵<a href="#note1" id="note1ref"><sup>1</sup></a>），就越有可能有副本幸存。
* 如果多个区域中都有可用的副本，则可以将Git读取请求定向到距离最近的副本，从而减少传输时间。

本文首先解释了为什么延迟会带来问题，我们如何克服问题，使得Git数据能够分布式地存储在整片大陆上，以及这为我们的用户带来了哪些改进。、

## 副本之间相隔很远。那有什么好大惊小怪的呢？

在开发Spokes之前，我们使用[DRBD](https://en.wikipedia.org/wiki/Distributed_Replicated_Block_Device)，对文件系统进行块级复制，以创建仓库副本。该系统对延迟非常敏感，因此我们不得不保证文件服务器副本相互靠近。这显然不够理想，解决这一问题就是最初推动Spokes发展的动力。

自从我们开始运行Spokes之后，我们就开始增加Spokes的仓库副本彼此之间的距离极限。副本之间相距越远，它们之间的延迟就越大。延迟大小限制了Spokes能够为每个仓库维持的Git引用更新（reference update）<a href="#note2" id="note2ref"><sup>2</sup></a>的最大速率。

你可能会惊讶，我们居然需要担心这种问题。单个仓库的推送频率不会**那么**高吧？

嗯，**大多数** 用户根本不会经常推送。但是如果你托管了近7000万个仓库，你总会发现[某些项目使用了你从未预料到的工作流程](https://www.youtube.com/watch?v=-ZNKR9wFe8o)。我们非常努力，才能保证Github能够为几乎所有的项目提供正常服务，但仍有一些极其荒谬的案例除外。

此外，为了进行内部记录，Github本身也产生了大量的引用更新。例如，每次用户推送一个pull request分支时，我们都必须记录push操作本身，可能需要将该分支同步到目标仓库，为该pull request计算测试merge和测试rebase<a href="#note3" id="note3ref"><sup>3</sup></a>，这些操作都会产生引用。如果用户推送到项目的`master`分支，我们就需要为每一个目标是`master`的活跃pull request都计算一个测试merge和测试rebase。在某些仓库中，这可能会触发超过一百个引用的更新。

能够对具有高延迟的远程副本进行足够快的引用更新对于Spokes的可用性至关重要。具体来说，我们希望能够支持的每个仓库每秒的更新次数大于1。这意味着每次更新操作的预算只有使用几百毫秒。请记住，无论我们采用何种方法优化写操作，都不能因此减慢读操作的速度，因为读操作和写操作数量之比约为100:1。

## 减少往返次数

考虑到光速有限之类的烦心事，每次到副本的往返通信都需要时间。例如，横跨美国大陆的一次网络往返通信需要60-80毫秒。多往返几次就会耗尽我们的时间预算。

我们使用[三阶段提交](https://zh.wikipedia.org/wiki/三阶段提交)<a href="#note4" id="note4ref"><sup>4</sup></a>来更新副本，同时将副本作为分布式锁，以确保更新数据库的顺序是正确的。总而言之，远程副本需要四次往返通信；这无疑是昂贵的，但还没有到无法接受的地步。（我们正在计划通过使用更先进的一致性算法来减少往返次数。）

我们尽可能地利用等待网络请求的时间来完成其他的工作。例如，当一个副本获取互斥锁时<a href="#note5" id="note5ref"><sup>5</sup></a>，另一个副本可能正在计算校验和，而协调器（coordinator）<a href="#note6" id="note6ref"><sup>6</sup></a>可能正在读数据库。

## Git引用更新事务
三阶段提交是保持副本同步的关键。为了实现这一协议，我们需要每个副本能够回答“你能执行这些引用更新吗？”这一问题，然后根据协调器的指示提交或回滚事务。为了实现这一目标，我们在开源Git项目中[实现了Git引用更新事务](https://github.com/git/git/compare/8eaf517835d0534767d6a54d12d072ce30276ad9...2cc70cefdd4a249fab895943890d21071e03f8c7)（可以通过类似于`git update-ref --stdin`的命令使用这一特性<a href="#note7" id="note7ref"><sup>7</sup></a）；为了保证[事务](https://github.com/git/git/compare/538569bc8a212a45b7b3f124822b4c3e458752f5...3ad8b5bf26362ac67c9020bf8c30eee54a84f56d)的[执行结果](https://github.com/git/git/compare/08bb3500a2a718c3c78b0547c68601cafa7a8fd9...87492cb24d9d8be8e18217b89ae5f090089ff31d)在副本间是[确定的](https://github.com/git/git/compare/53083f8547cd45cdfabcf2f1bd21461cd6769189...711a11c301dafe84389624f009a2abfb7da5d83f)（deterministic），我们[做](https://github.com/git/git/compare/c380cf85a79c78d9dceb9290c9d4017d30804521...33d4669aaa658f3e35f88748ed2db51c84203f62)了[大量](https://github.com/git/git/compare/7543dea8b2a33e4a56b0fdd408bc47769238025e...11cb3130d551590ae2dbd582e809763bfc353a47)的[工作](https://github.com/git/git/compare/97c12a8b71e7d42b87b9588ba2fe0e1e44411c21...fd9de868c359a1bbd214e354aefdb0f1eaa898bd)。<a href="#note8" id="note8ref"><sup>8</sup></a>首先，Git获取所有必要的本地引用的锁，然后验证旧值符合预期且新值是有意义的。如果一切正常，则提交这一试探性事务（tentative transaction）；否则，它将回滚一切更改。

## 加速Git引用更新

除了网络延迟之外，我们还必须考虑在单个副本上更新Git引用所需的时间。为此，我们[还](https://github.com/git/git/compare/8e606f97f8dee35f839b50900db8ab98fe189b3c...a7ddaa8eacb45fdd5241e52d72e6f75d8b67b953)为与引用相关的操作[实现](https://github.com/git/git/compare/5f02274e4c4506b923b510a24da7991656f4db14...be9cb560e31c76c00760dadb151b5e3059970586)了[一些](https://github.com/git/git/compare/a080a5ce8d9f6897668bb36cb1891f70d685b6c3...44c2339e55df11b2cfd8bdc28ceee6b4d1ca1928)[加速](https://github.com/git/git/compare/9124cca61f7edfed70dc5d8bced7fb7cb9fe2221...1a2e1a76ec2cbbafe60ffd124f673f62045fb0d3)。这些变化也贡献回了开源Git项目。

## 使用校验和对副本进行比较

我们通过计算副本的所有引用及其值（和一些其他的东西）的校验和来概括副本的状态，称之为“Spokes校验和”。如果两个副本的Spokes校验和相同，则它们肯定拥有相同的逻辑内容。我们在每次更新后计算每个副本的Spokes校验和，作为验证它们保持同步的一项额外检查。

在具有大量引用的繁忙仓库中，从头开始计算Spokes校验和是比较昂贵的，并且会限制引用更新的最大速率。因此，我们会尽可能用逐步的方法来计算Spokes校验和。我们将该值定义为所有`(refname, value)`对的hash值的异或。因此，在更新引用时，我们可以通过下式来更新校验和的这一部分：

```
new_checksum = old_checksum XOR hash(refname, oldvalue) XOR hash(refname, newvalue)
```

在我们知道旧Spokes校验和的情况下，计算新Spokes校验和的代价就很小了。

## 优先考虑用户发起的更新

即使进行了所有这些优化，一次参考更新仍然需要大约三分之一秒。这在大多数情况下都足够了。但是在我们之前提到的情况下，对`master`进行一次更新可能会导致上百次内部记录的引用更新（bookkeeping reference update），处理这些更新可能会使仓库在30秒内都处于忙状态。如果这些更新会在如此长的时间内阻止用户发起引用更新，则用户请求将被高度延迟，甚至会超时。

为了解决这一问题，我们将一些内部记录更新合并为几个事务，并且令用户发起的更新优先于内部记录更新（因为它们不需要立即被执行）。

## GitHub.com和GitHub Enterprise的地理复制

Spokes为GitHub用户带来的最切实的好处是，可以通过地理位置较近的Spokes副本提供Git读取操作（fetch和clone）。由于Spokes可以快速找出哪些副本是最新的，它可以将读操作发送到距离最近的最新副本。Spokes已经在这方面加速了GitHub.com的许多用户的传输速度，而且，随着我们在更多地理区域增加副本，传输速度还会进一步提高。

GitHub Enterprise是GitHub的企业本地版，通过相同的底层Spokes技术，它现在也支持[地理复制](https://help.github.com/enterprise/2.11/admin/guides/installation/about-geo-replication/)（Geo-replication）<a href="#note9" id="note9ref"><sup>9</sup></a>了。甚至当用户远离中心GHE主机（main GHE host）<a href="#note10" id="note10ref"><sup>10</sup></a>时，靠近这样的副本的用户也可以享受更快的Git传输速度。这些副本被配置为无投票权的（non-voting）<a href="#note11" id="note11ref"><sup>11</sup></a>，因此，即使被地理复制的主机暂时无法访问，对中心GHE主机的Git推送也能继续进行。

## 结论

通过对Spokes的精心设计，以及对分布式引用更新的性能的仔细优化，Spokes现在能够在更长的距离范围内复制Git仓库了。这提高了GitHub.com和GitHub Enterprise的健壮性、速度和灵活性。

## 注释

<a id="note1" href="#note1ref"><sup>1</sup></a>虽然我觉得，一旦外星人真的入侵，应该也没有时间考虑这个问题了。

<a id="note2" href="#note2ref"><sup>2</sup></a>我不太明白“reference update”这一术语指代的是什么。[Git文档](https://git-scm.com/book/zh/v2/Git-内部原理-Git-引用)似乎表明，这是用于保存commit对应的SHA-1值的文件：

>我们可以借助类似于`git log 1a410e`这样的命令来浏览完整的提交历史，但为了能遍历那段历史从而找到所有相关对象，你仍须记住`1a410e`是最后一个提交。我们需要一个文件来保存SHA-1值，并给文件起一个简单的名字，然后用这个名字指针来替代原始的SHA-1值。
在 Git 里，这样的文件被称为“引用（references，或缩写为 refs）”；你可以在`.git/refs`目录下找到这类含有 SHA-1 值的文件。

<a id="note3" href="#note3ref"><sup>3</sup></a>我感觉自己对merge和rebase的区别一无所知，也无从理解为什么要做这样的计算。大概是为了显示差异比较？（[5.1 代码合并：Merge、Rebase 的选择](https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase-%E7%9A%84%E9%80%89%E6%8B%A9)）

<a id="note4" href="#note4ref"><sup>4</sup></a>[三阶段提交](https://zh.wikipedia.org/wiki/三阶段提交)：

>三阶段提交（英语：Three-phase commit），也叫三阶段提交协议（英语：Three-phase commit protocol），是在计算机网络及数据库的范畴下，使得一个分布式系统内的所有节点能够执行事务的提交的一种分布式算法。三阶段提交是为解决两阶段提交协议的缺点而设计的。
与两阶段提交不同的是，三阶段提交是“非阻塞”协议。三阶段提交在两阶段提交的第一阶段与第二阶段之间插入了一个准备阶段，使得原先在两阶段提交中，参与者在投票之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。

<a id="note5" href="#note5ref"><sup>5</sup></a>并不理解具体是获取什么锁。

<a id="note6" href="#note6ref"><sup>6</sup></a>我猜测这里的协调器指的应该是分布式事务处理协调器（distributed transaction coordinator），这种技术能够使得分布式计算的事务是可靠的。（参考了[What is MSDTC and why do I need to care about it?](https://blogs.msdn.microsoft.com/florinlazar/2004/03/04/what-is-msdtc-and-why-do-i-need-to-care-about-it/)，虽然不知道和数据库有什么关系。分布式系统真有趣！）

<a id="note7" href="#note7ref"><sup>7</sup></a>我之前从未听说过`update-ref`这个命令。于是查阅[手册](https://git-scm.com/docs/git-update-ref)，得知这是一个用于安全地更新引用中存储的对象名称的命令。

<a id="note8" href="#note8ref"><sup>8</sup></a>为了说明他们**确实**做了很多工作，作者在这一句话里插入了9个链接，全是指向对应的commit和merge记录的。真是辛苦了……

<a id="note9" href="#note9ref"><sup>9</sup></a>简单来说，“[地理复制](https://help.github.com/enterprise/2.11/admin/guides/installation/about-geo-replication/)”（Geo-replication）这个东西指的就是，通过多个活跃副本完成来自地理区域不同的数据中心的请求。不过好像还有一些其他的细节。

<a id="note10" href="#note10ref"><sup>10</sup></a>“GHE”是“Github Enterprise”的缩写。

<a id="note11" href="#note11ref"><sup>11</sup></a>“投票权”说的应该是[在Spokes中实现弹性](/post/building-resilience-in-spokes-translation)这篇文章中提到的实现持久性的方法：保证多数一致。在这里，我猜失去投票权的意思是，无论它的写入结果如何，都不参与投票（不需要获得对于它的独占锁定），如果发生不一致，再进行更新。
