---
title: CSP 201803 (2) 碰撞的小球（模拟）
urlname: csp-201803-2
toc: true
date: 2018-08-29 12:41:06
updated: 2018-08-29 15:06:00
tags: [CSP]
---

## 题意

试题编号：201803-2

试题名称：碰撞的小球

时间限制：1.0s

内存限制：256.0MB

### 问题描述

数轴上有一条长度为L（L为偶数)的线段，左端点在原点，右端点在坐标L处。有n个不计体积的小球在线段上，开始时所有的小球都处在偶数坐标上，速度方向向右，速度大小为1单位长度每秒。

当小球到达线段的端点（左端点或右端点）的时候，会立即向相反的方向移动，速度大小仍然为原来大小。

当两个小球撞到一起的时候，两个小球会分别向与自己原来移动的方向相反的方向，以原来的速度大小继续移动。

现在，告诉你线段的长度L，小球数量n，以及n个小球的初始位置，请你计算t秒之后，各个小球的位置。

### 提示

因为所有小球的初始位置都为偶数，而且线段的长度为偶数，可以证明，不会有三个小球同时相撞，小球到达线段端点以及小球之间的碰撞时刻均为整数。

同时也可以证明两个小球发生碰撞的位置一定是整数（但不一定是偶数）。

### 输入格式

输入的第一行包含三个整数n, L, t，用空格分隔，分别表示小球的个数、线段长度和你需要计算t秒之后小球的位置。

第二行包含n个整数a1, a2, …, an，用空格分隔，表示初始时刻n个小球的位置。

### 输出格式

输出一行包含n个整数，用空格分隔，第i个整数代表初始时刻位于ai的小球，在t秒之后的位置。

### 样例输入1

```
3 10 5
4 6 8
```

### 样例输出1

```
7 9 9
```

### 样例输入2

```
10 22 30
14 12 16 6 10 2 8 20 18 4
```

### 样例输出2

```
6 6 8 2 4 0 4 12 10 2
```

### 数据规模和约定

对于所有评测用例，1 ≤ n ≤ 100，1 ≤ t ≤ 100，2 ≤ L ≤ 1000，0 < ai < L。L为偶数。

保证所有小球的初始位置互不相同且均为偶数。

## 分析

这题看着很像紫书上的一道例题，同样可以用交换速度的思路去看，唯一的区别是小球会在线段端点处反射（好像？），但这并没有改变小球之间只是交换速度（或互相穿越），而相对顺序不变的事实。所以其实不需要模拟，直接按初始位置排序，然后计算出所有最终位置，再排序，然后根据初始顺序就可以知道每个小球的最终位置了。

事实上我又忘了怎么用两种排序方法调用`std::sort`了。事实上我觉得这种东西是不可能记住的，不如背诵一下`qsort`的用法。

参数：

* 数组起始位置
* 元素个数
* 元素`size`
* 比较函数，要求两个参数都是`const void*`类型，返回值为`int`

```cpp
// http://www.cplusplus.com/reference/cstdlib/qsort/
/* qsort example */
#include <stdio.h>      /* printf */
#include <stdlib.h>     /* qsort */

int values[] = { 40, 10, 100, 90, 20, 25 };

int compare (const void * a, const void * b)
{
  return ( *(int*)a - *(int*)b );
}

int main ()
{
  int n;
  qsort (values, 6, sizeof(int), compare);
  for (n=0; n<6; n++)
     printf ("%d ",values[n]);
  return 0;
}
```

## 代码

时间：15ms

空间：504.0KB

```cpp
#include <iostream>
#include <cstdlib>
using namespace std;

struct Position {
    int pos;
    int num;
};

int cmpPos(const void* x, const void* y) {
    return ((Position*) x)->pos - ((Position*) y)->pos;
}

int cmpNum(const void* x, const void* y) {
    return ((Position*) x)->num - ((Position*) y)->num;
}

Position initPos[105], laterPos[105];

int main() {
    int n, L, t;
    cin >> n >> L >> t;

    // 按顺序排序
    for (int i = 0; i < n; i++) {
        cin >> initPos[i].pos;
        initPos[i].num = i;
    }
    qsort(initPos, n, sizeof(Position), cmpPos);

    // 计算之后的“模拟”位置
    // 撞墙多次的情况显然循环了
    t %= 2 * L;
    for (int i = 0; i < n; i++) {
        // 没撞到墙
        if (initPos[i].pos + t <= L)
            laterPos[i].pos = initPos[i].pos + t;
        // 撞墙一次
        else if (L < initPos[i].pos + t && initPos[i].pos + t <= 2 * L)
            laterPos[i].pos = L - (t - (L - initPos[i].pos));
        // 撞墙两次
        else
            laterPos[i].pos = t - (2 * L - initPos[i].pos);
    }
    qsort(laterPos, n, sizeof(Position), cmpPos);

    for (int i = 0; i < n; i++)
        laterPos[i].num = initPos[i].num;
    qsort(laterPos, n, sizeof(Position), cmpNum);

    cout << laterPos[0].pos;
    for (int i = 1; i < n; i++)
        cout << ' ' << laterPos[i].pos;
    cout << endl;

    return 0;
}
```
