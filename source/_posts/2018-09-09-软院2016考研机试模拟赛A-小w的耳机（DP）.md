---
title: 软院2016考研机试模拟赛A. 小w的耳机（DP）
urlname: thuss-2016-postgraduate-entrance-exam-simulation-a-earphone
toc: true
date: 2018-09-09 15:42:18
updated: 2018-09-10 13:51:00
tags: [alg:Dynamic Programming]
---

题目来源：[http://ac.ssast.org/contest/2/problem/5](http://ac.ssast.org/contest/2/problem/5)（需要清华内网）

提交次数：1/2

## 题意

有一个`n * n`的网格，定义一条合法路径是从左上角到右下角且只向右和向下走的路径。每个格子有一定的权值。问从左上到右下的三条路径所覆盖的格子的总权值最大是多少？（权值不重复计算）

## 分析

比赛的时候我看到这是第一题，就很慌张。后来发现这是三道题里最难的一道。我开始时想到了复杂度较高的DP方法，后来简化了一下，就交上去了。结果比赛之后发现只得了70分，因为我看错数据范围了，应该开`2 * n`的数组，我只开了`n`。

---

我想出来的第一种DP做法是这样的：令`f[x1][y1][x2][y2][x3][y3]`表示第一条路径到达`(x1, y1)`，第二条路径到达`(x2, y2)`，第三条路径到达`(x3, y3)`时的最大权值和。此时的问题是怎么写状态转移方程。很显然，每次只选择若干条路径前进是一种不太合理的做法，既然三条路径的长度是相同的，不妨令每次每条路径都要前进。此时可以这样进行状态转移：

* 初始条件：`f[0][0][0][0][0][0] = a[0][0]`（这是显然的）
* 转移：`f[x1][y1][x2][y2][x3][y3] = max(f[x1 - dx[i1]][y1 - dy[i1]][x2 - dx[i2]][y2 - dx[i2]][x3 - dx[i3]][y3 - dy[i3]]) + value`，其中`dx[2] = {0, 1}`，`dy[2] = {1, 0}`，`i = 0`表示该路径上一步是向右走的，`i = 1`表示该路径上一步是向下走的，`value`表示`(x1, y1), (x2, y2), (x3, y3)`覆盖的格子的总权值和。
* 答案：`f[n-1][n-1][n-1]`

这个方法的问题是空间复杂度太高（`O(n^6)`）。

通过之前的观察，我们可以发现，这个方法里的状态是比较冗余的：既然每条路径当前走过的总长度都是相同的，不妨这样设计状态：令`f[m][x1][x2][x3]`表示三条路径都走了`m`，第一条路径到达`(x1, m - x1)`，第二条路径到达`(x2, m - x2)`，第三条路径到达`(x3, m - x3)`时的最大权值和。

* 初始条件：`f[0][0][0][0] = a[0][0]`
* 转移：`f[m][x1][x2][x3] = max(f[m - 1][x1 - dx[i1]][x2 - dx[i2]][x3 - dx[i3]]) + value`
* 答案：`max(f[2(n-1)][i][j][k])`

这种方法的空间复杂度降低到了`O(n^4)`。

当然，上述两种方法都要注意边界条件。[^blog]

[^blog]: 上述描述参考了[《小w的耳机》解题报告](http://ac.ssast.org/blogof/ycdfwzy/blog/14)（仍然需要内网）

## 代码

```cpp
#include <iostream>
using namespace std;
typedef long long int LL;
int n;
LL g[55][55];
LL f[105][55][55][55];
int main() {
    cin >> n;
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            cin >> g[i][j];
    // 共需走2(n-1)步
    // f[m][x1][x2][x3]：当都走了m步，且1向下走了x1步，2向下走了x2步，3向下走了x3步时的最大的和
    LL maxSum = -1;
    f[0][0][0][0] = g[0][0];
    for (int m = 1; m <= 2 * (n-1); m++) {
        for (int i = 0; i <= min(m, n-1); i++) {
            for (int j = 0; j <= min(m, n-1); j++) {
                for (int k = 0; k <= min(m, n-1); k++) {
                    f[m][i][j][k] = 0;
                    for (int i1 = max(0, i-1); i1 <= min(i, m-1); i1++)
                        for (int j1 = max(0, j-1); j1 <= min(j, m-1); j1++)
                            for (int k1 = max(0, k-1); k1 <= min(k, m-1); k1++)
                                f[m][i][j][k] = max(f[m][i][j][k], f[m-1][i1][j1][k1]);

                    f[m][i][j][k] += g[i][m - i] + g[j][m - j] + g[k][m - k];
                    if (i == j) f[m][i][j][k] -= g[i][m-i];
                    if (i == k) f[m][i][j][k] -= g[i][m-i];
                    if (j == k) f[m][i][j][k] -= g[k][m-k];
                    if (i == j && j == k) f[m][i][j][k] += g[i][m-i];

                    if (m == 2 * (n-1)) maxSum = max(maxSum, f[m][i][j][k]);
                }
            }
        }
    }

    cout << maxSum << endl;
    return 0;
}
```
