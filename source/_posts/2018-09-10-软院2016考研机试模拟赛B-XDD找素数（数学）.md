---
title: 软院2016考研机试模拟赛B. XDD找素数（数学）
urlname: thuss-2016-postgraduate-entrance-exam-simulation-b-prime
toc: true
mathjax: true
date: 2018-09-10 14:12:29
updated: 2018-09-10 15:44:29
tags: [alg:Math]
---

题目来源：[http://ac.ssast.org/contest/2/problem/6](http://ac.ssast.org/contest/2/problem/6)（需要清华内网）

提交次数：1/2

## 题意

输入`n`，输出`[2, n]`区间内的素数总数。（`2 <= n <= 2 * 10^7`）

## 分析

比赛的时候我心想，这不是很简单的暴力题么……我相信肯定可以开一个`10^7`左右的`bool`数组的。于是我就写完了，写过之后测了一下最大的数据（`20000000`），发现也没有超过1秒，于是就这样了。

---

这道题至少有两个正解，埃式筛法（Sieve of Eratosthenes）和欧拉筛法（Euler's Sieve）。[^sieve]

[^sieve]: [Sieve of Eratosthenes](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)

### 埃式筛法

最简单的筛法之一，思路非常简单。

```cpp
define array isPrime[n + 1]  // 令数组isPrime表示一个数是否为素数
for i from 1 to n
    isPrime[i] = true  // 起始时假定所有数都是素数

for i from 2 to n  // 如果不需要打印所有素数，此处结束条件可以是n / i（或者说sqrt(n)）
    if (isPrime[i])  // 找到了一个素数；筛除所有这个素数的倍数
        for j from 2 to n / i  // 从i开始可以降低复杂度
            isPrime[i * j] = false
```

算法空间复杂度是$O(n)$，时间复杂度是$O(n\log{\log{n}})$，接近于线性。当然，一个问题是，这个时间复杂度是怎么算出来的。显然，对于每个素数`p`，内层的`for`循环至多运行了`n / p`次。由于[^mathexchange]

$$\sum_{p \leq n} \frac{1}{p} = O(\log{\log{n}})$$

[^mathexchange]: [What is the sum of the reciprocal of primes? (Yes, it diverges)](https://math.stackexchange.com/questions/674877/what-is-the-sum-of-the-reciprocal-of-primes-yes-it-diverges)

因此总的时间复杂度是$O(n\log{\log{n}})$。

下一个问题是，如果外层循环的结束条件改成$\sqrt{n}$，并不会改变这个界。虽然此时我们只访问了比$\sqrt{n}$小的素数，但是对于每个素数`p`，内层的`for`循环仍然至多运行了`n / p`次。此时

$$\sum_{p \leq \sqrt{n}} \frac{n}{p} = n \cdot O(\log{\log{\sqrt{n}}}) = n \cdot O(\log{(0.5 \log{n})}) = n \cdot O(\log{0.5} + \log{\log{n}}) = n \cdot O(\log{\log{n}})$$

最后一个问题是，如果再把内层循环的起始条件改成`i`，这个算法的时间复杂度上界能否更紧一些。此时和式变成了

$$\sum_{p \leq \sqrt{n}} ( \frac{n}{p} - p) = n \cdot \sum_{p \leq \sqrt{n}} \frac{1}{p} - \sum_{p \leq \sqrt{n}} p$$


### 欧拉筛法

从上面的例子可以看出，$\log{\log{n}}$这个函数已经相当接近于线性了，不过我们仍然可以把埃式筛法改得更好一些，使它的时间复杂度变成$O(n)$。对于埃式筛法，显然一个合数可能被不止一个素数筛掉，如12，可能会被2和3筛掉两遍，这就增加了复杂度。如果我们通过某些方法，使得每个合数只会被它最小的质因子筛掉一遍，复杂度就可以降低到$O(n)$了。

我们考查任何一个数$n$，假设其最小质因子为$m$，那么小于等于$m$的质数与$n$相乘，会得到一个更大的合数，且其最小质因数为与$n$相乘的那个素数。此时该合数可以直接从表中删除，因为其刚好满足之前的合数删除的定义。

```cpp
define array isPrime[n + 1]  // 令数组isPrime表示一个数是否为素数
define array prime[n + 1]  // 存储已经找到的素数
int m = 0  // 找到的素数个数

for i from 1 to n
    isPrime[i] = true  // 起始时假定所有数都是素数

for i from 2 to n
    if (isPrime[i])
        prime[m] = i
        m += 1
    for j from 0 to m-1
        if (i * prime[j] > n)
            break
        isPrime[i * prime[j]] = false  // prime[j]是<=i的最小素因子的素数
        if (i % prime[j] == 0) break  // 如果prime[j]已经是i的最小素因子了，结束
```

上述代码里有一个我起初没有注意到的问题。我们需要允许与`i`的最小素因子相等的素数与`i`相乘的结果被筛掉，否则我们就无法筛掉任何含有素数的比1更高的次幂的数了。[^blog]

[^blog]: 上述描述参考了[XDD找素数——题解](http://ac.ssast.org/blogof/wonderfulnx/blog/16)（仍然需要内网）

## 代码

### 埃式筛法

```cpp
#include <iostream>
#include <cstring>
using namespace std;
bool isPrime[20000005];
int main() {
    int n;
    cin >> n;
    memset(isPrime, 1, sizeof(isPrime));
    isPrime[1] = false;
    int cnt = 0;
    for (int i = 2; i <= n; i++) {
        if (isPrime[i]) {
            cnt++;
            // 注意溢出
            for (long long int k = i; k * i <= n; k++)
                isPrime[k * i] = false;
        }
    }
    cout << cnt << endl;
    return 0;
}
```

### 欧拉筛法

```cpp
#include <iostream>
#include <cstring>
using namespace std;
typedef long long int LL;
bool isPrime[20000005];
LL prime[2000005];
int main() {
    LL n, m;
    cin >> n;
    m = 0;
    memset(isPrime, 1, sizeof(isPrime));
    for (LL i = 2; i <= n; i++) {
        if (isPrime[i]) prime[m++] = i;
        for (LL j = 0; j < m && i * prime[j] <= n; j++) {
            isPrime[i * prime[j]] = false;
            if (i % prime[j] == 0) break;
        }
    }
    cout << m << endl;
    return 0;
}
```
