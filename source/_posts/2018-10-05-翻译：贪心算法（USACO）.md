---
title: 翻译：贪心算法（USACO）
urlname: greedy-algorithm-usaco-translation
toc: true
date: 2018-10-05 00:35:59
updated: 2018-10-05 00:35:59
tags: [Translation, USACO]
---

之前我在USACO上的做题计划卡住了，主要是因为我想仔细阅读一下这篇文章，因为我觉得写得很好——结果因为各种原因卡了一个多月。

总之下面的翻译主要来自[^ref]，进行了一些小修改。

[^ref]: [贪心算法简介](https://blog.csdn.net/jiajie999/article/details/1515167)

---

<!--Sample Problem: Barn Repair [1999 USACO Spring Open]-->

## 例题: 栅栏修理（1999 USACO Spring Open）

<!--There is a long list of stalls, some of which need to be covered with boards. You can use up to N (1 <= N <= 50) boards, each of which may cover any number of consecutive stalls. Cover all the necessary stalls, while covering as few total stalls as possible.-->

>农场里有一排牛棚，其中的一些牛棚需要用木板遮盖起来。你最多可以使用`N`（`1<=N<=50`）块木板，其中每一块都可以遮盖任何数数量的连续的牛棚。请遮盖所有需要被遮盖的牛棚，而且使总的遮盖的牛棚的数量尽可能的少。

<!--The Idea-->

## 思路

<!--The basic idea behind greedy algorithms is to build large solutions up from smaller ones. Unlike other approaches, however, greedy algorithms keep only the best solution they find as they go along. Thus, for the sample problem, to build the answer for N = 5, they find the best solution for N = 4, and then alter it to get a solution for N = 5. No other solution for N = 4 is ever considered.-->

>贪心法的基本思想是用局部解构造全局解。和其它方法不同的是，贪心法在求解过程中只保留所找到的最优解。以上面这道题为例，为了构造`N=5`时的最优解，贪心法需要先找到`N=4`时的最优解，然后在此基础上进行修改，以得到`N=5`时的解。`N=4`时的所有其他解都不予考虑。

很显然，很多其他方法的基本思想都是用局部解构造全局解（大概包括回溯法和动态规划法，以及我现在都想不起来的很多很多算法，毕竟很难凭空造一个解出来）。只保留最优解就是贪心法速度快的原因（因为需要的解空间少）。以及在实际中（也就是不一定需要一个“正确”算法的时候），贪心法实际上不一定只会保留“the best solution”，而可能是若干个“best solutions”。昨天刚读的[seq2seq](https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf)里用到的[Beam Search](https://en.wikipedia.org/wiki/Beam_search)就是一个很好的例子。[^beam]

[^beam]: [谁能解释下seq2seq中的beam search算法过程? - 知乎](https://www.zhihu.com/question/54356960)

不过我感觉在竞赛算法中一般用不到这个策略……

<!--Greedy algorithms are fast, generally linear to quadratic and require little extra memory. Unfortunately, they usually aren't correct. But when they do work, they are often easy to implement and fast enough to execute.-->

>贪心法的特点是速度快，时间复杂度通常在`O(N)`和`O(N^2)`之间，不需要太多额外的内存。不幸的是，它们通常是不正确的。不过在贪心法确实正确的时候，它们通常很容易实现，且执行速度很快。

<!--Problems-->

## 基本问题

<!--There are two basic problems to greedy algorithms.-->

>贪心法通常将面临两个基本问题。

<!--How to Build-->

### 如何构造？

<!--How does one create larger solutions from smaller ones? In general, this is a function of the problem. For the sample problem, the most obvious way to go from four boards to five boards is to pick a board and remove a section, thus creating two boards from one. You should choose to remove the largest section from any board which covers only stalls which don't need covering (so as to minimize the total number of stalls covered).-->

>怎样通过小规模的解构造更大规模的解呢？一般来说，这与问题本身有关。对于这道例题来说，通过4块板的解构造5块板的解的最显然的方法就是，选出一块木板，从中间去掉一段，这样就把一块木板变成了两块木板。你应该选择去掉所有木板中只包含不需要被遮盖的牛棚的最长的一段（这样就可以使得被遮盖的牛棚总数最少）。

<!--To remove a section of covered stalls, take the board which spans those stalls, and make into two boards: one of which covers the stalls before the section, one of which covers the stalls after the section.-->

>将一段被遮盖的牛棚上遮盖的木板去除的方法是，把遮盖了这些牛棚的那块木板分成两块木板：一块遮盖了这一段之前的牛棚，另一块遮盖了这一段之后的牛棚。

<!--Does it work?-->

### 是否正确？

<!--The real challenge for the programmer lies in the fact that greedy solutions don't always work. Even if they seem to work for the sample input, random input, and all the cases you can think of, if there's a case where it won't work, at least one (if not more!) of the judges' test cases will be of that form.-->

>对编程者而言，最大的挑战来自这一事实：贪心法得到的解并不总是正确的。即使它们看起来好像在样例输入、随机输入，以及你能想到的任何情形下都是正确的，只要存在一种使贪心法发生错误的输入，评测样例中必然会包含至少一种（如果不是更多）该类型的输入。

（出题人的小心机……）

<!--For the sample problem, to see that the greedy algorithm described above works, consider the following:-->

>对于之前的例题，下面的内容证明了之前描述的贪心算法的正确性：

<!--Assume that the answer doesn't contain the large gap which the algorithm removed, but does contain a gap which is smaller. By combining the two boards at the end of the smaller gap and splitting the board across the larger gap, an answer is obtained which uses as many boards as the original solution but which covers fewer stalls. This new answer is better, so therefore the assumption is wrong and we should always choose to remove the largest gap.-->

>假设正确的解中里没有包含贪心算法移除的最长的一段木板留下的缺口，却包含了另外一段较小的缺口。通过把位于较小缺口两端的两块木板合并，并将跨越较长缺口的那块板分开，就可以得到一个与原解使用的木板数量相同，但覆盖的牛棚数量更少的新解。这个新的解更好，所以这个假设是错误的，我们总是应该选择移除最长的可以移除的一段木板。

<!--If the answer doesn't contain this particular gap but does contain another gap which is just as large, doing the same transformation yields an answer which uses as many boards and covers as many stalls as the other answer. This new answer is just as good as the original solution but no better, so we may choose either.-->

>如果正解中不包含这一个缺口，却包含另一个大小相同的缺口，使用同样的方法，可以得到一个与原解使用的木板数量相同，且覆盖的牛棚数量相同的解。新解与原解一样好，我们可以任选其一。

<!--Thus, there exists an optimal answer which contains the large gap, so at each step, there is always an optimal answer which is a superset of the current state. Thus, the final answer is optimal.-->

>因此存在一个包含最大缺口的最优解，所以在每一步，总存在一个包含当前状态的最优解。因此，得到的解是最优的。

这是我比较喜欢的一个贪心法正确性证明的例子（虽然这里写得不是很严格）。这很显然是两种贪心法证明（exchange和stay ahead）中的exchange，其主要步骤为[^exchange]：

* 用符号分别对贪心算法得到的解和最优解进行表示
* 将贪心解和最优解进行比较（假设两者不等），则可能
  * 两者含有不同的元素（如上述证明中的不同的缺口）
  * 两者元素顺序不同
* 对最优解中的元素进行修改，使得最优解更接近于贪心解，同时不比之前更差。继续进行修改，直到最优解与贪心解相同，这就证明了贪心解即最优解

[^exchange]: [Greedy Exchange](http://www.cs.cornell.edu/courses/cs482/2003su/handouts/greedy_exchange.pdf)

<!--Conclusions-->

## 总结

<!--If a greedy solution exists, use it. They are easy to code, easy to debug, run quickly, and use little memory, basically defining a good algorithm in contest terms. The only missing element from that list is correctness. If the greedy algorithm finds the correct answer, go for it, but don't get suckered into thinking the greedy solution will work for all problems.-->

>假如贪心法存在，可以用它。贪心法容易编写，调试方便，运行速度快，使用的内存少，这使得它在竞赛中不失为一个优秀算法。这里唯一没有提到的问题是它的正确性。如果贪心法能找到正确答案，就用它吧，但不要把时间浪费在试图把贪心算法应用于任何问题上。

（不过大部分情况下正确性是死结吧！）

<!--Sample Problems-->

## 其他例题

<!--Sorting a three-valued sequence [IOI 1996]-->

### 对三值序列排序（IOI 1996）

<!--You are given a three-valued (1, 2, or 3) sequence of length up to 1000. Find a minimum set of exchanges to put the sequence in sorted order.-->

>给定一个长度最大为1000的三值序列（只包含1、2和3），找出总数最小的能将该序列排序的交换操作的集合。


#### 算法

<!--The sequence has three parts: the part which will be 1 when in sorted order, 2 when in sorted order, and 3 when in sorted order. The greedy algorithm swaps as many as possible of the 1's in the 2 part with 2's in the 1 part, as many as possible 1's in the 3 part with 3's in the 1 part, and 2's in the 3 part with 3's in the 2 part. Once none of these types remains, the remaining elements out of place need to be rotated one way or the other in sets of 3. You can optimally sort these by swapping all the 1's into place and then all the 2's into place.-->

>序列由三个区域组成：第一个区域在排序后都是1，第二个区域在排序后都是2，第三个区域都是3。贪心算法尽量把位于区域二中的1和位于区域一中的2交换，把位于区域三中的1和位于区域一中的3交换，把位于区域三中的2和区域二中的3交换。将这些类型交换完后，剩余的不在正确区域的元素需要在某种意义上进行旋转。你可以通过首先把所有1交换到区域一中，再把所有2交换到区域二中完成最优排序。

事实上“旋转”的意思类似于置换，就像下面的证明中说的那样，三个数需要两次交换才能回到正确位置。

#### 分析

<!--Obviously, a swap can put at most two elements in place, so all the swaps of the first type are optimal. Also, it is clear that they use different types of elements, so there is no ``interference'' between those types. This means the order does not matter. Once those swaps have been performed, the best you can do is two swaps for every three elements not in the correct location, which is what the second part will achieve (for example, all the 1's are put in place but no others; then all that remains are 2's in the 3's place and vice-versa, and which can be swapped).-->

>显然，一次交换最多能将两个元素复位，所以所有的第一类交换操作都是最优的。而且，很显然不同的第一类操作交换的元素类型都是不同的，所以不同类型的操作之间没有“相互干渉”。这意味着交换的顺序对结果没有影响。完成所有第一类交换操作之后，最优的交换方法就是将不在正确位置的三个元素通过两次交换复位，这就是第二类交换操作将完成的（比如，所有的1都归位了，所有的2都在区域三，反之亦然，这可以进行交换）。

这似乎只是一个分析，而不是证明。（以及我没看懂他那个比如……）但是我还真的不知道该怎么证……目前的一个初步的想法是，假设一个最优的交换操作序列，证明它的一些比较好的性质（比如把一个元素归位之后就不会再动它了之类的），然后也用exchange的方法去做。

我刚才脑子一晕，还以为操作的总数应该等于逆序对的数量（不，那是冒泡排序）。实际上好像可以严格证明排序到底最少需要多少次swap操作。[^swaps]所以可能不宜把这个题当做是一道贪心来证明。但是因为有重复元素，所以比较困难。

[^swaps]: [Minimum number of swaps required to sort an array](https://www.geeksforgeeks.org/minimum-number-swaps-required-sort-array/)

<!--Friendly Coins - A Counterexample [abridged]-->

### 友好的硬币——一个反例（有删节）

<!--Given the denominations of coins for a newly founded country, the Dairy Republic, and some monetary amount, find the smallest set of coins that sums to that amount. The Dairy Republic is guaranteed to have a 1 cent coin.-->

>给定一个新建立的国家（乳品共和国）的硬币面值和一些钱数，找出最小的和等于钱数的硬币集合。保证乳品共和国有1分硬币。

#### 算法

<!--Take the largest coin value that isn't more than the goal and iterate on the total minus this value.-->

>找出最大的不大于目标值的硬币，将目标钱数减去该硬币，然后继续直到完成。

#### （错误的）分析

<!--(Faulty) Analysis: Obviously, you'd never want to take a smaller coin value, as that would mean you'd have to take more coins to make up the difference, so this algorithm works.-->

>显然你绝不会想要拿一个面值更小的硬币，因为这意味着你需要拿更多的硬币以补上缺的部分，所以这个算法是正确的。

#### （大概没错的）分析

<!--Maybe not: Okay, the algorithm usually works. In fact, for the U.S. coin system {1, 5, 10, 25}, it always yields the optimal set. However, for other sets, like {1, 5, 8, 10} and a goal of 13, this greedy algorithm would take one 10, and then three 1's, for a total of four coins, when the two coin solution {5, 8} also exists.-->

>好吧，这个算法通常是正确的。事实上，对于美国硬币系统（1、5、10、25），这一算法总会输出最优解。但是，对于其他系统，如1、5、8、10和目标值13，贪心算法会拿一个10和三个1，总共为4个硬币；而实际上最优解是拿8和5。

这说明贪心算法还是很可能不对的。这个问题的正解大概是回溯法。

<!--Topological Sort-->

### 拓扑排序

<!--Given a collection of objects, along with some ordering constraints, such as "A must be before B," find an order of the objects such that all the ordering constraints hold.-->

>给定一系列对象，以及一些顺序约束，如“A必须在B前面”，找出一个对象的顺序，满足全部约束。

#### 算法

<!--Algorithm: Create a directed graph over the objects, where there is an arc from A to B if "A must be before B." Make a pass through the objects in arbitrary order. Each time you find an object with in-degree of 0, greedily place it on the end of the current ordering, delete all of its out-arcs, and recurse on its (former) children, performing the same check. If this algorithm gets through all the objects without putting every object in the ordering, there is no ordering which satisfies the constraints.-->

>以对象为结点创建一个有向图，如果“A必须在B前面”，就从A到B创建一条边。以随机顺序遍历所有对象。每次你发现一个入度为0的的对象，就贪心地把它放在当前顺序序列的末尾，删除所有它的出边，然后对它（之前）的孩子结点执行相同的检查。如果算法遍历了所有对象，却没能把每个对象都放入顺序序列中，说明没有顺序能满足所有约束。

好吧，拓扑排序也是一种贪心算法。这个要证明起来还是比较容易的（而且，对于拓扑排序存在的情况，实际上没有“最优解”可言，都是可行解）：每找到一个入度为0的结点，说明它要么没有约束，要么所有约束都已经位于序列前面了，所以可以直接把它加入序列。这大概是一种类似于stay ahead[^head]的方法。问题是怎么证明拓扑排序找不到序列的时候，拓扑序是不存在的。大概可以应用反证法。如果存在一个拓扑序列，则在每一步必然可以找到序列中的下一个结点，不可能找不到。

[^head]: [Stays Ahead](http://www.cs.cornell.edu/courses/cs482/2003su/handouts/greedy_ahead.pdf)
