---
title: Leetcode 924. Minimize Malware Spread（图论）
urlname: leetcode-924-minimize-malware-spread
toc: true
date: 2018-10-14 19:49:59
updated: 2018-10-14 21:08:00
tags: [Leetcode, Leetcode Contest, alg:Graph, alg:Depth-first Search, alg:Union-find Forest]
---

题目来源：[https://leetcode.com/problems/minimize-malware-spread/description/](https://leetcode.com/problems/minimize-malware-spread/description/)

标记难度：Hard

提交次数：3/7

代码效率：

* 暴力：256ms
* DFS：216ms
* 并查集：108ms

## 题意

有一个无向图，图中有些结点被感染了，感染会通过图的边传播。现在可以移除一个初始被感染的结点，问移除哪一个结点可以使最终被感染的总结点数最小？如果有多个结点，输出编号最小的一个。

## 分析

我比赛的时候居然交了4次……

* 第一次写了一个巨暴力的方法：每次移除一个初始感染结点，然后用DFS计算被感染结点总数。然后我还没写对。题目表明“使一个结点初始不被感染，它仍然有可能被传播到感染”，所以直接把结点从图里去掉是不可取的。而且很不幸的是，我还把`graph`当成邻接表了（事实上应该是邻接矩阵）。
* 第二次我尝试调这个暴力，但是我对题意产生了一点误解：如果有多个合法结点，是输出在`vector<int> initial`中index最小的结点，还是输出编号最小的结点？事实证明应该是编号最小的结点，但我这一次改成了index最小，那自然是没有什么对的可能了。
* 第三次我还在调这个暴力，但并没有发现核心问题。
* 第四次我仍然在调这个暴力，此时发现了`graph`的问题，但还是对题目内容有着非常深刻的误解。（而且此时已经10:55了。）

其实交第一次之前我是想到了正解的（无论是用DFS，还是并查集），但紧接着我就由于各种原因把题给看错了……这可真是太不可取了。

---

上面说的暴力算法的复杂度应该是`O(M * N + M)`（`M = initial.length`，`N = graph.length`）。原来这样就能过了吗……不愧是`1 <= graph.length <= 300`。

### DFS

这个思路很容易想到。用DFS对图中的连通分量（如果我没有搞错图论术语的话）进行染色，这样就可以知道每个结点对应的连通分量和连通分量的大小了；然后统计每个连通分量中所包含的初始感染结点的数量，如果该连通分量只包含一个初始感染结点，则移除该感染结点可以防止整个连通分量的结点受到感染；否则移除该结点不会改变受感染结点的总数。然后取最小值即可。

DFS的时间复杂度是`O(N)`，统计结点数量的复杂度是`O(M)`，总复杂度为`O(N + M)`。

### 并查集

这个思路和DFS基本类似，只是换成用并查集来进行着色而已。[^lee215]

[^lee215]: [lee215's Union Found Solution](https://leetcode.com/problems/minimize-malware-spread/discuss/181129/Python-Union-Found)

## 代码

### 暴力

```cpp
class Solution {
private:
    int n;

    void dfs(int x, vector<vector<int>>& graph, int& cnt, bool visited[]) {
        for (int i = 0; i < n; i++) {
            if (graph[x][i] && !visited[i]) {
                cnt++;
                visited[i] = true;
                dfs(i, graph, cnt, visited);
            }
        }
    }

public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        n = graph.size();
        bool visited[n];
        int minimum = n + 1, index = -1;
        sort(initial.begin(), initial.end());
        for (int i = 0; i < initial.size(); i++) {
            memset(visited, 0, sizeof(visited));
            // remove i
            int cnt = 0;
            for (int j = 0; j < initial.size(); j++) {
                if (j != i && !visited[initial[j]]) {
                    visited[initial[j]] = true;
                    cnt++;
                    dfs(initial[j], graph, cnt, visited);
                }
            }
            //cout << initial[i] << ' ' << cnt << endl;
            if (cnt < minimum) {
                minimum = cnt;
                index = initial[i];
            }
        }
        return index;
    }
};
```

### DFS

```cpp
class Solution {
private:
    int n;

    void dfs(int x, int c, vector<vector<int>>& graph, int color[], int colorNum[]) {
        for (int y = 0; y < n; y++)
            if (graph[x][y] && !color[y]) {
                color[y] = c;
                colorNum[c]++;
                dfs(y, c, graph, color, colorNum);
            }
    }

public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        n = graph.size();
        // color the graph
        int color[n + 1], colorNum[n + 1];
        memset(color, 0, sizeof(color));
        int c = 1;
        for (int i = 0; i < n; i++) {
            if (!color[i]) {
                color[i] = c;
                colorNum[c] = 1;
                dfs(i, c, graph, color, colorNum);
                c++;
            }
        }
        // find colors of initials
        // 此处也可以不排序的，多加一些特判就行了……
        sort(initial.begin(), initial.end());
        int initialsInColors[n + 1];
        memset(initialsInColors, 0, sizeof(initialsInColors));
        for (int x: initial) {
            initialsInColors[color[x]]++;
        }
        int maxn = -1, index = -1;
        for (int x: initial) {
            if (initialsInColors[color[x]] <= 1 && colorNum[color[x]] > maxn) {
                maxn = colorNum[color[x]];
                index = x;
            }
            else if (initialsInColors[color[x]] > 1 && 0 > maxn) {
                maxn = 0;
                index = x;
            }
        }
        return index;
    }
};
```

### 并查集

```cpp
class Solution {
private:
    int n;

    int fa[305], cnt[305];

    void init() {
        for (int i = 0; i < n; i++) {
            fa[i] = i;
            cnt[i] = 1;
        }
    }

    int find(int x) {
        if (x == fa[x]) return x;
        else {
            cnt[fa[x]] += cnt[x];
            cnt[x] = 0;
            return fa[x] = find(fa[x]);
        }
    }

    int getcnt(int x) {
        return cnt[find(x)];
    }

    void merge(int x, int y) {
        x = find(x);
        y = find(y);
        if (cnt[x] >= cnt[y]) swap(x, y);
        fa[x] = y;
        find(x);
    }

public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        n = graph.size();
        init();
        for (int i = 0; i < n; i++)
            for (int j = i + 1; j < n; j++)
                if (graph[i][j])
                    merge(i, j);
        int facnt[n];
        memset(facnt, 0, sizeof(facnt));
        for (int x: initial)
            facnt[find(x)]++;
        int maxn = -1, index = n + 1;
        for (int x: initial) {
            if (facnt[find(x)] <= 1 && (getcnt(x) > maxn || getcnt(x) == maxn && x < index)) {
                maxn = getcnt(x);
                index = x;
            }
            else if (0 > maxn || maxn == 0 && x < index) {
                maxn = 0;
                index = x;
            }
        }
        return index;
    }
};
```
