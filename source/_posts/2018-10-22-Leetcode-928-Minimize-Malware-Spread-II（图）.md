---
title: Leetcode 928. Minimize Malware Spread II（图）
urlname: leetcode-928-minimize-malware-spread-ii
toc: true
date: 2018-10-22 00:39:12
updated: 2018-10-22 01:31:00
tags: [Leetcode, Leetcode Contest, alg:Graph, alg:Depth-first Search, alg:Union-find Forest]
---

题目来源：[https://leetcode.com/problems/minimize-malware-spread-ii/description/](https://leetcode.com/problems/minimize-malware-spread-ii/description/)

标记难度：Hard

提交次数：2/2

代码效率：

* 暴力DFS：104ms
* 优化过的DFS：108ms
* 优化过的并查集：懒得写了

## 题意

有一个无向图，图中有些结点被感染了，感染会通过图的边传播。现在可以移除一个初始被感染的结点（是移除，而不是让它不被感染），问移除哪一个结点可以使最终被感染的总结点数最小？如果有多个结点，输出编号最小的一个。

## 分析

呃，这道题的题意正好和我[上次](/post/leetcode-924-minimize-malware-spread)看错的是一样的……于是我当然直接用了最暴力的方法，手动模拟每个初始感染结点被删除之后的感染状况。当然我觉得这种方法看起来还不差，因为DFS的复杂度是`O(N)`，DFS`N`次的复杂度就是`O(N^2)`；不过显然我这样想的时候没有考虑到题目里给出的图是邻接矩阵表示（而非邻接表），所以实际复杂度应该是`O(N^3)`。不过反正`N <= 300`，N^2和N^3也差不多。（……）

### 优化过的DFS

首先将所有初始感染结点从图里移除；然后对于每个初始感染结点，通过DFS找到它能够感染的结点集合；然后对于每个普通结点，找出它会被多少个结点感染。如果它只能被某一个结点感染，移除该结点就可以使得该普通结点不会被感染。然后找到其中的最大值即可。[^solution]

[^solution]: [Leetcode Official Solution for 928. Minimize Malware Spread II](https://leetcode.com/problems/minimize-malware-spread-ii/solution/)

我的一个疑惑是，为何是把所有初始感染结点都移除，而不是把所有的结点都留在图里，然后找到某一个结点能感染的结点集合？这两点的区别显然是，把其他的结点留在图里之后，某一个结点能感染的结点集合就会变大，甚至包含一些移除了别的结点之后不能被感染的结点，这大约是不合适的。

另一个问题是，考虑到邻接矩阵的问题，这个方法的时间复杂度是不是仍然是`O(N^3)`……事实证明运行时间差不多。

### 优化过的并查集

这个方法的思路和上一个差不多，不过是把DFS换成并查集，然后判断每个分量和多少个初始感染结点相邻。（就是写得更明白一点了。）我感觉这个方法是`O(N^2)`的（因为相比DFS节省了很多无用的计算），不过我现在不是很想写了。[^solution]

## 代码

### 暴力DFS

```cpp
class Solution {
private:
    void dfs(int cur, vector<vector<int>>& graph, int &cnt, const int& removed, bool visited[]) {
        for (int y = 0; y < graph[cur].size(); y++) {
            if (graph[cur][y] && !visited[y] && y != removed) {
                visited[y] = true;
                cnt++;
                dfs(y, graph, cnt, removed, visited);
            }
        }
    }

public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // completely remove
        sort(initial.begin(), initial.end());
        int n = graph.size();
        int ans = n + 1, index = -1;
        bool visited[n];
        for (int x: initial) {
            memset(visited, false, sizeof(visited));
            int cnt = 0;
            for (int y: initial) {
                if (x != y && !visited[y]) {
                    visited[y] = true;
                    cnt++;
                    dfs(y, graph, cnt, x, visited);
                }
            }
            if (cnt < ans) {
                index = x;
                ans = cnt;
            }
        }
        return index;
    }
};
```

### 优化过的DFS

```cpp
class Solution {
private:
    void dfs(int cur, const int& x, vector<vector<int>>& graph, bool isRemoved[], unordered_set<int> affect[]) {
        for (int i = 0; i < graph.size(); i++) {
            if (graph[cur][i] && !isRemoved[i] && affect[x].find(i) == affect[x].end()) {
                affect[x].insert(i);
                dfs(i, x, graph, isRemoved, affect);
            }
        }
    }

public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        bool isRemoved[n];
        memset(isRemoved, 0, sizeof(isRemoved));
        for (int x: initial)
            isRemoved[x] = true;

        // 分别DFS
        unordered_set<int> affect[n];
        for (int x: initial) {
            isRemoved[x] = false;
            affect[x].insert(x);
            dfs(x, x, graph, isRemoved, affect);
            isRemoved[x] = true;
        }

        // 每个结点会被哪些结点感染
        unordered_set<int> affectedBy[n];
        for (int i = 0; i < n; i++) {
            for (int x: affect[i])
                affectedBy[x].insert(i);
        }

        // 只被一个结点感染的结点
        int singleCnt[n];
        memset(singleCnt, 0, sizeof(singleCnt));
        for (int i = 0; i < n; i++) {
            if (!isRemoved[i] && affectedBy[i].size() == 1)
                singleCnt[*affectedBy[i].begin()]++;
        }

        // 取最大值
        int index = -1, maximum = -1;
        for (int i = 0; i < n; i++) {
            if (isRemoved[i] && singleCnt[i] > maximum) {
                index = i;
                maximum = singleCnt[i];
            }
        }

        return index;
    }
};
```
