---
title: 2017年清华大学保研机试第3题：多项式求和（数学）
urlname: 2017-thupub-3-polynomial
toc: true
mathjax: true
date: 2018-12-04 17:27:43
updated: 2018-12-10 01:52:00
tags: [alg:Math]
---

## 题意

给定$n$，$m$，$a$，求解

{% raw %}
$$
S(n) = \sum_{k=0}^n \left( a^k \sum_{i=0}^m b_i k^i \right)
$$
{% endraw %}

其中$n \leq 10^9$，$m \leq 100$，$a \leq 10^9$。

其中每个测试点的具体情况：

![测试点具体情况](testpoints.png)

## 分析

### 20分解法：暴力

测试点1-2满足$n \leq 1000$，$m \leq 10$，可以用复杂度为$O(nm^2)$的暴力算法直接解决；通过保存$k^i$的结果，上述复杂度可降低为$O(nm)$。

<script src="https://gist.github.com/zhanghuimeng/f0681c0bc71f6204255c21e91c8e5d58.js?file=polynomial_20pts.cpp"></script>

### 40分解法：暴力+等幂求和公式

在20分解法的基础上，可通过观察发现，测试点3-4满足$a = 1$且$m \leq 2$。此时

{% raw %}
$$
\begin{aligned}
S(n) =& \sum_{k=0}^n \left( a^k \sum_{i=0}^m b_i k^i \right) \\
=& \sum_{k=0}^n \sum_{i=0}^m b_i k^i \\
=& \sum_{i=0}^m \sum_{k=0}^n b_i k^i \\
=& \sum_{i=0}^m \left(b_i \sum_{k=0}^n k^i \right) \\
=& b_0 \sum_{k=0}^n k^0 + b_1 \sum_{k=0}^n k^1 + b_2 \sum_{k=0}^n k^2 \\
=& b_0 (n+1) + b_1 \frac{n(n+1)}{2} + b_2 \frac{n(n+1)(2n+1)}{6}
\end{aligned}
$$
{% endraw %}

可直接通过等幂求和公式进行求解。需要注意在取模情况下除法的处理：在上述简单情况下，可以在取模前就将分母约掉。

<script src="https://gist.github.com/zhanghuimeng/f0681c0bc71f6204255c21e91c8e5d58.js?file=polynomial_40pts.cpp"></script>

### 70分解法1：暴力+等幂求和递推

观察发现，除测试点3-4外，测试点6-8也满足$a=1$，但$m \leq 20$。这意味着像40分解法中那样直接使用等幂求和公式比较困难且容易出错（如果你觉得不困难就当我没说，直接用公式就好了）。

不妨先考虑平方和公式的一种推导过程：

{% raw %}
$$
\begin{aligned}
(n+1)^3 & - & n^3 &= & 3n^2 & + & 3n & + & 1 \\
((n-1)+1)^3 & - & (n-1)^3 &= & 3(n-1)^2 & + & 3(n-1) & + & 1 \\
\vdots & & \vdots & & \vdots & & \vdots & & \vdots \\
(2+1)^3 & - & 2^3 &= & 3\cdot 2^2 & + & 3\cdot2 & + & 1 \\
(1+1)^3 & - & 1^3 &= & 3\cdot 1^2 & + & 3\cdot1 & + & 1 \\
\end{aligned}
$$
{% endraw %}

将上述$n$个等式相加，得到

$$
(n+1)^3 - 1^3 = 3(1^2+2^2+\cdots+n^2) + 3(1+2+\cdots+n) + n
$$

记$T(m) = \sum_{i=0}^n i^m$，则从上式可以得出$T(2)$的递推公式：

$$
T(2) = \frac{(n+1)^3 -3T(1)-T(0)}{3}
$$

（注意$T(0)=n+1$而不是$n$）

通过类似的过程，我们可以推出$T(m)$的递推公式。

{% raw %}
$$
\begin{aligned}
(n+1)^{m+1} & - & n^{m+1} &= & \binom{m+1}{1}n^m & + & \binom{m+1}{2}n^{m-1} & + \cdots + & \binom{m+1}{m+1}1 \\
((n-1)+1)^{m+1} & - & (n-1)^{m+1} &= & \binom{m+1}{1}(n-1)^m & + & \binom{m+1}{2}(n-1)^{m-1} & + \cdots + & \binom{m+1}{m+1}1 \\
\vdots &  & \vdots & & \vdots &  & \vdots &  & \vdots \\
(1+1)^{m+1} & - & 1^{m+1} &= & \binom{m+1}{1}1^m & + & \binom{m+1}{2}1^{m-1} & + \cdots + & \binom{m+1}{m+1}1 \\
\end{aligned}
$$
{% endraw %}

将上述$n$个等式求和，可得

$$
(n+1)^m - 1^m = \binom{m+1}{1}T(m) + \binom{m+1}{2}T(m-1) + \cdots \binom{m+1}{m+1} (T(0) - 1)
$$

写成递推$T(m)$的形式：

$$
T(m) = \frac{(n+1)^m  - \binom{m+1}{2}T(m-1) - \cdots - \binom{m+1}{m+1} T(0)}{m+1}
$$

用上述公式即可对$T(m)$进行递推求解，时间复杂度为$O(m^2)$。

<script src="https://gist.github.com/zhanghuimeng/f0681c0bc71f6204255c21e91c8e5d58.js?file=polynomial_70pts.cpp"></script>


### 80分解法：矩阵快速幂

将$S(n)$改写为下列形式：

{% raw %}
$$
\begin{aligned}
S(n) =& \sum_{k=0}^n \left( a^k \sum_{i=0}^m b_i k^i \right) \\
=& \sum_{k=0}^n \sum_{i=0}^m a^k b_i k^i \\
=& \sum_{i=0}^m b_i \sum_{k=0}^n a^k k^i
\end{aligned}
$$
{% endraw %}

记$T(i) = \sum_{k=0}^n a^k k^i$，$t(i, k) = a^k k^i$，则$T(i) = \sum_{k=0}^n t(i, k)$。下面尝试寻找$t(i, k)$的递推公式。

{% raw %}
$$
\begin{aligned}
t(i, k+1) =& a^{k+1} (k+1)^i \\
=& a^{k+1}\left[\binom{i}{i} k^i + \binom{i}{i-1}k^{i-1} + \cdots + \binom{i}{0} 1 \right] \\
=& a\left[\binom{i}{i} t(i,k) + \binom{i}{i-1} t(i-1, k) + \cdots + \binom{i}{0} t(0, k) \right] \\
\end{aligned}
$$
{% endraw %}

由上述递推公式出发，不妨令向量$\vec{t}(k) = [t(0, k), t(1, k), \cdots, t(i, k)]^T$，则可得到：

{% raw %}
$$
\vec{t}(k+1) = 
\begin{bmatrix}
t(0,k+1) \\
t(1, k+1) \\
t(2, k+1) \\
\vdots \\
t(i, k+1)
\end{bmatrix}
=
\begin{bmatrix}
\binom{0}{0} a & 0 & 0 & \cdots & 0 \\
\binom{1}{0} a & \binom{1}{1} a & 0 & \cdots & 0 \\
\binom{2}{0} a & \binom{2}{1} a & \binom{2}{2} a & \cdots & 0 \\
\vdots & \vdots & \vdots & \ddots & \vdots \\
\binom{i}{0} a & \binom{i}{1} a & \binom{i}{2} a & \cdots & \binom{i}{i} a
\end{bmatrix}
\begin{bmatrix}
t(0,k) \\
t(1, k) \\
t(2, k) \\
\vdots \\
t(i, k)
\end{bmatrix}
\leftarrow \vec{t}(k)
$$
{% endraw %}

用$A$表示中间的矩阵，则可以得到一个用矩阵快速幂求解$t(i, k)$的方法。问题是，我们不是要求解$t(i, k)$，而是要对每个$i$求解$T(i) = \sum_{k=0}^n t(i, k)$。所以需要对上述公式进行一些修改。

令向量

{% raw %}
$$\vec{t'}(k) =
\begin{bmatrix}
\vec{t}(k) \\
\sum_{k'=0}^{k-1} t(i,k')
\end{bmatrix} =
\begin{bmatrix}
t(0,k) \\
t(1, k) \\
t(2, k) \\
\vdots \\
t(i, k) \\
\sum_{k'=0}^{k-1} t(i,k')
\end{bmatrix}
$$
{% endraw %}

（注意右下角的求和是0到$k-1$，不是$k$。）

则

{% raw %}
$$
\vec{t'}(k+1) =
\begin{bmatrix}
t(0, k+1) \\
t(1, k+1) \\
t(2, k+1) \\
\vdots \\
t(i, k+1) \\
\sum_{k'=0}^{k} t(i,k')
\end{bmatrix}
=
\begin{bmatrix}
\binom{0}{0} a & 0 & 0 & \cdots & 0 & 0\\
\binom{1}{0} a & \binom{1}{1} a & 0 & \cdots & 0 & 0\\
\binom{2}{0} a & \binom{2}{1} a & \binom{2}{2} a & \cdots & 0 & 0\\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
\binom{i}{0} a & \binom{i}{1} a & \binom{i}{2} a & \cdots & \binom{i}{i} a & 0 \\
0 & 0 & 0 & \cdots & 1 & 1
\end{bmatrix}
\begin{bmatrix}
t(0, k) \\
t(1, k) \\
t(2, k) \\
\vdots \\
t(i, k) \\
\sum_{k'=0}^{k-1} t(i,k')
\end{bmatrix}
\leftarrow \vec{t'}(k)
$$
{% endraw %}

记中间的矩阵为$A'$，那么我们找到了一种计算$T(i)$的矩阵快速幂方法。

以及，事实上，$t(i, k) = a^k k^i$在$k=0$时，当且仅当$i$也为0时才不是0，所以$\vec{t'}(0) = [1, 0, \cdots, 0, 0]^T$；从矩阵乘法的性质可知，$T(i)$即为${A'}^{n+1}$的左下角元素。

上述算法的复杂度为$O(m^4\log{n})$，可以通过测试点1-8。

<script src="https://gist.github.com/zhanghuimeng/f0681c0bc71f6204255c21e91c8e5d58.js?file=polynomial_80pts.cpp"></script>

## 100分解法：改进的矩阵快速幂

在80分的矩阵快速幂解法中，可以观察到，实际上很多$t(i, k)$的值经过了重复计算。所以不妨尝试把$b_i$也加到计算过程中，直接对$S(n)$进行求和。

{% raw %}
$$
\begin{aligned}
S(n) =& \sum_{i=0}^m b_i T(i) \\
=&  \sum_{i=0}^m \sum_{k=0}^n b_i t(i, k) \\
\end{aligned}
$$
{% endraw %}

所以只需要求解一遍所有的$t(i, k)$，并乘上相应的系数$b_i$即可。

令向量

{% raw %}
$$\vec{s}(k) =
\begin{bmatrix}
\vec{t}(k)_{i=m} \\
\sum_{i=0}^m \sum_{k'=0}^{k-1} b_i t(i,k')
\end{bmatrix} =
\begin{bmatrix}
t(0, k) \\
t(1, k) \\
t(2, k) \\
\vdots \\
t(m, k) \\
\sum_{i=0}^m \sum_{k'=0}^{k-1} b_i t(i,k')
\end{bmatrix}
$$
{% endraw %}

则

{% raw %}
$$ \vec{s}(k+1) =
\begin{bmatrix}
t(0, k+1) \\
t(1, k+1) \\
t(2, k+1) \\
\vdots \\
t(m, k+1) \\
\sum_{i=0}^m \sum_{k'=0}^{k} b_i t(i,k')
\end{bmatrix}
=
\begin{bmatrix}
\binom{0}{0} a & 0 & 0 & \cdots & 0 & 0\\
\binom{1}{0} a & \binom{1}{1} a & 0 & \cdots & 0 & 0\\
\binom{2}{0} a & \binom{2}{1} a & \binom{2}{2} a & \cdots & 0 & 0\\
\vdots & \vdots & \vdots & \ddots & \vdots & \vdots \\
\binom{m}{0} a & \binom{m}{1} a & \binom{m}{2} a & \cdots & \binom{m}{m} a & 0 \\
b_0 & b_1 & b_2 & \cdots & b_m & 1
\end{bmatrix}
\begin{bmatrix}
t(0, k) \\
t(1, k) \\
t(2, k) \\
\vdots \\
t(m, k) \\
\sum_{i=0}^m \sum_{k'=0}^{k-1} b_i t(i,k')
\end{bmatrix}
=\vec{s}(k)
$$
{% endraw %}

然后即可用矩阵快速幂的方法进行求解，复杂度为$O(m^3\log{n})$。记中间的矩阵为$B$，同理，$\vec{s}(0) = [1, 0, \cdots, 0, 0]^T$，从矩阵乘法的性质可知，$S(n)$即为${B}^{n+1}$的左下角元素。

代码可能需要对下三角方阵的乘法进行优化才能不超时。

<script src="https://gist.github.com/zhanghuimeng/f0681c0bc71f6204255c21e91c8e5d58.js?file=polynomial_100pts.cpp"></script>
