---
title: 翻译：欧拉路（USACO）
urlname: eulerian-tour-usaco-translation
toc: true
date: 2019-02-09 20:54:04
updated: 2019-02-09 20:54:04
tags: [Translation, USACO]
---

这是几乎全部机翻的版本。几乎可以肯定的是，这个翻译需要改进。

<!-- Sample Problem: Riding The Fences -->

## 例题：穿越栅栏

<!-- Farmer John owns a large number of fences, which he must periodically check for integrity. Farmer John keeps track of his fences by maintaining a list of their intersection points, along with the fences which end at each point. Each fence has two end points, each at an intersection point, although the intersection point may be the end point of only a single fence. Of course, more than two fences might share an endpoint. -->

>农夫约翰拥有大量围栏，他必须定期检查它们的完整性。农民约翰通过维护围栏的交叉点列表，以及在每个交叉点点结束的围栏来跟踪它们。每个围栏有两个端点，每个端点位于一个交叉点，交叉点可能只是单个围栏的终点。当然，两个以上的围栏也可能共享一个端点。

<!-- Given the fence layout, calculate if there is a way for Farmer John to ride his horse to all of his fences without riding along a fence more than once. Farmer John can start and end anywhere, but cannot cut across his fields (the only way he can travel between intersection points is along a fence). If there is a way, find one way. -->

>给定围栏的布局，计算农夫约翰是否有办法骑马去他所有的围栏，且不需要不止一次地穿越围栏。约翰可以在任何地方开始和结束，但不能穿过他的田地（在交叉点之间穿行的唯一方法是沿着围栏）。如果有方法，找出一种方法。

<!-- The Abstraction -->

## 问题的抽象

<!-- Given: An undirected graph -->

>给定：无向图

<!-- Find a path which uses every edge exactly once. This is called an Eulerian tour. If the path begins and ends at the same vertex, it is called a Eulerian circuit. -->

>找到一条只使用每条边一次的路径。这样的路径称为欧拉路径。如果路径在同一顶点开始和结束，则称为欧拉回路。

<!-- The Algorithm -->

## 算法

<!-- Detecting whether a graph has an Eulerian tour or circuit is actually easy; two different rules apply. -->

>检查图中是否有欧拉路径或回路实际上很容易; 使用下列两条规则。

<!-- A graph has an Eulerian circuit if and only if it is connected (once you throw out all nodes of degree 0) and every node has `even degree'. -->
<!-- A graph has an Eulerian path if and only if it is connected and every node except two has even degree. -->
<!-- In the second case, one of the two nodes which has odd degree must be the start node, while the other is the end node. -->

>* 图中有欧拉回路，当且仅当它是连通图（在去掉度数为0的所有结点之后），且每个结点具有“偶数度”。
>* 图中有欧拉路径，当且仅当它是连通图，且除了两个结点之外的每个结点的度数均为偶数。
>* 在第二种情况下，具有奇数度的两个结点中的一个必须是起始结点，而另一个是结束结点。

<!-- The basic idea of the algorithm is to start at some node the graph and determine a circuit back to that same node. Now, as the circuit is added (in reverse order, as it turns out), the algorithm ensures that all the edges of all the nodes along that path have been used. If there is some node along that path which has an edge that has not been used, then the algorithm finds a circuit starting at that node which uses that edge and splices this new circuit into the current one. This continues until all the edges of every node in the original circuit have been used, which, since the graph is connected, implies that all the edges have been used, so the resulting circuit is Eulerian. -->

>算法的基本思想是从图的某个结点开始，并确定回到同一结点的回路。现在，随着回路的添加（事实上是以逆序），算法确保从该路径上所有结点出发的所有边都已被使用。如果该路径上还存在一些具有未使用的边的结点，则算法找到从该结点开始的使用这条边的回路，并将该新回路拼接到当前回路中。这一直持续到原始回路中每个结点的所有边都被使用为止，由于图是连通的，这意味着已经使用了所有边，因此得到的回路是欧拉回路。

<!-- More formally, to determine a Eulerian circuit of a graph which has one, pick a starting node and recurse on it. At each recursive step: -->

>更正式地说，要确定一个含有欧拉回路的图中的欧拉回路，选择一个起始结点并对其进行递归。在每个递归步骤中：

<!-- Pick a starting node and recurse on that node. At each step: -->
<!-- If the node has no neighbors, then append the node to the circuit and return -->
<!-- If the node has a neighbor, then make a list of the neighbors and process them (which includes deleting them from the list of nodes on which to work) until the node has no more neighbors -->
<!-- To process a node, delete the edge between the current node and its neighbor, recurse on the neighbor, and postpend the current node to the circuit. -->

>* 选择一个起始结点并对该结点进行递归。在每一步中：
>  * 如果结点没有邻居，则将结点加入到回路中并返回
>  * 如果结点具有邻居，则创建邻居列表并对其进行处理（包括从需要处理的结点列表中删除它们），直到该节点不再有邻居为止
>  * 为了处理结点，删除当前结点与其邻居之间的边，递归邻居，然后将当前结点加入到电路中。

<!-- And here's the pseudocode: -->

>这是伪代码：

```py
# circuit是一个全局数组
find_euler_circuit
    circuitpos = 0
    find_circuit(node 1)

# nextnode和visited是局部数组
# 将以逆序找到路径
find_circuit(node i)
    if 结点i没有邻居 then
      circuit(circuitpos) = 结点i
      circuitpos = circuitpos + 1
    else
      while (结点i有邻居)
          随机选择结点i的邻居结点j
          delete_edges (结点j, 结点i)
          find_circuit (结点j)
      circuit(circuitpos) = 结点i
      circuitpos = circuitpos + 1
```

<!-- To find an Eulerian tour, simply find one of the nodes which has odd degree and call find_circuit with it. -->

>为了找到欧拉路径，只需找到其中一个具有奇数度的结点，并对它调用`find_circuit`。

<!-- Both of these algorithms run in O(m + n) time, where m is the number of edges and n is the number of nodes, if you store the graph in adjacency list form. With larger graphs, there's a danger of overflowing the run-time stack, so you might have to use your own stack. -->

>这两种算法的时间复杂度都是O(m + n)，其中m是边数，n是结点数，如果图是以邻接表形式存储的话。对于较大的图，存在运行时栈溢出的风险，因此你可能需要使用自己的栈。

<!-- Execution Example -->

## 执行示例

<!-- Consider the following graph:  -->

>考虑下图：

![](euler1.gif)

<!-- Assume that selecting a random neighbor yields the lowest numbered neighbor, the execution goes as follows: -->

>假设选择随机邻居时选择的是编号最小的邻居，算法执行过程如下：

![](euler2a.gif)

<!-- Stack: 
Location: 1 
Circuit: -->

>栈：
>当前位置：1
>回路：

![](euler2b.gif)

<!-- Stack: 1 
Location: 4 
Circuit: -->

>栈：1
>当前位置：4
>回路：

![](euler2c.gif)

<!-- Stack: 1 4 
Location: 2 
Circuit: -->

>栈：1 4
>当前位置：2
>回路：

![](euler2d.gif)

<!-- Stack: 1 4 2 
Location: 5 
Circuit: -->

>栈：1 4 2
>当前位置：5
>回路：

![](euler2e.gif)

<!-- Stack: 1 4 2 5 
Location: 1 
Circuit: -->

>栈：1 4 2 5
>当前位置：1
>回路：

![](euler2e.gif)

<!-- Stack: 1 4 2 
Location: 5 
Circuit: 1 -->

>栈：1 4 2
>当前位置：5
>回路：1

![](euler2f.gif)

<!-- Stack: 1 4 2 5 
Location: 6 
Circuit: 1 -->

>栈：1 4 2 5
>当前位置：6
>回路：1

![](euler2g.gif)

<!-- Stack: 1 4 2 5 6 
Location: 2 
Circuit: 1 -->

>栈：1 4 2 5 6
>当前位置：2
>回路：1

![](euler2h.gif)

<!-- Stack: 1 4 2 5 6 2 
Location: 7 
Circuit: 1 -->

>栈：1 4 2 5 6 2
>当前位置：7
>回路：1

![](euler2i.gif)

<!-- Stack: 1 4 2 5 6 2 7 
Location: 3 
Circuit: 1 -->

>栈：1 4 2 5 6 2 7
>当前位置：3
>回路：1

![](euler2j.gif)

<!-- Stack: 1 4 2 5 6 2 7 3 
Location: 4 
Circuit: 1 -->

>栈：1 4 2 5 6 2 7 3
>当前位置：4
>回路：1

![](euler2k.gif)

<!-- Stack: 1 4 2 5 6 2 7 3 4 
Location: 6 
Circuit: 1 -->

>栈：1 4 2 5 6 2 7 3 4
>当前位置：6
>回路：1

![](euler2l.gif)

<!-- Stack: 1 4 2 5 6 2 7 3 4 6 
Location: 7 
Circuit: 1 -->

>栈：1 4 2 5 6 2 7 3 4 6
>当前位置：7
>回路：1

![](euler2m.gif)

<!-- Stack: 1 4 2 5 6 2 7 3 4 6 7 
Location: 5 
Circuit: 1 -->

>栈：1 4 2 5 6 2 7 3 4 6 7
>当前位置：5
>回路：1

![](euler2m.gif)

<!-- Stack: 1 4 2 5 6 2 7 3 4 6 
Location: 7 
Circuit: 1 5 -->

>栈：1 4 2 5 6 2 7 3 4 6
>当前位置：7
>回路：1 5

![](euler2m.gif)

<!-- Stack: 1 4 2 5 6 2 7 3 4 
Location: 6 
Circuit: 1 5 7 -->

>栈：1 4 2 5 6 2 7 3 4
>当前位置：6
>回路：1 5 7

![](euler2m.gif)

<!-- Stack: 1 4 2 5 6 2 7 3 
Location: 4 
Circuit: 1 5 7 6 -->

>栈：1 4 2 5 6 2 7 3
>当前位置：4
>回路：1 5 7 6

![](euler2m.gif)

<!-- Stack: 1 4 2 5 6 2 7 
Location: 3 
Circuit: 1 5 7 6 4 -->

>栈：1 4 2 5 6 2 7
>当前位置：3
>回路：1 5 7 6 4

![](euler2m.gif)

<!-- Stack: 1 4 2 5 6 2 
Location: 7 
Circuit: 1 5 7 6 4 3 -->

>栈：1 4 2 5 6 2
>当前位置：7
>回路：1 5 7 6 4 3

![](euler2m.gif)

<!-- Stack: 1 4 2 5 6 
Location: 2 
Circuit: 1 5 7 6 4 3 7 -->

>栈：1 4 2 5 6
>当前位置：2
>回路：1 5 7 6 4 3 7

![](euler2m.gif)

<!-- Stack: 1 4 2 5 
Location: 6 
Circuit: 1 5 7 6 4 3 7 2 -->

>栈：1 4 2 5
>当前位置：6
>回路：1 5 7 6 4 3 7 2

![](euler2m.gif)

<!-- Stack: 1 4 2 
Location: 5 
Circuit: 1 5 7 6 4 3 7 2 6 -->

>栈：1 4 2
>当前位置：5
>回路：1 5 7 6 4 3 7 2 6

![](euler2m.gif)

<!-- Stack: 1 4 
Location: 2 
Circuit: 1 5 7 6 4 3 7 2 6 5 -->

>栈：1 4
>当前位置：2
>回路：1 5 7 6 4 3 7 2 6 5

![](euler2m.gif)

<!-- Stack: 1 
Location: 4 
Circuit: 1 5 7 6 4 3 7 2 6 5 2 -->

>栈：1
>当前位置：4
>回路：1 5 7 6 4 3 7 2 6 5 2

![](euler2m.gif)

<!-- Stack: 
Location: 1 
Circuit: 1 5 7 6 4 3 7 2 6 5 2 4 -->

>栈：
>当前位置：1
>回路：1 5 7 6 4 3 7 2 6 5 2 4

![](euler2m.gif)

<!-- Stack: 
Location: 
Circuit: 1 5 7 6 4 3 7 2 6 5 2 4 1 -->

>栈：
>当前位置：
>回路：1 5 7 6 4 3 7 2 6 5 2 4 1

<!-- Extensions -->

## 扩展

<!-- Multiple edges between nodes can be handled by the exact same algorithm. -->

>重边可以通过完全相同的算法来处理。

<!-- Self-loops can be handled by the exact same algorithm as well, if self-loops are considered to add 2 (one in and one out) to the degree of a node. -->

>如果认为自环会为结点度数增加2（一进一出），则自环也可以通过完全相同的算法来处理。

<!-- A directed graph has a Eulerian circuit if it is strongly connected (except for nodes with both in-degree and out-degree of 0) and the indegree of each node equals its outdegree. The algorithm is exactly the same, except that because of the way this code finds the cycle, you must traverse arcs in reverse order. -->

>有向图仅当强连通且每个结点的入度等于出度时才有欧拉回路（除了入度和出度均为0的节点）。算法完全相同，只是由于此代码找到环路的方式，您必须以相反的顺序遍历边。

<!-- Finding a Eulerian path in a directed graph is harder. Consult Sedgewick if you are interested. -->

>在有向图中找到欧拉路径更难。如果您有兴趣，请阅读Sedgewick的书。

<!-- Example problems -->

## 例题

<!-- Airplane Hopping -->

### 飞机跳跃

<!-- Given a collection of cities, along with the flights between those cities, determine if there is a sequence of flights such that you take every flight exactly once, and end up at the place you started. -->

>给定一系列城市，以及这些城市之间的航班，确定是否存在一个航班序列，使得你顺序搭乘每个航班一次，最后回到开始的地方。

<!-- Analysis: This is equivalent to finding a Eulerian circuit in a directed graph. -->

>分析：这相当于在有向图中找到欧拉回路。

<!-- Cows on Parade -->

### 行进中的奶牛

<!-- Farmer John has two types of cows: black Angus and white Jerseys. While marching 19 of their cows to market the other day, John's wife Farmeress Joanne, noticed that all 16 possibilities of four successive black and white cows (e.g., bbbb, bbbw, bbwb, bbww, ..., wwww) were present. Of course, some of the combinations overlapped others. -->

农夫约翰有两种类型的奶牛：黑色安格斯奶牛和白色泽西奶牛。前几天约翰的妻子琼安将19头奶牛赶到市场上时，注意到四只连续黑白奶牛的所有16种可能性（例如，bbbb，bbbw，bbwb，bbww，...，wwww）都存在。当然，有些组合与其他组合重叠。

<!-- Given N (2 <= N <= 15), find the minimum length sequence of cows such that every combination of N successive black and white cows occurs in that sequence. -->

>给定N（2 <= N <= 15），找到最小的奶牛长度序列，使得N个连续的黑色和白色奶牛的每个组合都出现在该序列中。

<!-- Analysis: The vertices of the graph are the possibilities of N-1 cows. Being at a node corresponds to the last N-1 cows matching the node in color. That is, for N = 4, if the last 3 cows were wbw, then you are at the wbw node. Each node has out-degree of 2, corresponding to adding a black or white cow to the end of the sequence. In addition, each node has in-degree of 2, corresponding to whether the cow just before the last N-1 cows is black or white. -->

>分析：图的顶点是N-1头奶牛的可能颜色。位于一个结点处表示最后N-1头奶牛与该结点的颜色匹配。也就是说，对于N = 4，如果最后3头奶牛颜色是wbw，那么你就在wbw节点。每个节点的出度为2，对应于在序列末尾添加黑色或白色奶牛。另外，每个节点的入度为2，对应于最后N-1头奶牛之前的奶牛是黑色还是白色。

嗯……为啥图的顶点是N-1头奶牛的可能颜色，而不是N头呢？

<!-- The graph is strongly connected, and the in-degree of each node equals its out-degree, so the graph has a Eulerian circuit. -->

>图是强连通的，并且每个结点的入度等于出度，因此图中有欧拉回路。

<!-- The sequence corresponding to the Eulerian circuit is the sequence of N-1 cows of the first node in the circuit, followed by cows corresponding to the color of the edge. -->

>和欧拉回路相对应的序列是回路中第一个结点对应的N-1头母牛的序列，之后再加上每条边对应的颜色。