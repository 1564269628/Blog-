---
title: Leetcode水题合集
urlname: leetcode-easy-questions
toc: true
date: 2018-11-28 09:22:54
updated: 2018-12-07 19:29:00
tags: [Leetcode, alg:Linked List]
---

嗯，即使是我，最终也会发现Leetcode中有些题太水了而不值得专门写一篇post，有些题太愚蠢了而不值得专门写一篇post，等等。但有时候还是有一些可写的东西，所以就放在这里好了。

## 在LeetCode中卡时

点开0ms Solution的时候常常会见到这样一段：

```cpp
static int speedup=[](){
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    return 0;
}();
```

函数内部的内容很好理解：关闭C和C++标准输入输出流的同步，并且将`cin`和`cout`解除绑定（在切换时不再自动`flush`）。[^stackoverflow]但外面包的那一堆看起来很不好懂。事实上这是一个立即执行的Lambda表达式。[^lambda]

[^stackoverflow]: [stackoverflow - Significance of ios_base::sync_with_stdio(false); cin.tie(NULL);](https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull)

[^lambda]: [cppreference - Lambda 表达式](https://zh.cppreference.com/w/cpp/language/lambda)

简单来说，Lambda表达式的一种形式是`[captures] (params) {body}`，此时返回值是由`return`语句推导的。例子：

```cpp
// 泛型 lambda ， operator() 是有二个形参的模板
auto glambda = [](auto a, auto&& b) { return a < b; };
bool b = glambda(3, 3.14); // ok

// 泛型 lambda ， operator() 是有一个形参的模板
auto vglambda = [](auto printer) {
    return [=](auto&&... ts) // 泛型 lambda ， ts 是形参包
    { 
        printer(std::forward<decltype(ts)>(ts)...);
        return [=] { printer(ts...); }; // 空型 lambda （不接收参数）
    };
};
auto p = vglambda([](auto v1, auto v2, auto v3) { std::cout << v1 << v2 << v3; });
auto q = p(1, 'a', 3.14); // 输出 1a3.14
q();                      // 输出 1a3.14
```

所以上图就是一个没有参数、返回值为0且立即执行的Lambda表达式。之所以要写成这样好像也很容易理解，全局变量会先初始化，此时就可以在开始真正的输入输出之前进行优化了。如果直接写到函数里，那这个时候都已经完成读入了……

（感谢rd同学告诉我那是个Lambda函数）

## 17. Letter Combinations of a Phone Number

题目来源：[https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/](https://leetcode.com/problems/letter-combinations-of-a-phone-number/description/)

难度：Medium

知识点：字符串

把数字串映射到字母串，每个数字的映射方法是电话按键（例：`2 -> abc`），问一共有多少种可能的映射方法。

直接……做就……好了。

以及，能不硬编码就不要硬编码……

```cpp
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        if (digits.size() == 0) return {};
        
        vector<string> ans = {""};
        vector<string> a2;
        vector<string> maps = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        for (char c: digits) {
            for (string x: ans) {
                for (char a: maps[c - '0'])
                    a2.push_back(x + a);
            }
            swap(ans, a2);
            a2.clear();
        }
        return ans;
    }
};
```

## 23. Merge k Sorted Lists

题目来源：[https://leetcode.com/problems/merge-k-sorted-lists/description/](https://leetcode.com/problems/merge-k-sorted-lists/description/)

难度：Hard

知识点：优先队列

多个有序链表合并。和有序数组合并非常相似，直接用优先队列就好了。

```cpp
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        ListNode* head = nullptr, *p = nullptr;
        priority_queue<pair<int, ListNode*>> pq;
        for (ListNode* q: lists) {
            if (q != nullptr)
                pq.emplace(-q->val, q);
        }
        while (!pq.empty()) {
            ListNode* q = pq.top().second;
            pq.pop();
            if (head == nullptr) {
                head = p = q;
            }
            else {
                p->next = q;
                p = p->next;
            }
            q = q->next;
            if (q != nullptr) pq.emplace(-q->val, q);
        }
        return head;
    }
};
```

## 50. Pow(x, n)

题目来源：[https://leetcode.com/problems/powx-n/description/](https://leetcode.com/problems/powx-n/description/)

难度：Medium

知识点：快速幂

这道题的有趣之处是增加了对负数幂的考察（当然这也不是很难）。不过，在-2147483648上卡一下还是令人不那么愉快……

```cpp
class Solution {
public:
    double myPow(double x, int n) {
        if (n == -2147483648) {
            double y = myPow(x, n / 2);
            return y * y;
        }
        if (n < 0) return myPow(1 / x, -n);
        if (n == 0) return 1;
        if (n == 1) return x;
        double y = myPow(x * x, n / 2);
        if (n % 2 == 0) return y;
        else return y * x;
    }
};
```

## 66. Plus One

题目来源：[https://leetcode.com/problems/plus-one/description/](https://leetcode.com/problems/plus-one/description/)

难度：Easy

知识点：高精度加法

简化版的高精度加法，只考虑+1的情况。唯一的问题可能是在于，数组是正序给的，首位进位稍微有点麻烦。（当然，也可以说：传参是引用，不要直接在参数上改。）

```cpp
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int n = digits.size();
        digits[n-1]++;
        for (int i = n - 1; i > 0; i--) {
            digits[i - 1] += digits[i] / 10;
            digits[i] %= 10;
        }
        if (digits[0] >= 10) {
            digits.insert(digits.begin(), digits[0] / 10);
            digits[1] %= 10;
        }
        return digits;
    }
};
```

## 237. Delete Node in a Linked List

题目来源：[https://leetcode.com/problems/delete-node-in-a-linked-list/description/](https://leetcode.com/problems/delete-node-in-a-linked-list/description/)

难度：Easy

知识点：链表

这道题的傻逼之处在于，明明是要删除链表中的结点，最后却变成了（不得不）交换链表中结点的值，这一点也不科学。我的第一个想法是把给定结点（`node`）之后的值依次前移然后删掉最后一个结点；[题解](https://leetcode.com/articles/delete-node-linked-list/)中给出了只需赋值一次的方法，把`node->val`替换成`node->next->val`，`node->next`也替换成`node->next->next`。但这方法仍然不怎么样。

```cpp
class Solution {
public:
    void deleteNode(ListNode* node) {
        ListNode* p = node;
        while (p->next != nullptr) {
            p->val = p->next->val;
            if (p->next->next == nullptr) break;
            p = p->next;
        }
        p->next = nullptr;
    }
};
```

## 840. Magic Squares In Grid

题目来源：[https://leetcode.com/problems/magic-squares-in-grid/description/](https://leetcode.com/problems/magic-squares-in-grid/description/)

难度：Easy

知识点：数组

（数组是知识点不就相当于没有吗）

这道题就是在一个二维数组里寻找所有可能的三阶幻方。因为判断条件比较多，而三阶幻方的阶数又很小，不如直接对每个3x3的方框进行暴力判断。我写了横纵和的递推，当然事实上对角线之和，以及各个数字的出现次数这些都能递推，但就三阶幻方而言，这么做太大张旗鼓了，还不如直接暴力算了。

```cpp
class Solution {
public:
    int numMagicSquaresInside(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        if (n < 3 || m < 3) return 0;
        
        int ans = 0;
        int downSum[n][m], rightSum[n][m];
        
        for (int i = 0; i < m; i++)
            downSum[0][i] = grid[0][i] + grid[1][i] + grid[2][i];
        for (int i = 1; i <= n - 3; i++)
            for (int j = 0; j < m; j++)
                downSum[i][j] = downSum[i-1][j] - grid[i-1][j] + grid[i+2][j];
        
        for (int i = 0; i < n; i++)
            rightSum[i][0] = grid[i][0] + grid[i][1] + grid[i][2];
        for (int i = 0; i < n; i++)
            for (int j = 1; j <= m - 3; j++)
                rightSum[i][j] = rightSum[i][j-1] - grid[i][j-1] + grid[i][j+2];
        
        int f[20];
        for (int i = 0; i <= n - 3; i++)
            for (int j = 0; j <= m - 3; j++) {
                int sum = rightSum[i][j];
                if (rightSum[i+1][j] != sum || rightSum[i+2][j] != sum || downSum[i][j] != sum 
                    || downSum[i][j+1] != sum || downSum[i][j+2] != sum)
                    continue;
                if (grid[i][j] + grid[i+1][j+1] + grid[i+2][j+2] != sum || grid[i+2][j] + grid[i+1][j+1] + grid[i][j+2] != sum)
                    continue;
                
                memset(f, 0, sizeof(f));
                for (int i1 = 0; i1 < 3; i1++)
                    for (int j1 = 0; j1 < 3; j1++)
                        f[grid[i+i1][j+j1]]++;
                bool ok = true;
                for (int k = 1; k <= 9; k++)
                    if (f[k] != 1) {
                        ok = false;
                        break;
                    }
                if (!ok) continue;
                ans++;
            }
        return ans;
    }
};
```

## 852. Peak Index in a Mountain Array

题目来源：[https://leetcode.com/problems/peak-index-in-a-mountain-array/description/](https://leetcode.com/problems/peak-index-in-a-mountain-array/description/)

难度：Easy

知识点：数组，二分查找

<del>（根本就没有把二分查找用在这种题目上的必要……）</del>

2018.11.28 UPDATE：这道题有一道Follow Up（[Leetcode 162](/post/leetcode-162-find-peak-element)）；不应该说二分查找完全没有意义，毕竟可以把复杂度降到log……

题意是，给定一个单增再单减的数组，问最大值的元素对应的`index`。

直接扫一遍找到第一个开始单减的数就好了……

```cpp
class Solution {
public:
    int peakIndexInMountainArray(vector<int>& A) {
        for (int i = 1; i < A.size(); i++) {
            if (!(A[i] > A[i - 1]))
                return i - 1;
        }
        return -1;
    }
};
```

## 859. Buddy Strings

题目来源：[https://leetcode.com/problems/buddy-strings/description/](https://leetcode.com/problems/buddy-strings/description/)

难度：Easy

知识点：字符串

这道题就是给你两个字符串，让你判断交换其中一个字符串的两个字母之后两个字符串能否相等。很简单，不过有一些细节，比如，如果两个字符串相等但是每种字母最多只有一个，则不能通过**交换**使得这两个字符串相等（虽然它们本来就是相等的）。

```cpp
class Solution {
public:
    bool buddyStrings(string A, string B) {
        int n = A.length();
        if (n != B.length()) return false;
        int differCnt = 0, dif[2];
        int cnt[26];
        memset(cnt, 0, sizeof(cnt));
        for (int i = 0; i < n; i++) {
            cnt[A[i] - 'a']++;
            if (A[i] != B[i]) {
                if (differCnt >= 2) return false;
                dif[differCnt++] = i;
            }
        }
        if (differCnt == 1) return false;
        if (differCnt == 2 && A[dif[0]] == B[dif[1]] && A[dif[1]] == B[dif[0]]) return true;
        if (differCnt == 0) {
            for (int i = 0; i < 26; i++)
                if (cnt[i] >= 2) return true;
        }
        return false;
    }
};
```