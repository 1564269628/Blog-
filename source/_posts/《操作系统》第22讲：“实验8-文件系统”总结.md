---
title: 《操作系统》第22讲：“实验8-文件系统”总结
urlname: os-mooc-lecture-22-summary
date: 2018-05-24 17:21:25
toc: true
tags: [操作系统, 课程总结]
---

## 课程内容概述

本讲介绍了ucore中的文件系统。

## 练习

来自[lec22 lab8 文件系统 在线练习](https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/09-2-lab8-quiz.md)和[lab8 文件系统 (lec 22) spoc 思考题](https://github.com/chyyuu/os_course_exercises/blob/2018spring/all/09-2-lab8-spoc-discussion.md)。

### 选择填空题

**ucore实现的文件系统抽象包括（）**

* **文件**
* **目录项**
* **索引节点**
* **安装点**

我猜这里主要说的是VFS文件系统中的内容。
* `struct file`：应用程序能够看到的各种文件信息
* `struct inode`：映射到特定文件系统的inode
* `struct fs`：保存了具体文件系统的结构、类型和信息

然后安装点是个啥我也不知道。

> 安装点是一个目录或文件，可在该处访问新文件系统、目录或文件。要安装文件系统或目录，安装点必须为一个目录；要安装文件，那么安装点必须为文件。（<https://www.ibm.com/support/knowledgecenter/zh/ssw_aix_72/com.ibm.aix.osdevice/mountpoint.htm>）

---

**ucore实现的simple FS（简称SFS）采用的文件分配机制是（）**

* 连续分配
* 链式分配
* **索引分配**
* 位图分配

SFS使用的是一级索引。

索引分配的定义：为每个文件创建一个索引数据块，指向文件数据块的指针列表；文件头包含了索引数据块指针。

---

**关于ucore实现的SFS阐述正确的是（）**

* **SFS的超级块保存在硬盘上，在加载simple FS时会读入内存中**
* **SFS的free map结构保存在硬盘上，表示硬盘可用的数据块（扇区）**
* **SFS的root-dir inode结构保存在硬盘上，表示SFS的根目录的元数据信息**
* 硬盘上的SFS ，除保存上述三种结构外，剩下的都用于保存文件的数据内容

除了前三种结构，剩下的用于保存文件的inode, dir/file的data。

---

**关于ucore实现的Virtual FS（简称VFS）阐述正确的是()**

* **已支持磁盘文件系统**
* **已支持设备文件系统**
* 已支持网络文件系统
* 已支持系统状态文件系统

> 后两种可实现，但现在还没实现

哈哈哈哈哈哈……

---

**关于ucore文件系统支持的I/O设备包括()**

* **串口设备**
* **并口设备**
* **CGA设备**
* **键盘设备**

总之这些都支持。不过好像从Lab1就有了。

### 简答题

**与文件系统相关的系统调用接口、虚拟文件系统VFS、简单文件系统SFS和设备I/O等四个部分各实现什么功能？**

* 系统调用接口：向应用进程提供文件访问的系统调用
* 虚拟文件系统VFS：屏蔽具体文件系统差异，对上提供一个统一的文件系统访问接口
* 简单文件系统SFS：解析和读写磁盘数据块中具体的SFS文件系统存储结构
* 设备I/O：完成实际磁盘设备上数据块的访问

---

**文件系统中的文件、目录、索引节点(inode)和安装点(挂载点)这几种数据结构分别支持些什么操作？**

* 文件：open/close, read/write
* 目录：open/close, read
* 索引节点：lookup, read/write
* 挂载点：mount/unmount

---

**请简要阐述ucore文件系统架构的四个组成部分。**

* 系统调用接口：用户应用使用封装后的libc库函数，文件访问的libc库函数利用文件访问系统调用来实现
* VFS：内核的系统调用（文件、目录接口）会转换成对VFS抽象的文件访问接口（索引节点、文件卷、设备等接口）的调用，VFS再把抽象的VFS接口转换成具体的文件系统SFS的访问接口
* SFS：对具体文件系统存储结构进行解析，把SFS对接口（索引节点、文件卷、设备等接口）的访问请求转换成设备数据块的访问
* I/O接口：不同具体设备上的数据块访问控制

---

**请简要说明进程proc_struct、文件file、inode之间的关系。**

* 进程控制块数据结构`proc_struct`中，`struct files_struct *filesp`指向进程的打开文件表
* 进程打开文件表中`struct file *file`指向系统打开文件中的相应文件状态数据
* VFS中的系统打开文件表中`struct inode *inode`维护打开文件的状态信息，并最终对应到磁盘上的存储数据块

---

**ucore中的进程打开文件表和系统打开文件表对应到具体的哪个数据结构上？**

* 进程打开文件表：`proc_struct`中的`struct files_struct *filesp`
* 系统打开文件表：不知道

---

**SFS在硬盘上的四大部分主要是什么，有何作用？**

* superblock：数据块大小、文件卷名字等文件卷信息
* root-dir inode：根目录的inode信息（存储位置等）
* freemap：数据块占用状态信息
* data block：inode/文件数据/目录数据

---

**硬盘上的SFS是如何加载到ucore中并初始化的？**

ucore docs Lab8：
>在`sfs_fs.c`文件中的`sfs_do_mount`函数中，完成了加载位于硬盘上的SFS文件系统的超级块superblock和freemap的工作。这样，在内存中就有了SFS文件系统的全局信息。

---

**硬盘上的inode和内存中的inode的关系和区别是什么？**

内存中的inode数据结构sfs_inode中有一个字段sfs_disk_inode，它对应磁盘上的inode。

ucore docs Lab8：
>SFS中的磁盘索引节点代表了一个实际位于磁盘上的文件。
……
可以看到SFS中的内存inode包含了SFS的硬盘inode信息，而且还增加了其他一些信息，这属于是便于进行是判断否改写、互斥操作、回收和快速地定位等作用。需要注意，一个内存inode是在打开一个文件后才创建的，如果关机则相关信息都会消失。而硬盘inode的内容是保存在硬盘中的，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据

---

**描述file, dir, inode在内存和磁盘上的格式和相关操作。**

每一种类型的数据块都在SFS层中有对应的操作函数指针和数据结构定义。

事实上，file、dir和inode在内存和磁盘上都以inode形式存储：
* 内存：`struct sfs_disk_inode`
* 磁盘：inode

> 通过上表可以看出，如果inode表示的是文件，则成员变量direct[]直接指向了保存文件内容数据的数据块索引值。indirect间接指向了保存文件内容数据的数据块，indirect指向的是间接数据块（indirect block），此数据块实际存放的全部是数据块索引，这些数据块索引指向的数据块才被用来存放文件内容数据。
对于普通文件，索引值指向的block中保存的是文件中的数据。而对于目录，索引值指向的数据保存的是目录下所有的文件名以及对应的索引节点所在的索引块（磁盘块）所形成的数组。

---

**file数据结构的主要内容是什么？与进程的关系是什么？**

`struct file`数据结构定义在`lab8/kern/fs/file.h`中：
```
struct file {
    enum {
        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,
    } status;
    bool readable;
    bool writable;
    int fd;
    off_t pos;
    struct inode *node;
    int open_count;
};
```

`struct file`数据结构的内容包括：
* `status`：文件状态
* `bool readable & writable`：文件操作类型
* `int fd`：文件描述符
* `off_t pos`：文件指针
* `struct inode *node`：对应系统打开文件表项指针
* `int open_count`：文件打开计数

`struct file`就是进程打开文件表对应的数据结构。

---

**inode数据结构的主要内容是什么？与file的数据结构的关系是什么？**

`struct inode`数据结构定义在`lab8/kern/fs/vfs/inode.h`中：
```
struct inode {
    union {
        struct device __device_info;
        struct sfs_inode __sfs_inode_info;
    } in_info;
    enum {
        inode_type_device_info = 0x1234,
        inode_type_sfs_inode_info,
    } in_type;
    int ref_count;
    int open_count;
    struct fs *in_fs;
    const struct inode_ops *in_ops;
};
```

`struct inode`数据结构的内容：
* `in_info & in_type`：文件类型
* `ref_count & open_count`：引用计数
* `struct fs *in_fs`：对下具体文件操作函数指针
* `const struct inode_ops *in_ops`：对上inode操作函数指针

`struct inode`就是系统打开文件表对应的数据结构。

---

**inode_ops包含哪些与文件相关的操作？**

`struct inode_ops`数据结构定义在`lab8/kern/fs/vfs/inode.h`中，它是上层使用的inode操作函数：
```
struct inode_ops {
    unsigned long vop_magic;
    int (*vop_open)(struct inode *node, uint32_t open_flags);
    int (*vop_close)(struct inode *node);
    int (*vop_read)(struct inode *node, struct iobuf *iob);
    int (*vop_write)(struct inode *node, struct iobuf *iob);
    int (*vop_fstat)(struct inode *node, struct stat *stat);
    int (*vop_fsync)(struct inode *node);
    int (*vop_namefile)(struct inode *node, struct iobuf *iob);
    int (*vop_getdirentry)(struct inode *node, struct iobuf *iob);
    int (*vop_reclaim)(struct inode *node);
    int (*vop_gettype)(struct inode *node, uint32_t *type_store);
    int (*vop_tryseek)(struct inode *node, off_t pos);
    int (*vop_truncate)(struct inode *node, off_t len);
    int (*vop_create)(struct inode *node, const char *name, bool excl, struct inode **node_store);
    int (*vop_lookup)(struct inode *node, char *path, struct inode **node_store);
    int (*vop_ioctl)(struct inode *node, int op, void *data);
};
```

文件中有每个操作的详细注释
* open：打开文件
* close：关闭文件
* read：读文件
* write：写文件
* fstat：读文件信息
* fsync：将脏缓存写回持久化存储介质
* namefile：计算文件相对于文件系统根目录的路径
* getdirentry：从目录中读一个文件名
* reclaim：回收inode
* gettype：文件种类
* tryseek：检查移动文件指针是否合法
* truncate：重设文件大小，丢弃多余的数据
* create：在目录中新建文件
* lookup：在给定目录中按文件名查找文件
* ioctl：管理I/O通道（？？）

---

**VFS是如何把键盘、显示输出和磁盘文件统一到一个系统调用访问框架下的？**

* VFS把键盘、显示和磁盘文件都视为文件，VFS对上提供的访问接口都是文件访问接口
* VFS通过区别文件类型、文件操作类型、设备类型等来区别同类操作在不同设备的不同实现

---

**device数据结构的主要内容是什么？与fs的关系是什么？与inode的关系是什么？**

这里的`device`指的应该是`lab8/kern/fs/devs/dev.h`中定义的`struct device`：
```
/*
 * Filesystem-namespace-accessible device.
 * d_io is for both reads and writes; the iobuf will indicates the direction.
 */
struct device {
    size_t d_blocks;
    size_t d_blocksize;
    int (*d_open)(struct device *dev, uint32_t open_flags);
    int (*d_close)(struct device *dev);
    int (*d_io)(struct device *dev, struct iobuf *iob, bool write);
    int (*d_ioctl)(struct device *dev, int op, void *data);
};
```

`struct device`数据结构的内容：
* `size_t d_blocks`：数据块个数
* `size_t d_blocksize`：数据块大小
* 设备操作函数指针（`d_open`, `d_close`, `d_io`, `d_ioctl`）

fs和inode通过device数据结构中的设备操作函数指针实现对设备数据块的访问。

---

**比较ucore中I/O接口、SFS文件系统接口和文件系统的系统调用接口的操作函数有什么异同？**

* 文件系统的系统调用接口（`lab8/kern/syscall/syscall.c`）：sys_open, sys_close, sys_read, sys_write, sys_seek, sys_fstat, sys_fsync, sys_chdir, sys_getcwd, sys_mkdir, sys_link, sys_rename, sys_unlink, sys_getdirentry, sys_dup, sys_pipe, sys_mkfifo, sys_mount, sys_umount, sys_ioctl
* VFS文件系统接口（`lab8/kern/vfs/vfs.h`）：vfs_open, vfs_close, vfs_link, vfs_symlink, vfs_readlink, vfs_mkdir, vfs_unlink, vfs_rename, vfs_chdir, vfs_getcwd
* SFS文件系统接口（`lab8/kern/sfs/sfs.h`）：sfs_rblock, sfs_wblock, sfs_rbuf, sfs_wbuf, sfs_sync_super, sfs_sync_freemap, sfs_clear_block, sfs_load_inode
* I/O接口（`lab8/kern/devs/dev.h`）：d_open, d_close, d_io, d_ioctl

### 实践题

**理解文件访问的执行过程，即在ucore运行过程中通过`cprintf`函数来完整地展现出来读一个文件在ucore中的整个执行过程，(越全面细致越好) 完成代码填写，并形成spoc练习报告，需写练习报告和简单编码，完成后放到git server 对应的git repo中。**

啊，这个完全没有时间去写了……

---

**在下面的实验代码的基础上，实现基于文件系统的pipe IPC机制。练习用的[lab8 spoc exercise project source code](https://github.com/chyyuu/ucore_lab/tree/master/labcodes_answer/lab8_result)**

呃，这是lab8的附加题……
